
static char *rcsid = "$Header: /dsl/HeliosRoot/Helios/cmds/com/RCS/sysbuild.c,v 1.13 1994/08/10 09:14:39 al Exp $";

#include <stdio.h>
#include <module.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "getargs.h" /* AM */

#ifndef WORD
typedef long WORD;
typedef char *STRING;
typedef unsigned char UBYTE;
#endif

/*
 * Helios system builder
 *
 * Takes as input a set of image files generated by the assembler and
 * combines them into a single image suitable for booting into a transputer.
 * The file consists of an initial size word (in little-endian order), followed
 * by a sequence of self-relative pointers to the start of each image, followed
 * by the images themselves.
 *
 * Author: NHG   Changes Feb 88: TJK
 */

#if defined(IBMPC) || defined(__HELIOS)
# define MEMSIZE 500000L	/* 500k max nucleus size */
#else
# define MEMSIZE 1000000L	/* 1Mb max nucleus */
#endif

UBYTE *image;
UBYTE *iptr;
WORD isize;
WORD ptabsize;
FILE* infd;
FILE* outfd;

#ifdef IBMPC
UBYTE *lmalloc();
extern unsigned fread();
#endif


WORD swap(WORD x )
#ifdef BYTE_SEX_ODD
{
        WORD r = 0;
        r |= ((x>>24)&0xff)<< 0;
        r |= ((x>>16)&0xff)<< 8;
        r |= ((x>> 8)&0xff)<<16;
        r |= ((x>> 0)&0xff)<<24;
	return r;
}
#else
{ return(x); }
#endif

void
tidyup(WORD rc )
{
	if ( infd  != 0 ) fclose(infd);
	if ( outfd != 0 ) fclose(outfd);
	if ( image != 0 ) free(image);
	exit( (int) rc);
}

void
error(
      STRING str,
      ... )
{
  va_list	args;
  
  va_start( args, str );  
  vprintf(str,args);
  va_end(args);
  
  putchar('\n');
  tidyup(20L);
}

int
main(
int argc,
STRING *argv )
{
	WORD 		p, pp;
	WORD 		*iwd;
	WORD 		sz;
	STRING		dstname;
	ArgStack	*argstack = NULL;

	argc -= 2;
	argv++;
	dstname = argv[0];
	infd  = outfd = NULL;
	image = NULL;

	if( argc <= 0 ) error("Usage: sysbuild systemfile imagefile...");

	/* Find out the table size */
	{
		int 	keepargc = argc;
		STRING 	*keepargv = argv;
		int	cnt = 0;

		/* Skip nucleus */		
		argv++;

		/* Count the real arguments */
		while ( (*argv != NULL) || (argstack != NULL) ) {
			if (*argv == NULL) {
				popargs(&argstack, &argc, &argv);
				continue;
			}

			if ( **argv == '@') {
				char **argfile;

				argfile = getargs((*argv)+1, &argc);
				if (argfile == NULL) { 
					error("Unable to open or create arguments from %s\n", (*argv)+1);
				} else {
					/* argv+1 is pushed so we return to the next argv */
					pushargs(&argstack, argc-1, argv+1);
					argv = argfile;
				}

				continue;
			}

			argv++;
			cnt++;
		}

		/* Restore settings */
		argc = keepargc;
		argv = keepargv;

		/* Free memory */
		freeargs();

		ptabsize = cnt;
	}

#if defined (IBMPC) || defined (MWC)
	image = lmalloc(MEMSIZE);
#else
	image = (UBYTE *)malloc((int) MEMSIZE);
#endif

	if( image == 0 ) error("Cannot allocate memory");

	/* The marker for SCCS: @(#) */
	printf("Helios System Builder V1.7 21/6/90\n");
	printf("(C) 1990-1993 Copyright Perihelion Distributed Software");
	printf(" All Rights Reserved.\n");

	iptr = image + (8 + ptabsize*4);
	iwd  = (WORD *)image;
	isize = iptr - image;

	p = 0;
	pp = 0;

	while( (pp++ != argc) || (argstack != NULL)  )
	{
		WORD hdr[3];
		WORD fsize;
		int s;

#if 0
		WORD mn;
#endif
		char *nptr = argv[pp];

		if (pp > argc) {
			popargs(&argstack, &argc, &argv);
			pp = -1;
			continue;
		}

		if ( *nptr == '@') {
			char **argfile;
			int c;

			argfile = getargs(nptr+1, &c);
			if (argfile == NULL) { 
				error("Unable to open or create arguments from %s\n", nptr+1);
			} else {
				/* argv+1 is pushed so we return to the next argv */
				pushargs(&argstack, argc-pp-1, argv+pp+1);
				argv = argfile;
				argc = c - 1;
				pp = -1;
			}

			continue;
		}

		/* Next image file */
		p++;

#if defined(SUN4) || defined(R140)
		infd = fopen(nptr,"r");
#else
		infd = fopen(nptr,"rb");
#endif
		if( infd == NULL ) 
			error("Cannot open %s for input",nptr);

		if((s=fread(hdr,1,12,infd)) != 12 )
			error("Cannot read image file header: %s %ld",nptr,s);

		/* Extract final part of name */
		nptr = nptr + strlen(nptr);
		while (*nptr != '/' && *nptr != '\\' && nptr >= argv[pp])
		  nptr--;

		nptr++;

#if 0
		/* cut this check out as we wish to use one version of */
		/* sysbuild on a host for multiple cpu targets */
		mn = swap(hdr[0]);

		if(mn != Image_Magic )
			error("Bad magic number in file %s",argv[pp]);
#endif
		
		fsize = swap(hdr[2]);

		if (((isize + fsize + 3) & ~3) > MEMSIZE)
			error("Image size too large\n");

#if defined (IBMPC) || defined (MWC)
	{
		WORD s = fsize;
		UBYTE *b = iptr;
		while( s > 0 )
		{
			int tfr = s > 30000L ? 30000 : s;
			if(fread(b,1,tfr,infd) != tfr )
				error("Bad header in file %s %ld %ld",argv[pp],sz,fsize);
			s = s-tfr;
			b = (UBYTE *)((WORD)b + tfr);
		}
	}
#else
		if((sz=fread(iptr,1,(int)fsize,infd)) != fsize)
			error("Bad header in file %s %ld %ld",argv[pp],sz,fsize);
#endif
		printf("%20s: offset %#8lx size %#8lx\n", nptr, isize, fsize );

		/* align to next word boundary */
		fsize = (fsize+3) & (~3);

		isize += fsize;

		if (isize > MEMSIZE ) error("Run out of memory\n");

		{

#if defined (IBMPC) || defined (MWC)
			WORD ip = (WORD)iptr - ((WORD)image + 4*p);
			iptr = (UBYTE *)((WORD)iptr + fsize);
#else
			WORD ip = iptr - image - 4*p;
			iptr += fsize;
#endif
			iwd[p] = swap(ip);
		}
		

		fclose(infd); infd = 0;
	}
	p++;

	iwd[0] = swap(isize);
	iwd[p] = 0L;

#if defined(MWC) || defined(IBMPC)
	/* Messing around here because of MWC restrictions */
	outfd = fopen(dstname,"wb");
	if( outfd == NULL ) 
		error("Cannot open %s for output",dstname);

	{
		WORD s = isize;
		UBYTE *b = image;
		while( s > 0 )
		{
			int tfr = s > 30000L ? 30000 : s;
			fwrite(b,1,tfr,outfd);
			s = s-tfr;
			b = (UBYTE *)((WORD)b + tfr);
		}
	}
#else
#if defined(SUN4) || defined(R140)
	outfd = fopen(dstname,"w");
#else
	outfd = fopen(dstname,"wb");
#endif
	if( outfd == NULL ) 
		error("Cannot open %s for output",dstname);
	if (fwrite(image,1,(int)isize,outfd) != isize) printf("Write failed\n");
#endif

	fclose(outfd); outfd = NULL;
	
	printf("System size = %#lx (%ld)\n",isize, isize);

	tidyup(0L);
	freeargs();
}
