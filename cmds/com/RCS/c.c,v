head	1.137;
access;
symbols
	Helios_1_3_1:1.128
	Helios_C40_1_3_Official_Release:1.118
	Alenia_release:1.115
	Helios1_3:1.107
	C40_Field_Test_2:1.102
	C40_Field_Test_R1:1.68
	Helios13_beta:1.68
	Helios1_2_2:1.52
	Helios1_2_2Beta:1.47
	Helios1_2_1:1.34
	Helios1_2:1.16;
locks
	nickc:1.137; strict;
comment	@ * @;


1.137
date	94.06.13.11.53.45;	author nickc;	state Exp;
branches;
next	1.136;

1.136
date	94.03.31.10.19.32;	author nickc;	state Exp;
branches;
next	1.135;

1.135
date	94.03.22.14.29.46;	author nickc;	state Exp;
branches;
next	1.134;

1.134
date	94.03.08.11.02.29;	author nickc;	state Exp;
branches;
next	1.133;

1.133
date	94.03.03.12.10.36;	author nickc;	state Exp;
branches;
next	1.132;

1.132
date	94.03.01.14.10.17;	author nickc;	state Exp;
branches;
next	1.131;

1.131
date	94.03.01.13.37.28;	author nickc;	state Exp;
branches;
next	1.130;

1.130
date	94.02.24.13.17.12;	author nickc;	state Exp;
branches;
next	1.129;

1.129
date	94.02.18.09.30.58;	author nickc;	state Exp;
branches;
next	1.128;

1.128
date	93.10.05.14.09.31;	author nickc;	state Exp;
branches;
next	1.127;

1.127
date	93.09.15.16.16.59;	author nickc;	state Exp;
branches;
next	1.126;

1.126
date	93.08.10.15.48.32;	author nickc;	state Exp;
branches;
next	1.125;

1.125
date	93.08.08.17.11.59;	author paul;	state Exp;
branches;
next	1.124;

1.124
date	93.08.04.15.30.48;	author bart;	state Exp;
branches;
next	1.123;

1.123
date	93.07.12.12.48.04;	author nickc;	state Exp;
branches;
next	1.122;

1.122
date	93.07.05.12.54.58;	author nickc;	state Exp;
branches;
next	1.121;

1.121
date	93.06.25.10.29.43;	author nickc;	state Exp;
branches;
next	1.120;

1.120
date	93.06.10.17.04.50;	author nickc;	state Exp;
branches;
next	1.119;

1.119
date	93.06.09.15.01.18;	author nickc;	state Exp;
branches;
next	1.118;

1.118
date	93.03.16.14.10.38;	author nickc;	state Exp;
branches;
next	1.117;

1.117
date	93.03.15.12.06.02;	author nickc;	state Exp;
branches;
next	1.116;

1.116
date	93.01.15.11.22.14;	author nick;	state Exp;
branches;
next	1.115;

1.115
date	92.12.08.14.22.56;	author nickc;	state Exp;
branches;
next	1.114;

1.114
date	92.12.03.11.05.19;	author nickc;	state Exp;
branches;
next	1.113;

1.113
date	92.12.03.11.04.07;	author nickc;	state Exp;
branches;
next	1.112;

1.112
date	92.11.13.14.00.20;	author nickc;	state Exp;
branches;
next	1.111;

1.111
date	92.11.13.13.47.14;	author nickc;	state Exp;
branches;
next	1.110;

1.110
date	92.11.12.18.26.03;	author nickc;	state Exp;
branches;
next	1.109;

1.109
date	92.11.04.18.55.38;	author nickc;	state Exp;
branches;
next	1.108;

1.108
date	92.11.04.18.45.32;	author nickc;	state Exp;
branches;
next	1.107;

1.107
date	92.10.28.16.40.35;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	92.10.28.16.21.30;	author nickc;	state Exp;
branches;
next	1.105;

1.105
date	92.10.21.09.17.03;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	92.10.21.09.05.32;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	92.10.20.10.59.32;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	92.10.14.16.57.29;	author martyn;	state Exp;
branches;
next	1.101;

1.101
date	92.10.12.11.30.53;	author nickc;	state Exp;
branches;
next	1.100;

1.100
date	92.10.12.09.41.48;	author nickc;	state Exp;
branches;
next	1.99;

1.99
date	92.10.06.10.47.53;	author nickc;	state Exp;
branches;
next	1.98;

1.98
date	92.09.30.13.50.50;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	92.09.30.13.49.25;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	92.09.16.17.21.26;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	92.09.15.15.16.42;	author nickc;	state Exp;
branches;
next	1.94;

1.94
date	92.09.15.10.07.07;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	92.09.02.16.45.08;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	92.09.01.13.49.14;	author nickc;	state Exp;
branches;
next	1.91;

1.91
date	92.09.01.13.25.36;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	92.08.21.16.32.33;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	92.08.20.15.31.07;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	92.08.19.16.16.25;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	92.08.19.13.33.52;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	92.08.13.08.11.44;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	92.08.12.17.01.27;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	92.08.12.13.41.38;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	92.07.30.11.28.03;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	92.07.30.10.46.31;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	92.07.29.15.46.26;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	92.07.29.15.39.40;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	92.07.29.15.37.43;	author nickc;	state Exp;
branches;
next	1.78;

1.78
date	92.07.29.14.50.17;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	92.07.28.17.06.19;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	92.07.28.14.47.36;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	92.07.24.07.58.43;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	92.07.14.14.56.27;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	92.07.13.17.22.12;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	92.07.10.15.00.34;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	92.07.10.08.29.58;	author paul;	state Exp;
branches;
next	1.70;

1.70
date	92.07.08.08.56.15;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	92.07.06.16.44.41;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	92.06.26.16.21.33;	author bart;	state Exp;
branches;
next	1.67;

1.67
date	92.06.25.14.25.17;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	92.06.25.10.47.20;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	92.06.24.17.06.20;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	92.06.24.08.51.04;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	92.06.15.11.58.56;	author paul;	state Exp;
branches;
next	1.62;

1.62
date	92.03.30.11.52.48;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	92.03.30.11.34.35;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	92.03.24.19.36.23;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	92.03.24.19.31.00;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	92.03.24.17.38.33;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	92.03.24.17.11.06;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	92.03.23.18.21.39;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	92.03.23.17.17.43;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	92.03.03.08.38.56;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	92.02.13.13.51.55;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	91.11.12.12.34.14;	author martyn;	state Exp;
branches;
next	1.51;

1.51
date	91.11.12.11.53.42;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	91.10.14.09.41.45;	author paul;	state Exp;
branches;
next	1.49;

1.49
date	91.09.27.15.08.04;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	91.09.02.11.21.15;	author martyn;	state Exp;
branches;
next	1.47;

1.47
date	91.06.07.14.48.17;	author ben;	state Exp;
branches;
next	1.46;

1.46
date	91.06.05.16.50.28;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	91.06.04.09.03.51;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	91.05.30.14.19.34;	author ben;	state Exp;
branches;
next	1.43;

1.43
date	91.05.07.14.42.40;	author ben;	state Exp;
branches;
next	1.42;

1.42
date	91.05.07.09.25.44;	author ben;	state Exp;
branches;
next	1.41;

1.41
date	91.04.23.13.28.20;	author ben;	state Exp;
branches;
next	1.40;

1.40
date	91.04.15.18.26.25;	author martyn;	state Exp;
branches;
next	1.39;

1.39
date	91.04.12.15.01.27;	author ben;	state Exp;
branches;
next	1.38;

1.38
date	91.04.10.15.46.59;	author ben;	state Exp;
branches;
next	1.37;

1.37
date	91.04.09.16.46.50;	author ben;	state Exp;
branches;
next	1.36;

1.36
date	91.04.09.14.19.18;	author ben;	state Exp;
branches;
next	1.35;

1.35
date	91.04.05.16.45.55;	author bart;	state Exp;
branches;
next	1.34;

1.34
date	91.03.21.17.41.35;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	91.03.13.17.52.36;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	91.03.11.18.09.41;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	91.03.06.12.33.40;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	91.03.04.15.33.06;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	91.02.25.15.01.32;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	91.02.25.14.58.15;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	91.02.22.11.06.59;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	91.02.07.15.20.42;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	91.01.23.16.58.58;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	91.01.22.14.12.22;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	91.01.10.12.29.25;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	91.01.10.12.19.35;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	91.01.09.10.43.05;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	91.01.08.15.43.19;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	91.01.08.15.40.56;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	91.01.08.14.00.28;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	91.01.08.13.44.46;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	90.11.16.14.21.51;	author nick;	state Exp;
branches;
next	1.15;

1.15
date	90.11.16.14.09.55;	author nick;	state Exp;
branches;
next	1.14;

1.14
date	90.11.14.12.11.29;	author martyn;	state Exp;
branches;
next	1.13;

1.13
date	90.10.24.10.19.27;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	90.10.23.17.39.07;	author martyn;	state Exp;
branches;
next	1.11;

1.11
date	90.10.18.15.51.14;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	90.10.10.12.27.40;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	90.10.09.14.45.56;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	90.09.19.11.24.36;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	90.09.18.14.28.55;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	90.09.18.13.20.34;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	90.09.05.11.18.55;	author nick;	state Exp;
branches;
next	1.4;

1.4
date	90.08.29.12.19.21;	author nick;	state Exp;
branches;
next	1.3;

1.3
date	90.08.28.10.11.52;	author nick;	state Exp;
branches;
next	1.2;

1.2
date	90.08.23.09.50.36;	author james;	state Exp;
branches;
next	1.1;

1.1
date	90.08.22.16.00.32;	author james;	state Exp;
branches;
next	;


desc
@c compilier driver
@


1.137
log
@does not complain about bad c_libdir if only compiling
@
text
@/*{{{  Header */

/*
 * C => C & FORTRAN & Modula-2 compilers and assembler front end for Helios.
 *
 * Original version by Tim Glauert.
 *
 * Tidied up and extended by NC, THG, NHG, and PLC
 *
 * This code is Copyright (c) 1990, 1991, 1992, 1993, 1994 Perihelion Software Ltd.
 *   All Rights Reserved.
 *
 * RCS version: $Revision: 1.1.1.1 $
 * RCS date:    $Date: 1994/05/10 09:20:23 $
 */

#define VERSION		1
#define REVISION	64
#define DATE		05/10/93

/*}}}*/
/*{{{  Revision Log */

/*
 * 12 - added -q<> option to enable compiler debugging options
 *
 * 13 - allowed objed commands to be used even with a -B option
 *
 * 14 - added -DATW to automatic defines
 *
 * 15 - added -n<string> option to allow name of objed to be defined
 *
 * 16 - added multiple, comma seperated paths in -I
 *
 * 17 - added -R option to prevent loading RAM disk
 *
 * 18 - added environment variables
 *
 * 19 - FORTRAN 77 support added; uses posix execvp to execute programs 
 *
 * 20 - added -Fg option to remove procedure names
 *
 * 21 - made sure c fails if compiler(s) could not be found
 *
 * 22 - added automatic detection of RAM disk and reversed sense of -R option
 *
 * 23 - added -a, -z and -Z options to pass on flags to assembler and compilers respectivly
 *
 * -- missing versions 24 to 26 due to hard disk collapse -- I have tried to recreate them below
 *
 * 24 - added -Fn to turn off the vector stack
 *
 * 25 - added -r to allow compilation of device drivers
 *
 * 26 - added "-" as an output filename, meaning stdout
 *
 * -- back on track (I hope)
 *
 * 27 - added control-C handling - but not very good
 *
 * 28 - added -f option to generate name for virtual memory file
 *
 * 29 - prevented the inclusion of ',' in the search path for <> type includes
 *
 * 30 - allowed -s option to have a space before the number
 *
 * 31 - added file support for Rowley Modula-2 compiler.
 *	fixed some spelling and punctuation mistakes in the usage message.
 *
 * 32 - made -L option the same as the -l option (for backwards compatability)
 *      tidied up AddLibrary()
 *      added -wA and -FA options
 *      changed MACHINENAME to B008
 *
 * 33 - changed LIBDIR to C_LIBDIR and INCDIR to C_INCDIR to avoid conflicts 
 *      with the Imake utility
 *
 * 34 - added '*.lib' and 'lib*.a' to the library search pattern, and made an error messgae
 *      be produced if the library could not be found
 *
 * 35 - fixed AddLibrary() to distinguish between scanned and resident libraries
 *
 * 36 - added -E option and allowed .i as .c files
 *
 * 37 - recognise '.lib' as a valid extension for joining libraries
 *
 * 38 - recognises '-lm' as a UNIX abbreviation for the maths libraries
 *
 * 39 - added function AddLibraryName() to add names to the library list whilst
 *      preventing duplicate entries
 *
 * 40 - changed linking for C programs to use c0.o c.lib and helios.lib
 *
 * 41 - added -y option to pass text on to the macro assembler
 *
 * 42 - added -T5 option (for the T425),
 *      and sorted out multiple '-t' options in C compiler command line
 *      and added C_NONSTANDRD environment flag to enable various non-standard features
 *      and removed signal handling as Posix now does this automatically
 *
 * 43 - added support for compiling under UNIX
 *      and the use of pipes in non-standard mode
 *
 * 44 - added -T9 option (for the T810)
 *
 * 45 - fixed bug with pipe usage casuing C to return -1
 *
 * 46 - replaced use of access() with stat() so that we can detect non-file
 *      type names.
 *
 * 47 - changed -L option to match UNIX version and added -Wc,arg[,arg ..]
 *      compilation phase processing
 *
 * 48 - unknown!
 *
 * 49 - fixed AddLibrary, so that all libraries are linked with the -l option
 *    - fixed generation of FORTRAN temporary file names
 *
 * 50 - tried to fix bugs with return codes and library names
 *
 * 51 - Added /include to default search path for includes (this is Bart's include service)
 *
 * 52 - Added '-u' option to prevent files from being deleted
 *      Separated libraries into scanned and resident
 *      Added '-Fu' to enable the linker reporting unreferenced labels
 *
 * 53 - can now be used as a host utility on Sun4 etc.
 *
 * 54 - moved all machine dependent defines to makefile
 *
 * 55 - removed automatic detection of endian-ism of host as this is no longer needed
 *
 * 56 - fixed return codes to conform to POSIX spec
 *
 * 57 - added code to cope with being a front end to the new transputer compiler.
 *
 * 58 - added code to cope with the C40 compiler
 *
 * 59 - improved compiler type switching code
 *
 * 60 - added -J option to build libraries incrementally
 *
 * 61 - added OLD_TRAN to NEW_NCC options to allow old style transputer builds using environment
 *
 * 62 - cleaned up help text to reduce code and data sizes
 *
 * 63 - Added 68K support and folding in the sources
 *
 * 64 - Added RemoveLibraryPath function to cope with c_libdir being changed by command line switches
 */

/*}}}*/
/*{{{  Header Files */

#include <stdio.h>

#ifdef UNIX

#include "queue.h"

#ifndef true

#define bool 		int
#define false 		0
#define true  		1
#define Null( a )	((a *) NULL)
#define TRUE  		1
#define FALSE 		0

#endif

#else /* ! UNIX */

#include <helios.h>
#include <queue.h>

#endif /* UNIX */

#ifndef R140
#include <stdlib.h>
#else
#include <sys/types.h>
#endif

#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif

#include <string.h>

#ifndef UNIX
#include <nonansi.h>
#include <posix.h>
#endif

#include <signal.h>

#ifndef R140

#include <unistd.h>

#ifndef UNIX
#include <syslib.h>
#endif

#endif /* R140 */

#ifndef UNIX
#include <syslib.h>
#endif

#ifdef RS6000
#define _XOPEN_SOURCE
#endif

#include <sys/wait.h>
#include <errno.h>
#include <sys/stat.h>
#include <ctype.h>

#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS 0
#endif

#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif

/*}}}*/
/*{{{  Constants */

#ifdef UNIX
#  define const
#endif

#ifdef R140
#  define SEEK_END 2
#  define L_tmpnam 25
typedef	int	pid_t;
extern int	errno;
#endif /* R140 */

#ifdef RS6000
#define vfork	fork
#endif

/* NB defines below are default values; should be defined in m. dep makefile. */

#ifdef UNIX

#ifndef SHELL
#define SHELL			"/bin/sh"
#endif

#ifndef PRE_PROCESSOR
#define PRE_PROCESSOR		"/lib/cpp"
#endif

#ifndef REMOVER
#define REMOVER			"/bin/rm"
#endif

#else /* ! UNIX */

#ifndef SHELL
#define SHELL			"/helios/bin/shell"
#endif

#ifndef PRE_PROCESSOR
#define PRE_PROCESSOR		"/helios/bin/ncc"
#endif

#ifndef REMOVER
#define REMOVER			"/helios/bin/rm"
#endif

#endif /* UNIX */

#ifndef TRANSPUTER_CC
#define TRANSPUTER_CC		"/helios/bin/cc"
#endif

#ifndef C40_CC
#define C40_CC			"/helios/bin/ncc"
#endif

#ifndef M68K_CC
#define M68K_CC			"/helios/bin/ncc"
#endif

#ifndef ARM_CC
#define ARM_CC			"/helios/bin/ncc"
#endif

#ifndef I860_CC
#define I860_CC			"/helios/bin/ncc"
#endif

#ifndef C_COMPILER
 #ifdef __TRAN
  #define C_COMPILER		TRANSPUTER_CC
 #else
  #ifdef __C40
  #define C_COMPILER		C40_CC
  #else
   #ifdef __ARM
   #define C_COMPILER		ARM_CC
   #else
    #ifdef __M68K
     #define C_COMPILER		M68K_CC
    #endif
   #endif
  #endif
 #endif
#endif

#ifndef F77_PASS1
# define F77_PASS1		"/helios/bin/f77p1"
#endif

#ifndef F77_PASS2
# define F77_PASS2		"/helios/bin/f77p2"
#endif

#ifndef M2_COMPILER
# define M2_COMPILER		"/helios/bin/mc"
#endif

#ifndef TRANSPUTER_ASSEMBLER
 #define TRANSPUTER_ASSEMBLER	"/helios/bin/asm"
#endif

#ifndef C40_ASSEMBLER
# define C40_ASSEMBLER		"/helios/bin/as"
#endif

#ifndef M68K_ASSEMBLER
# define M68K_ASSEMBLER		"/helios/bin/as"
#endif

#ifndef ARM_ASSEMBLER
 #define ARM_ASSEMBLER		"/helios/bin/as"
#endif

#ifndef ASSEMBLER
# ifdef __TRAN
#  define ASSEMBLER		TRANSPUTER_ASSEMBLER
# else
#  ifdef __C40
#   define ASSEMBLER		C40_ASSEMBLER
#  else
#   ifdef __ARM
#    define ASSEMBLER		ARM_ASSEMBLER
#   else
#    ifdef __M68K
#     define ASSEMBLER		M68K_ASSEMBLER
#    endif
#   endif
#  endif
# endif
#endif

#ifndef TRANSPUTER_LINKER
# define TRANSPUTER_LINKER	"/helios/bin/asm"
#endif

#ifndef C40_LINKER
# define C40_LINKER		"/helios/bin/ld"
#endif

#ifndef M68K_LINKER
# define M68K_LINKER		"/helios/bin/ld"
#endif

#ifndef ARM_LINKER
# define ARM_LINKER		"/helios/bin/ld"
#endif

#ifndef I860_LINKER
# define I860_LINKER		"/helios/bin/ld"
#endif

#ifndef LINKER
# ifdef __TRAN
#  define LINKER			TRANSPUTER_LINKER
# else
#  ifdef __C40
#   define LINKER			C40_LINKER
#  else
#   ifdef __ARM
#    define LINKER			ARM_LINKER
#   else
#    ifdef __M68K
#     define LINKER			M68K_LINKER
#    endif
#   endif
#  endif
# endif
#endif

#ifndef MACRO
# define MACRO			"/helios/bin/ampp"
#endif

#ifndef C40_C_LIBDIR
# define C40_C_LIBDIR		"/helios/lib/"
#endif

#ifndef M68K_C_LIBDIR
# define M68K_C_LIBDIR		"/helios/lib/"
#endif

#ifndef ARM_C_LIBDIR
# define ARM_C_LIBDIR		"/helios/lib/"
#endif

#ifndef TRANSPUTER_C_LIBDIR
# define TRANSPUTER_C_LIBDIR	"/helios/lib/"
#endif

#ifndef C_LIBDIR
# ifdef __TRAN
#  define C_LIBDIR		TRANSPUTER_C_LIBDIR
# else
#  ifdef __C40
#   define C_LIBDIR		C40_C_LIBDIR
#  else
#   ifdef __ARM
#    define C_LIBDIR		ARM_C_LIBDIR
#   else
#    ifdef __M68K
#     define C_LIBDIR		M68K_C_LIBDIR
#    endif
#   endif
#  endif
# endif
#endif

#ifndef C_INCDIR
# define C_INCDIR		"/helios/include/"
#endif

#ifndef MACDIR
# define MACDIR			"/helios/include/ampp/"
#endif

#ifndef SYMDIR
# define SYMDIR			"/helios/symbols/"
#endif

#define LINK_HELIOS		"helios.lib"
#define LINK_CSTART		"c0.o"
#define LINK_CLIB		"c.lib"
#define LINK_FSTART		"fstart.o"
#define LINK_M2START		"m2start.o"
#define BASIC			"basic.m"
#define OBJNAME			"a.out"

#ifndef ARM_MACHINENAME
#define ARM_MACHINENAME		"ARM"
#endif

#ifndef I860_MACHINENAME
#define I860_MACHINENAME	"i860"
#endif

#ifndef TRANSPUTER_MACHINENAME
#define TRANSPUTER_MACHINENAME	"TRANSPUTER"
#endif

#ifndef C40_MACHINENAME
#define C40_MACHINENAME		"TMS320C40"
#endif

#ifndef M68K_MACHINENAME
#define M68K_MACHINENAME	"M68000"
#endif

#ifndef MACHINENAME
# ifdef __ARM
#  define MACHINENAME		ARM_MACHINENAME
# else
#  ifdef __I860
#   define MACHINENAME		I860_MACHINENAME
#  else
#   ifdef __C40
#    define MACHINENAME		C40_MACHINENAME
#   else
#    ifdef __M68K
#     define MACHINENAME	M68K_MACHINENAME
#    else
#     ifdef __TRAN
#      define MACHINENAME	TRANSPUTER_MACHINENAME
#     endif
#    endif
#   endif
#  endif
# endif
#endif

#ifndef MACHINENAME
# define MACHINENAME		"Unknown_CPU_type"
#endif

#define ARGBUFSIZE	1024

/*}}}*/
/*{{{  Macros */

#define _is_norcroft_compiler	(compiler == ARM_COMPILER ||  \
				 compiler == C40_COMPILER ||  \
				 compiler == M68K_COMPILER || \
				 compiler == I860_COMPILER )

#define _is_transputer_compiler	(compiler == TRANSPUTER_COMPILER || compiler == UNKNOWN_COMPILER)

#define NEW( _type )	(_type *)SafeAlloc( sizeof( _type ) )


#define streq(  s1, s2 )	(strcmp(  s1, s2      ) == 0)
#define strneq( s1, s2, len )	(strncmp( s1, s2, len ) == 0)
#define strend( a, b )	        (streq( a + strlen( a ) - strlen( b ), b ))

/*}}}*/
/*{{{  Types */

typedef struct	_NameNode
  {
    Node 	node;		/* link into list */
    char *	name;		/* the name */
  }
NameNode;

typedef List 	NameList;

typedef struct	_FileNode
  {
    Node 	node;		/* link into list */
    char *	ext;		/* extension */
    char *	oext;		/* original extension */
    char *	root;		/* name of file less extension */
    char *	base;		/* name of file less directory and extension */
  }
FileNode;

typedef enum	_State
  {
    normal,
    objed_suppressed,
    objed_enabled
  }
State;

typedef List 	FileList;


typedef enum
  {
    UNKNOWN_COMPILER,
    TRANSPUTER_COMPILER,
    ARM_COMPILER,
    C40_COMPILER,
    M68K_COMPILER,
    I860_COMPILER
  }
compiler_type;

/*}}}*/
/*{{{  Local Variables */

static NameList		IncludeDirs;
static NameList		SymbolDirs;
static NameList		LibraryDirs;
static NameList		ScanLibraryNames;
static NameList		ResLibraryNames;
static NameList		Defines;

static NameList		CompileOpts;
static NameList		PreProcOpts;
static NameList		AssembleOpts;
static NameList		MacroOpts;
static NameList		LinkOpts;
static NameList		ModulaOpts;

static char 		FortranP1Opts[ 256 ];
static char		FortranP2Opts[ 256 ];
static char *		FortranMapFile;

static FileList		SourceFiles;

static int		NSources;
static int		NOfiles;
static int		NCfiles;
static int		NSfiles;
static int		NAfiles;
static int		NFfiles;
static int		NMfiles;
static int		NDfiles;

static int		NCompiles;

static FileNode	*	LastCompile;

static int		HeapSize;
static int		StackSize;

static char *		ObjectName;

static State		state = normal;

static bool		ram_disk_present;
static bool		suppress_removes = false;

static char *		vfile = NULL;

static char *		shell;
static char *		c_compiler;
static char *		pre_processor;
static char *		f77_pass1;
static char *		f77_pass2;
static char *		m2_compiler;
static char *		assembler;
static char *		linker;
static char *		remover;
static char *		macro;
static char *		link_helios;
static char *		c_libdir;
static char *		link_clib;
static char *		c_incdir;
static char *		macdir;
static char *		symdir;
static char * 		link_cstart;
static char * 		link_fstart;
static char *		link_m2start;
static char *		machinename;

static compiler_type	compiler = UNKNOWN_COMPILER;

static int		Flags;
#define FLAG_B		(1 << 0)
#define FLAG_J		(1 << 1)
#define FLAG_O		(1 << 2)
#define FLAG_P		(1 << 3)
#define FLAG_S		(1 << 4)
#define FLAG_V		(1 << 5)
#define FLAG_b		(1 << 6)
#define FLAG_c		(1 << 7)
#define FLAG_j		(1 << 8)
#define FLAG_n		(1 << 9)
#define FLAG_o		(1 << 10)
#define FLAG_p		(1 << 11)
#define FLAG_v		(1 << 12)

#define STDLIBS		((Flags & (FLAG_b | FLAG_B)) == 0)
#define VERIFY		((Flags & FLAG_v) != 0)
#define OPTIMISE	((Flags & FLAG_O) != 0)
#define ASSEMBLE	((Flags & (FLAG_S | FLAG_p)) == 0)
#define ASSEMBLE_ONLY	((Flags & FLAG_S) != 0)
#define LINK		((Flags & (FLAG_S | FLAG_p | FLAG_c)) == 0)
#define EXECUTE		((Flags & FLAG_n) == 0)
#define VERBOSE		((Flags & FLAG_V) != 0)
#define REDIRECT	((Flags & FLAG_o) != 0)
#define JOIN		((Flags & FLAG_j) != 0)
#define APPEND		((Flags & FLAG_J) != 0)
#define NOLIBS		((Flags & FLAG_B) != 0)
#define PRE_PROC_ONLY	((Flags & FLAG_p) != 0)
#define USE_PIPE	((Flags & FLAG_P) != 0)
#define COMPILE_ONLY	((Flags & FLAG_c) != 0)


static int		Warns;

#define WARN_a		(1 << 0)
#define WARN_d		(1 << 1)
#define WARN_f		(1 << 2)
#define WARN_i		(1 << 3)
#define WARN_n		(1 << 4)
#define WARN_o		(1 << 5)
#define WARN_p		(1 << 6)
#define WARN_s		(1 << 7)
#define WARN_u		(1 << 8)
#define WARN_v		(1 << 9)


static int		Errs;

#define ERR_c		(1 << 0)
#define ERR_p		(1 << 1)
#define ERR_z		(1 << 2)


static int		Feats;

#define FEAT_b		(1 <<  0)
#define FEAT_d		(1 <<  1)
#define FEAT_f		(1 <<  2)
#define FEAT_g		(1 <<  3)
#define FEAT_h		(1 <<  4)
#define FEAT_l		(1 <<  5)
#define FEAT_m		(1 <<  6)
#define FEAT_n		(1 <<  7)
#define FEAT_p		(1 <<  8)
#define FEAT_s		(1 <<  9)
#define FEAT_u		(1 << 10)
#define FEAT_v		(1 << 11)
			 
static char *		ObjName;
static char *		ProgName = NULL;

static bool		use_non_standard_features = false;

/*}}}*/
/*{{{  Forward Declarations */

#ifdef __STDC__
static int ExecuteCommandLine( void );
#else
static int ExecuteCommandLine();
#endif

/*}}}*/
/*{{{  Functions */

/*{{{  Utility Routines */

/* #define DEBUG */

/*{{{  debug */

#ifdef DEBUG

static void
#ifdef __STDC__
debug( char * format, ... )
#else
debug( format, va_alist )
  char * format;
  va_dcl
#endif
  /*
   * print an debugging message
   */
{
  va_list	args;
  
  
#ifdef __STDC__    
  va_start( args, format );
#else
  va_start( args );
#endif
  
  fflush( stderr );
  
  fseek( stderr, 0L, SEEK_END );
  
  if (ProgName)
    fprintf( stderr, "%s: ", ProgName);
  
  vfprintf( stderr, format, args );
  
  fprintf( stderr, "\n" );
  
  fflush( stderr );
  
  va_end( args );
  
  return;
  
} /* debug */
    
#endif /* DEBUG */

/*}}}*/
/*{{{  error */

static void
#ifdef __STDC__
error( char * format, ... )
#else
error( format, va_alist )
  char *	format;
  va_dcl
#endif
  /*
   * print an error message
   */
{
  va_list	args;
  
  
#ifdef __STDC__    
  va_start( args, format );
#else
  va_start( args );
#endif
  
  fflush( stderr );
  
  fseek( stderr, 0L, SEEK_END );
  
  vfprintf( stderr, format, args );
  
  fprintf( stderr, "\n" );
  
  fflush( stderr );
  
  va_end( args );
  
  return;
  
} /* error */

/*}}}*/
/*{{{  warning */

  
static void
#ifdef __STDC__
warning( char * format, ... )
#else
warning( format, va_alist )
  char *	format;
  va_dcl
#endif
  /*
   * print a warning message
   */
{
  va_list	args;
  
  
#ifdef __STDC__    
  va_start( args, format );
#else
  va_start( args );
#endif
  
  fflush( stderr );
  
  fseek( stderr, 0L, SEEK_END );
  
  if (ProgName)
    fprintf( stderr, "%s: warning: ", ProgName);
  
  vfprintf( stderr, format, args );
  
  fprintf( stderr, "\n" );
  
  fflush( stderr );
  
  va_end( args );
  
  return;
  
} /* warning */

/*}}}*/
/*{{{  fail */

  
static void
#ifdef __STDC__
fail( char * format, ... )
#else
fail( format, va_alist )
  char *	format;
  va_dcl
#endif
  /*
   * print a reason message and terminate
   */
{
  va_list	args;
  
  
  signal( SIGINT, SIG_DFL );
  
#ifdef __STDC__    
  va_start( args, format );
#else
  va_start( args );
#endif
  
  fflush( stderr );
  
  fseek( stderr, 0L, SEEK_END );
  
  fprintf( stderr, "%s:- ", ProgName );
  
  vfprintf( stderr, format,  args );
  
  fprintf( stderr, "\n" );
  
  fflush( stderr );
  
  va_end( args );
  
  exit( 1 );
  
} /* fail */

/*}}}*/
/*{{{  SafeAlloc */

static char *
#ifdef __STDC__
SafeAlloc( unsigned long size )
#else
SafeAlloc( size )
  unsigned long size;
#endif
  /*
   * allocate 'size' bytes of memory or fail
   */
{
  char *	ptr = (char *)malloc( (size_t)size );
  
  
  if (ptr == NULL)
    {
      fail( "malloc failed (for %lu bytes)", size );
    }
  
  return ptr;
  
} /* SafeAlloc */

/*}}}*/

/*}}}*/
/*{{{  List Routines */

/*{{{  InitNode() */

static void
#ifdef __STDC__
InitNode( Node * pNode )
#else
InitNode( pNode )
  Node * pNode;
#endif
  /*
   * Initialises a node so that it is self-referential
   */
{
  if (pNode != Null( Node ))
    {
      pNode->Next = pNode->Prev = pNode;
    }
  
  return;
      
} /* InitNode */

/*}}}*/
/*{{{  First Node */

static Node *
#ifdef __STDC__
FirstNode( List * plist )
#else
FirstNode( plist )
  List * plist;
#endif
  /*
   * returns the first node in the given list or NULL if the list is empty
   */
{
  if (plist 		== Null( List ) ||
      plist->Head 	== Null( Node ) ||
      plist->Head->Next == Null( Node ) )
    {
      return Null( Node );
    }
  
  return plist->Head;
  
} /* FirstNode */

/*}}}*/
/*{{{  NextNode */

static Node *
#ifdef __STDC__
NextNode( Node * pnode )
#else
NextNode( pnode )
  Node * pnode;
#endif
  /*
   * returns the next node in the list containing 'pnode' or NULL if this
   * is the last node in the list or the node is not attached to a list
   */
{
  if (pnode 		== Null( Node ) ||
      pnode->Next 	== Null( Node ) ||
      pnode->Next->Next == Null( Node ) )
    {
      return Null( Node );
    }
  
  return pnode->Next;
  
} /* NextNode */

/*}}}*/
/*{{{  ListSize */

  
static int
#ifdef __STDC__
ListSize( List * plist )
#else
ListSize( plist )
  List * plist;
#endif
  /*
   * returns the number of elements in the list provided
   */
{
  int		n = 0;
  Node *	pnode;
  
  
  for (pnode = FirstNode( plist ); pnode; pnode = NextNode( pnode ))
    n++;
  
  return n;
  
} /* ListSize */

/*}}}*/
/*{{{  DupName */

  
static char *
#ifdef __STDC__
DupName( char * pname )
#else
DupName( pname )
  char * pname;
#endif
  /*
   * returns a copy of the string provided
   */
{
  char *	ptr = SafeAlloc( (unsigned long)strlen( pname ) + 1 );
    
    
  strcpy( ptr, pname );
    
  return ptr;
    
} /* DupName */

/*}}}*/
/*{{{  AddName */

  
static void
#ifdef __STDC__
AddName(
	NameList *	plist,
	char *		pname )
#else
AddName( plist, pname )
  NameList *	plist;  
  char *	pname;
#endif
  /*
   * add a new node to the list containing the string 'name'
   */	
{
  NameNode *	pnew = NEW( NameNode );
  
  pnew->name = DupName( pname );

  InitNode( &pnew->node );
  
  AddTail( (List *)plist, &pnew->node );
  
  return;
  
} /* AddName */

/*}}}*/
/*{{{  RemoveName */

  
static bool
#ifdef __STDC__
RemoveName(
	   NameList *	plist,
	   char * 	pname )
#else
RemoveName( plist, pname )
  NameList *	plist;  
  char * 	pname;
#endif
  /*
   * remove a name from the given list
   * returns TRUE upon success, FALSE otherwise
   * only removes the first occurance of pname
   */
{
  NameNode *	pnode;
  
  
  for (pnode  = (NameNode *)FirstNode( (List *)plist );
       pnode != NULL;
       pnode  = (NameNode *)NextNode( (Node *)pnode ))
    {
      if (streq( pnode->name, pname ))
	{
	  (void) Remove( (Node *)pnode );
	  
	  free( pnode );
	  
	  return TRUE;
	}
    }
  
  return FALSE;
  
} /* RemoveName */

/*}}}*/
/*{{{  AddNameToFront */

  
static void
#ifdef __STDC__
AddNameToFront(
	       NameList *	plist,
	       char *		pname )
#else
AddNameToFront( plist, pname )
  NameList *	plist;
  char *	pname;
#endif
  /*
   * add a new node to the list containing the string 'name'
   * name is added to the head of the list
   */	
{
  NameNode *	pnew = NEW( NameNode );
  
  
  pnew->name = DupName( pname );
  
  if (strchr( pname, ' ' ))
    {
      warning( "blank(s) found in argument '%s'", pname );
    }

  InitNode( &pnew->node );
  
  AddHead( (List *)plist, &pnew->node );
  
  return;
  
} /* AddNameToFront */

/*}}}*/
/*{{{  AddNamef */

static void
#ifdef __STDC__
AddNamef(
	 NameList *	plist,
	 char *		format,
	 ...		)
#else
AddNamef( plist, format, va_alist )
  NameList *	plist;
  char *	format;
  va_dcl
#endif
  /*
   * adds a node to a list containing a constructed string
   */	
{
  static char	buffer[ ARGBUFSIZE ];
  va_list	args;
  
  
#ifdef __STDC__    
  va_start( args, format );
#else
  va_start( args );
#endif
  
  vsprintf( buffer, format, args );
  
  va_end(   args );
  
  AddName( plist, buffer );
  
  return;
  
} /* AddNamef */

/*}}}*/
/*{{{  AddLibraryName */

  
static void
#ifdef __STDC__
AddLibraryName(
	       bool	resident,
	       char *	format,
	       ...	)
#else
AddLibraryName( resident, format, va_alist )
  bool		resident;
  char *	format;
  va_dcl
#endif
  /*
   * adds a name to the Library Name list
   */	
{
  static char	buffer[ ARGBUFSIZE ];
  va_list	args;
  NameList *	plibs;
  NameNode *	pname;
  
  
  if (resident)
    {
      plibs  = &ResLibraryNames;
    }
  else
    {
      plibs  = &ScanLibraryNames;
    }
  
  /* format the name */
  
#ifdef __STDC__    
  va_start( args, format );
#else
  va_start( args );
#endif
  
  vsprintf( buffer, format, args );
  
  va_end(   args );
  
  /* check to see if this name already exists */
  
  for (pname  = (NameNode *)FirstNode( (List *)plibs );
       pname != NULL;
       pname  = (NameNode *)NextNode( (Node *)pname ) )
    {
      if (streq( pname->name, buffer ))
	break;
    }
  
  if (pname == NULL)
    {
      /* add the name to the end of the list */
      
      AddName( plibs, buffer );
    }
  
  return;
  
} /* AddLibraryName */

/*}}}*/
/*{{{  AddFile */

static void
#ifdef __STDC__
AddFile(
	FileList *	plist,
	char *		file )
#else
AddFile( plist, file )
  FileList *	plist;
  char *	file;
#endif
  /*
   * adds a file name to the the file name list
   * seperates the filename and extension
   */	
{
  FileNode *	New = NEW( FileNode );
  char *	tmp = DupName( file );
  char *	p   = strrchr( tmp, '.' );
  
  
  if (p == NULL)
    {
      New->ext = DupName( "" );
    }
  else
    {
      *p++     = '\0';
      New->ext = DupName( p );
    }
  
  p = strrchr( tmp, '/' );
  
  if (p == NULL)
    {
      p = tmp;
    }
  else
    {
      p++;
    }
  
  New->base = DupName( p );
  New->oext = New->ext;
  New->root = DupName( tmp );

  InitNode( &New->node );
  
  AddTail( (List *)plist, &New->node );
  
  free( tmp );
  
  return;
  
} /* AddFile */

/*}}}*/
/*{{{  AddNames */

static void
#ifdef __STDC__
AddNames(
	 NameList *	nlist,
	 char *		format,
	 NameList *	plist )
#else
AddNames( nlist, format, plist )
  NameList *	nlist;
  char *	format;
  NameList *	plist;
#endif
  /*
   * merge two name lists
   */	
{
  NameNode *	This;
  
  
  for (This = (NameNode *)FirstNode( (List *)plist );
       This;
       This = (NameNode *)NextNode( (Node *)This ))
    {
      AddNamef( nlist, format, This->name );
    }
  
  return;
  
} /* AddNames */

/*}}}*/
/*{{{  AddFiles */

  
static void
#ifdef __STDC__
AddFiles(
	 NameList *	nlist,
	 char *		format,
	 FileList *	plist )
#else
AddFiles( nlist, format, plist )
  NameList *	nlist;
  char *	format;
  FileList *	plist;
#endif  
  /*
   * merge two file name lists
   */	
{
  FileNode *	This;
  
  
  for (This = (FileNode *)FirstNode( (List *)plist );
       This;
       This = (FileNode *)NextNode( (Node *)This ))
    {
      AddNamef( nlist, format, This->root, This->ext );
    }
  
  return;
  
} /* AddFiles */

/*}}}*/
/*{{{  AddLibrary */

/*
 * NB/ It is not sufficient to use access() here, as it is possible
 * to have a library name that matches a directory name, eg libX11.a vs X11/
 */

#define	file_exists( name )	(stat( name, &status ) == 0 && (status.st_mode & S_IFREG) == S_IFREG)
  
  
static bool
#ifdef __STDC__
AddLibrary(
	   char *	dir,
	   char *	stem )
#else
AddLibrary( dir, stem )
  char *	dir;
  char *	stem;
#endif
  /*
   * search for a library called 'stem' in directory 'dir'
   * if the library is found, add its name to the library list
   * returns true iff the library was found, false otherwise
   */
{
  static char	buf[ 100 ];	/* XXX */
  struct stat	status;  
  bool		resident  = false;
  char *	seperator = dir[ strlen(dir) - 1 ] == '/' ? "" : "/";
  

  if (strchr( stem, '.' ))
    {
      /* stem already has an extension - do not try adding one */

      sprintf( buf, "%s%s%s", dir, seperator, stem );
      
      if (file_exists( buf ))
	{
	  char * ptr = strchr( stem, '.' ) + 1;
	  
	  
	  if (streq( ptr, "def" ))
	    {
	      goto got_resident;
	    }
	  else
	    {
	      goto got_scanned;
	    }
	}
    }
  else
    {
      sprintf( buf, "%s%s%slib.def", dir, seperator, stem );
      
      if (file_exists( buf ))
	goto got_resident;
      
      sprintf( buf, "%s%s%s.def", dir, seperator, stem );
      
      if (file_exists( buf ))
	goto got_resident;
      
      sprintf( buf, "%s%s%slib", dir, seperator, stem );
      
      if (file_exists( buf ))
	goto got_scanned;
      
      sprintf( buf, "%s%s%s.lib", dir, seperator, stem );
      
      if (file_exists( buf ))
	goto got_scanned;
      
      sprintf( buf, "%s%s%s", dir, seperator, stem );
      
      if (file_exists( buf ))
	goto got_scanned;
      
      sprintf( buf, "%s%slib%s.a", dir, seperator, stem );
      
      if (file_exists( buf ))
	goto got_scanned;
      
      if (streq( stem, "m" ))
	{
	  /*
	   * UNIX style maths libraries
	   */
	  
	  if (!STDLIBS)
	    {
	      if (c_libdir[ strlen( c_libdir ) - 1 ] == '/')
		{
		  AddLibraryName( true, "%sfplib.def",  c_libdir );
		  AddLibraryName( true, "%sfpclib.def", c_libdir );
		}
	      else
		{
		  AddLibraryName( true, "%s/fplib.def",  c_libdir );
		  AddLibraryName( true, "%s/fpclib.def", c_libdir );
		}
	    }
	  
	  return TRUE;
	}
    }
  
  return FALSE;
  
 got_resident:
  
  if (streq( stem, "X" ))
    {
      /*
       * adding in the resident X library make sure that there is
       * sufficient stack space for the program.  (What, hack, us !?)
       */
      
      if (StackSize < 10000)
	StackSize = 10000;
    }
  
  resident = true;
  
 got_scanned:
  if (streq( stem, link_helios ) || streq( stem, link_clib ))
    {
      /* these two are actually resident libraries, despite their extension */
      
      resident = true;
    }
  
  AddLibraryName( resident, "-l%s", buf );
  
  return TRUE;
  
} /* AddLibrary */

/*}}}*/
/*{{{  FindAndAddLibrary */

static void
#ifdef __STDC__
FindAndAddLibrary( char * pfile_name )
#else
FindAndAddLibrary( pfile_name )
  char * pfile_name;
#endif
/*
 * attempts to locate the correct directory and name of the indicated
 * library, and then adds it to the library name list
 */
{
  NameList *	pdirs = &LibraryDirs;
  NameNode *	pdir_name;


  if (strrchr( pfile_name, '/' ))
    {
      struct stat	status;


      if (file_exists( pfile_name ))
	{
	  AddLibraryName( false, "-l%s", pfile_name );

	  return;
	}
    }
  else
    {
      for (pdir_name  = (NameNode *)FirstNode( (List *)pdirs );
	   pdir_name != NULL;
	   pdir_name  = (NameNode *)NextNode( (Node *)pdir_name ))
	{
	  if (AddLibrary( pdir_name->name, pfile_name ))
	    {
	      return;
	    }
	}
    }
  
  warning( "failed to locate library '%s'", pfile_name );
  
  return;
  
} /* FindAndAddLibrary */

/*}}}*/

/*}}}*/
/*{{{  Execution */

static char 	command_line[  1024 ];		/* XXX */
static char 	command_line2[ 1024 ];		/* XXX */

/*{{{  ExecuteList */

static int
#ifdef __STDC__
ExecuteList( NameList * nlist )
#else
ExecuteList( nlist )
  NameList * nlist;
#endif
/*
 * execute the indicate command with the provided arguments
 * wait for the command to terminate and return its exit code
 */
{
  pid_t		pid;
  int		i;
  int		result 	= -1;
  int		argc   	= ListSize( (List *)nlist );
  char **	argv 	= (char **)SafeAlloc( ((unsigned long)argc + 1) * sizeof( char * ) );
  NameNode *	pnode;
  char *	cmdline;
  

#ifdef DEBUG
  debug( "ExecuteList() called" );
#endif
  
  if (USE_PIPE && command_line[ 0 ] != '\0')
    {
      cmdline = command_line2;

      cmdline[ 0 ] = '\0';
    }
  else
    {
      cmdline = command_line;
    }
    
  i = 0;
    
  for (pnode = (NameNode *)FirstNode( (List *)nlist );
       pnode;
       pnode = (NameNode *)NextNode( (Node *)pnode ) )
    {
      if (USE_PIPE)
	{
	  strcat( cmdline, pnode->name );
	  strcat( cmdline, " " );
	    
	  continue;
	}
      
      argv[ i ] = pnode->name;

      while (isspace( argv[ i ][ 0 ]))
	argv[ i ] += 1;

      if (VERIFY)
	printf( "%s ", argv[ i ] );
      
      ++i;
    }
    
  argv[ i ] = NULL;
    
  if (!USE_PIPE && VERIFY)
    {
      printf( "\n" );
    }
    
  if (!EXECUTE || USE_PIPE)
    {
      free( argv );
      
      return 0;
    }
    
  if ((pid = vfork()) == 0)
    {
      int	return_code;
      
	
      return_code = execvp( argv[ 0 ], argv );
	
      _exit( return_code );
    }
    
  if (pid == -1)
    {
      fail( "Failed to execute %s", argv[ 0 ] );
    }
    
  while (wait( &result ) == -1 && errno == EINTR)
    ;
    
  if (result != 0)
    {
      warning( "Failed because %s exited with return code of %d", argv[ 0 ], result );
    }
    
  return result;
    
} /* ExecuteList */

/*}}}*/
/*{{{  command_line_to_argv */

static char **
#ifdef __STDC__
command_line_to_argv( char * command_line )
#else
command_line_to_argv( command_line )
  char *  command_line;
#endif
{
  static char *	argv[ 200 ];		/* XXX */
  char *	ptr;
  int		index;
  char		c;
  bool		found_quote;
  

  if (command_line == NULL)
    return NULL;

  ptr   = command_line;
  index = 0;
  found_quote = false;
  
  
  while ((c = *ptr++) != '\0')
    {
      /* skip past character after a backslash */
      
      if (c == '\\')
	if ((c = *ptr++) == '\0')
	  break;

      /* skip characters between double quotes */
      
      if (c == '"')
	{
	  if (found_quote)
	    found_quote = false;
	  else
	    found_quote = true;
	}

      /* break arguments at white space */
      
      if (isspace( c ) && !found_quote)
	{
	  /* point to start of command line argument */
	  
	  argv[ index++ ] = command_line;

	  /* terminate the argument */
	  
	  ptr[ -1 ] = '\0';

	  /* advance pointer to next non white space character */
	  
	  while ((c = *ptr) != '\0' && isspace( c ))
	    ptr++;

	  /* remember start of next bit of command line */
	  
	  command_line = ptr;
	}
    }

  /* terminate argv array */
  
  argv[ index ] = NULL;

  /* finished */

  return argv;
  
} /* command_line_to_argv */

/*}}}*/
/*{{{  signal_handler */

static pid_t	proc1 = -1;	/* process ID of first  process */
static pid_t	proc2 = -1;	/* process ID of second process */

void
#ifdef __STDC__
signal_handler( int sig )
#else
signal_handler( sig )
  int	sig;
#endif
{
  /* broadcast signal to child processes */
  
  if (proc1 != -1)
    kill( proc1, sig );

  if (proc2 != -1)
    kill( proc2, sig );

  /* finished */
  
  return;
  
} /* signal_handler */

/*}}}*/
/*{{{  ExecuteCommandLine */

static int
#ifdef __STDC__
ExecuteCommandLine( void )
#else
ExecuteCommandLine()
#endif
/*
 * execute the commands built up in the command line
 * wait for the commands to terminate and return the exit code
 */
{
  int		result 	= -1;
  pid_t		pid;
  char **	argv;
  void (*	old_handler)();

      
#ifdef DEBUG
  debug( "ExecuteCommandLine() called" );
#endif
      
  if (!USE_PIPE || command_line[ 0 ] == '\0')
    {
      return 0;
    }

  if (command_line2[ 0 ] != '\0')
    {
      int	fds[ 2 ];
      int	result2 = -1;

      
      if (VERIFY)
	{
	  printf( "%s |\n", command_line );
	  printf( "%s\n",   command_line2 );
	}
    
      if (!EXECUTE)
	{
	  command_line[  0 ] = '\0';
	  command_line2[ 0 ] = '\0';
      
	  return 0;
	}

      /* create a pipe to connect the two processes */
      
      if (pipe( fds ) != 0)
	{
	  fail( "Failed to create a pipe" );
	}

      /* convert command line to argv format */
      
      argv = command_line_to_argv( command_line );
	  
      /* set up a signal handler to process interrupts */
      
      if ((old_handler = signal( SIGINT, signal_handler )) == SIG_ERR)
	{
	  fail( "failed to set up signal handler" );
	}

      /* create first command line processes */
      
      if ((proc1 = vfork()) == 0)
	{
	  /* close stdout */
	  
	  close( 1 );

	  /* duplicate write channel of pipe as stdout */
	  
	  dup2( fds[ 1 ], 1 );

	  /* close unused file descriptors */
	  
	  close( fds[ 0 ] );
	  close( fds[ 1 ] );
	  
	  /* and run the first command line */
	  
	  _exit( execvp( argv[ 0 ], argv ) );
	}

      /* check to see if vfork worked */
      
      if (proc1 == -1)
	{
	  fail( "Failed to create child process for %s", command_line );
	}
      
      /* convert second command line to argv */
	  
      argv = command_line_to_argv( command_line2 );
	  
      /* create second command line processes */
      
      if ((proc2 = vfork()) == 0)
	{
	  /* close stdin */
	  
	  close( 0 );

	  /* duplicate read channel of pipe as stdin */
	  
	  dup2( fds[ 0 ], 0 );

	  /* close unused file descriptors */
	  
	  close( fds[ 0 ] );
	  close( fds[ 1 ] );

	  /* and run the second command line */
	  
	  _exit( execvp( argv[ 0 ], argv ) );
	}
      
      /* check to see if second vfork failed */
      
      if (proc2 == -1)
	{
	  fail( "Failed to create child process for %s", command_line2 );
	}

      /* close unused file descriptors */
      
      close( fds[ 0 ] );
      close( fds[ 1 ] );
	  
      /* wait for one child to finish */
      
      while ((pid = wait( &result )) == -1 && errno == EINTR)
	;

      /* mark the child process as having been terminated */
      
      if (pid == proc1)
	proc1 = -1;
      else if (pid == proc2)
	proc2 = -1;
      else
	warning( "unknown child process %d has terminated", pid );
	
      /* wait for other child to finish */
      
      while ((pid = wait( &result2 )) == -1 && errno == EINTR)
	;

      /* mark the other process as having been terminated */
      
      if (pid == proc1)
	proc1 = -1;
      else if (pid == proc2)
	proc2 = -1;
      else
	warning( "unknown child process %d has terminated", pid );
      
      if (result != 0)
	{
	  warning( "Failed because %s exited with return code of %d", command_line, result );
	}
      
      if (result2 != 0)
	{
	  warning( "Failed because %s exited with return code of %d", command_line2, result2 );
	}
      
      /* merge results */
      
      if (result2 != 0)
	result = result2;
    }
  else
    {
      if (VERIFY)
	{
	  printf( "%s\n", command_line );
	}
    
      if (!EXECUTE)
	{
	  command_line[ 0 ] = '\0';
      
	  return 0;
	}
    
      argv = command_line_to_argv( command_line );
	  
      if ((old_handler = signal( SIGINT, signal_handler )) == SIG_ERR)
	{
	  fail( "failed to set up signal handler" );
	}
      
      if ((proc1 = vfork()) == 0)
	{
	  _exit( execvp( argv[ 0 ], argv ) );
	}
      
      if (proc1 == -1)
	{
	  fail( "Failed to create child process for %s", command_line );
	}
    
      while ((pid = wait( &result )) == -1 && errno == EINTR)
	;
      
      if (pid == proc1)
	proc1 = -1;
      else
	warning( "unknown child process %d has terminated", pid );
	
      if (result != 0)
	{
	  warning( "Failed because %s exited with return code of %d", command_line, result );
	}
    }
  
  /* reset signal handler */

  (void) signal( SIGINT, old_handler );
  
  /* mark command lines as used */
      
  command_line[ 0 ]  = '\0';
  command_line2[ 0 ] = '\0';

  return result;
    
} /* ExecuteCommandLine */

/*}}}*/
/*{{{  RemoveFile */

static void
#ifdef __STDC__
RemoveFile( FileNode * pfile )
#else
RemoveFile( pfile )
  FileNode * pfile;
#endif
/*
 * deleted the indicated file
 */
{
  NameList	args;
  List *	plist = (List *)&args;
    

#ifdef DEBUG
  debug( "RemoveFile() called" );
#endif
  
  if (suppress_removes)
    return;
  
  InitList( plist );
    
  AddNamef( plist, "%s",    remover );
  AddNamef( plist, "%s.%s", pfile->root, pfile->ext );
  
  (void) ExecuteList( plist );

  return;
  
} /* RemoveFile */

/*}}}*/
/*{{{  C_Compile */

static int
#ifdef __STDC__
C_Compile( FileNode * fnode )
#else
C_Compile( fnode )
  FileNode * fnode;
#endif
/*
 * compile the indicated C file 
 * returns exit code of compilation
 */
{
  NameList	args;
  List *	plist  = (List *)&args;
  int		result = 0;
    
    
#ifdef DEBUG
  debug( "C_Compile() called" );
#endif
  
  InitList( plist );
    
  AddNamef( plist, "%s",   c_compiler   );
  AddNames( plist, "%s",   &CompileOpts );
  AddNamef( plist, "%s.%s", fnode->root, fnode->oext );

  if (REDIRECT && !_is_transputer_compiler && COMPILE_ONLY)
    {
      /*
       * XXX beware of compromising
       *
       * c fred.c -o fred
       * c -c fred.c -o fred
       */
      
      if (ObjName != NULL)
	{
	  if (_is_norcroft_compiler)
	    AddName( plist, "-o" );
	  else
	    AddName( plist, "-s" );

	  AddName(  plist, ObjName );
	}
    }
  else if (!USE_PIPE)
    {
      if (_is_norcroft_compiler)
	{
	  char *	name;


	  AddName( plist, "-o" );

	  name = fnode->root;

	  if ((name = strrchr( name, '/' )) != NULL)
	    {
	      name++;
	    }
	  else
	    {
	      name = fnode->root;	      
	    }
	  
	  if (ASSEMBLE_ONLY)
	    {
	      AddNamef( plist, "%s.s", name );
	    }
	  else
	    {
	      AddNamef( plist, "%s.o", name );
	    }
	}
      else
	{
	  AddName(  plist, "-s"                );
	  AddNamef( plist, "%s.s", fnode->root );
	}
    }
  else if (_is_norcroft_compiler && !COMPILE_ONLY && !ASSEMBLE_ONLY)
    {
      /*
       * By default Norcroft compiler's will create their own output
       * file name, so we must explicity override it
       */

      AddName( plist, "-o" );

      AddName( plist, "-" );
    }
  else if ((COMPILE_ONLY || ASSEMBLE_ONLY)
	   && ObjName != NULL
	   && ObjName != ((FileNode *)FirstNode( &SourceFiles ))->base
	   && !_is_transputer_compiler)
    {
      /*
       * force rename of output of compiler
       */

      AddName( plist, "-o" );

      AddName( plist, ObjName );
    }
  
    
  result = ExecuteList( plist );
  
  NCompiles++;
    
  LastCompile = fnode;
  
  if (_is_norcroft_compiler)
    {
      if (ASSEMBLE_ONLY)
	{
	  fnode->ext  = DupName( "s" );
	}
      else
	{
	  fnode->ext  = DupName( "o" );
	}
    }
  else
    {
      fnode->ext  = DupName( "s" );
    }
  
  return result;
    
} /* C_Compile */

/*}}}*/
/*{{{  Pre_Process */

static int
#ifdef __STDC__
Pre_Process( FileNode * fnode )
#else
Pre_Process( fnode )
  FileNode * fnode;
#endif
/*
 * pre_process the indicated file
 * returns exit code of compilation
 */
{
  NameList	args;
  List *	plist  = (List *)&args;
  int		result = 0;
  bool		using_cpp;
    
#ifdef DEBUG
  debug( "PreProcess() called" );
#endif
  
  using_cpp = strend( pre_processor, "cpp" );
  
  InitList( plist );

  AddNamef( plist, "%s",    pre_processor );
  if (!using_cpp)
    AddName( plist, "-E" );
  AddNames( plist, "%s",    &PreProcOpts  );
  AddNames( plist, "-D%s",  &Defines      );
  AddNames( plist, "-I%s",  &IncludeDirs  );
  AddNamef( plist, "%s.%s", fnode->root, fnode->oext );
  if (REDIRECT)
    {
      if (using_cpp)
	AddName( plist, ObjectName );
      else
	warning( "Unable to redirect output of pre-processor" );
    }
  else if (using_cpp)
    AddNamef( plist, "%s.i",  fnode->root   );
    
  result = ExecuteList( plist );
    
  NCompiles++;
    
  LastCompile = fnode;
    
  fnode->ext  = DupName( "i" );
    
  return result;
    
} /* pre_process */

/*}}}*/
/*{{{  F77_Compile */

#ifndef __ARM
static int
#ifdef __STDC__
F77_Compile( FileNode * fnode )
#else
F77_Compile( fnode )
  FileNode * fnode;
#endif
/*
 * compile the indicated FORTRAN file 
 * returns exit code of compilation
 */
{
  NameList	args;
  List *	plist    = (List *)&args;
  bool		pipe_off = false;
  int		result   = 0;
  char		buffer[ L_tmpnam + 1 ];
  char *	ptmp;
  char *	pname;
    
    
  if (USE_PIPE)
    {
      /* switch off piping for FORTRAN compiles */
      
      pipe_off = true;
      
      Flags &= ~FLAG_P;
    }
    
  InitList( plist );
    
  AddNamef( plist, "%s",      f77_pass1   );
  AddNamef( plist, "%s.f",    fnode->root );

  /* generate a temporary file name */

  /*
   * first get a temporary name, then extract the file name part, then add in our own root
   * This is highly grungy, but will actually work as the C library version of tmpnam()
   * does not check to see if the name it creates is truely unique with respect to the
   * directory it has chosen
   */

  (void) tmpnam( buffer );

  if ((ptmp = strrchr( buffer, '/' )) == NULL)
    {
      ptmp = buffer;
    }
  else
    {
      ++ptmp;
    }

  if ((pname = getenv( "TMPDIR" )) == NULL)
    {
      if (ram_disk_present)
	{
	  pname = "/ram/tmp";
	}
      else
	{
	  pname = "/helios/tmp";
	}
    }
  
  AddNamef( plist, "%s/%s", pname, ptmp );
      
  if (FortranP1Opts[ 0 ])
    {
      AddName( plist, ","           );
      AddName( plist, FortranP1Opts );
    }
    
  if ((result = ExecuteList( plist )) == 0)
    {
      InitList( plist );
      
      AddNamef( plist, "%s", f77_pass2 );
      
      AddNamef( plist, "%s/%s", pname, ptmp );
      
      AddNamef( plist, "%s.s", fnode->root );
      
      if (FortranP2Opts[ 0 ] ||
	  FortranMapFile)
	{
	  AddName( plist, "," );
	  AddName( plist, "," );
	  
	  if (FortranP2Opts[ 0 ])
	    {
	      AddName( plist, FortranP2Opts );
	    }
	  else
	    {
	      AddName( plist, "," );
	    }
	  
	  if (FortranMapFile)
	    {
	      AddName( plist, FortranMapFile );
	    }
	}
      
      result = ExecuteList( plist );
    }
      
  NCompiles++;
    
  LastCompile = fnode;
    
  fnode->ext  = DupName( "s" );
    
  if (pipe_off)
    {
      Flags |= FLAG_P;
    }
  
  return result;
    
} /* F77_Compile */
#endif /* not __ARM */

/*}}}*/
/*{{{  M2_CompileDef */

#ifndef __ARM

static int
#ifdef __STDC__
M2_CompileDef( FileNode * fnode )
#else
M2_CompileDef( fnode )
  FileNode * fnode;
#endif
/*
 * compile the indicated Modula-2 definition file
 * returns exit code of compilation
 */
{
  NameList	args;
  List *	plist  = (List *)&args;
  int		result = 0;
    
    
  InitList( plist );
    
  AddNamef( plist, "%s",     m2_compiler );
  AddNames( plist, "%s",     &ModulaOpts );
  AddNamef( plist, "%s.def", fnode->root );
  
  result = ExecuteList( plist );
  
  return result;
    
} /* M2_CompileDef */

#endif /*not __ARM */

/*}}}*/
/*{{{  M2_CompileMod */

#ifndef __ARM

static int
#ifdef __STDC__
M2_CompileMod( FileNode * fnode )
#else
M2_CompileMod( fnode )
  FileNode * fnode;
#endif
/*
 * compile the indicated Modula-2 program file
 * returns exit code of compilation
 */
{
  NameList	args;
  List *	plist     = (List *)&args;
  int		result    = 0;
  char *	extension = Null( char );
    
    
  InitList( plist );
  
  AddNamef( plist, "%s",     m2_compiler );
  AddNames( plist, "%s",     &ModulaOpts );
  AddNamef( plist, "%s.mod", fnode->root );
  
  AddName(  plist, "-w" );
  
  if (ram_disk_present)
    {
      AddName( plist, "/ram/tmp" );
    }
  else
    {
      AddName( plist, "/helios/tmp" );
    }
    
  LastCompile = fnode;
  
  if (REDIRECT && !ASSEMBLE)
    {
      if (ObjName != NULL)
	{
	  AddName(  plist, "-s"    );
	  AddName(  plist, ObjName );
	  
	  extension = "";
	}
    }
  else if (!ASSEMBLE)
    {
      AddName(  plist, "-s"                );
      AddNamef( plist, "%s.s", fnode->root );
      
      extension = "s";
    }
  else
    {
      AddName(  plist, "-o"                );
      AddNamef( plist, "%s.o", fnode->root );
      
      extension   = "o";
      LastCompile = NULL;
    }
    
  result = ExecuteList( plist );
  
  NCompiles++;
  
  fnode->ext  = DupName( extension );
  
  return result;
  
} /* M2_CompileMod */

#endif /* not __ARM */

/*}}}*/
/*{{{  MacroAssemble */

static int
#ifdef __STDC__
MacroAssemble( FileNode * fnode )
#else
MacroAssemble( fnode )
  FileNode * fnode;
#endif
/*
 * macro assemble the indicated file
 * returns exit code of operation
 */
{
  NameList	args;
  List *	plist  = (List *)&args;
  int		result = 0;
  
  
#ifdef DEBUG
  debug( "MacroAssemble() called" );
#endif
  
  InitList( plist );
  
  AddNamef( plist, "%s", macro );
  
  if (REDIRECT && !ASSEMBLE)
    {
      if (ObjName != NULL)
	{
	  AddNamef( plist, "-o%s", ObjName );
	}
    }
  else if (!USE_PIPE)
    {
      AddNamef( plist, "-o%s.s", fnode->root );
    }
  
  AddNamef( plist, "-i%s", macdir );
  
  AddNames( plist, "%s",   &MacroOpts );
  
  AddNamef( plist, "%s%s", macdir, BASIC );
  
  AddNamef( plist, "%s.a", fnode->root );
  
  result = ExecuteList( plist );
  
  NCompiles++;
      
  fnode->ext = DupName( "s" );

  return result;
  
} /* MacroAssemble */

/*}}}*/
/*{{{  Assemble */

static int
#ifdef __STDC__
Assemble( FileNode * fnode )
#else
Assemble( fnode )
  FileNode * fnode;
#endif
/*
 * assemble the indicated file
 * returns the result of the assemble operation
 */
{
  NameList	args;
  List *	plist  = (List *)&args;
  int		result = 0;
    
    
#ifdef DEBUG
  debug( "Assemble() called" );
#endif
  
  InitList( plist );
    
  AddNamef( plist, "%s", assembler );

  if (_is_transputer_compiler)
    AddName(  plist, "-p"          ); /* only assemble */

  AddNames( plist, "%s", &AssembleOpts );
  
#ifndef __ARM
  if (vfile != NULL)
    {
      AddNamef( plist, "-m%s", vfile );
    }
#endif
  
  if (REDIRECT && !LINK)
    {
      if (ObjName != NULL)
	{
	  AddName( plist, "-o"    );
	  AddName( plist, ObjName );
	}
    }
  else
    {
      FileNode *	This;

      
      /*
       * check to see if we are about to create an object
       * file whose name matches the name of an object file
       * already created...
       */

      for (This  = (FileNode *)FirstNode( (List *)&SourceFiles );
	   This != NULL;
	   This  = (FileNode *)NextNode( (Node *)This ) )
	{
	  if (This == fnode)
	    break;
	  
	  if (streq( This->ext, "o" ) && streq( This->root, fnode->root ))
	    {
	      warning( "source files %s.%s and %s.%s produce same named object files!",
		    This->root, This->oext, fnode->root, fnode->oext );

	      return -1;
	    }
	}
      
      AddName(  plist, "-o"                );
      AddNamef( plist, "%s.o", fnode->root );
    }
  
  if (!USE_PIPE)
    {
      AddNamef( plist, "%s.s", fnode->root );
    }
  
  result = ExecuteList( plist );
  
  if (streq( fnode->oext, "s" ))
    {
      NCompiles++;
      
      LastCompile = fnode;
    }
  else if (USE_PIPE && (streq( fnode->oext, "c" ) || streq( fnode->oext, "a" )))
    {
      (void) ExecuteCommandLine();
    }
  else
    {
      RemoveFile( fnode );
    }
  
  fnode->ext = DupName( "o" );
  
  return result;
  
} /* Assemble */

/*}}}*/
/*{{{  DoCompiles */

static bool
DoCompiles(
#ifdef __STDC__
	   void
#endif
	   )
/*
 * perform all the necessary compilations
 * returns TRUE if all the compilations complete successfully, FALSE otherwise
 */
{
  FileNode *	This;
  FileNode *	next;
  bool		result = TRUE;
  
  
#ifdef DEBUG
  debug( "DoCompiles() called" );
#endif
  
  for (This = (FileNode *)FirstNode( (List *)&SourceFiles );
       (This != NULL) && result;
       This = next)
    {
      /* initialize next so Remove() works safely */
      
      next = (FileNode *)NextNode( (Node *)This );
      
      switch (*This->ext)
	{
	case 'c':
	  if (PRE_PROC_ONLY)
	    {
	      if (Pre_Process( This ) != 0)
		result = FALSE;
	      
	      break;
	    }
	  
	  /* drop through */
	  
	case 'i':
	  if (C_Compile( This ) != 0)
	    {
	      result = FALSE;
	    }
	  
	  if (!_is_norcroft_compiler &&	/* these compiler produce object code output, not assembler */
	      (NCfiles > 1 || NAfiles > 0 || NOfiles > 0))
	    {
	      if (Assemble( This ) != 0)
		result = FALSE;
	    }
	  break;
	  
#ifndef __ARM	  
	case 'f':
	  if (F77_Compile( This ) != 0)
	    result = FALSE;
	  break;
#endif
	case 'a':
	  if (MacroAssemble( This ) != 0)
	    result = FALSE;

	  if (! _is_transputer_compiler)
	    {
	      if (Assemble( This ) != 0)
		result = FALSE;
	    }
	  
	  if ((NAfiles > 1 || NCfiles > 0 || NOfiles > 0))
	    {
	      if (Assemble( This ) != 0)
		result = FALSE;
	    }
	  
	  break;
	  
	default:
	  /* Modula-2 extensions are three characters wide */
	  
#ifdef __ARM
	  result = TRUE;
#else
	  if (streq( This->ext, "mod" ))
	    {
	      if (M2_CompileMod( This ) != 0)
		result = FALSE;
	    }
	  else if (streq( This->ext, "def" ))
	    {
	      if (M2_CompileDef( This ) != 0)
		result = FALSE;
	      
	      /* delete This node from the list of source  */
	      /* files as it should not be included in the */
	      /* file list passed to the linker.	     */
	      
	      Remove( (Node *)This );
	    }
#endif /* __ARM */	  
	  break;
	}
    }
    
  return result;
    
} /* DoCompiles */

/*}}}*/
/*{{{  DoAssembles */

static bool
DoAssembles(
#ifdef __STDC__
	    void
#endif
	    )
/*
 * perform all necessary assembles
 * returns TRUE if all the assembles complete successfuly, FALSE otherwise
 */
{
  FileNode *	This;
  bool		result = TRUE;
    
    
#ifdef DEBUG
  debug( "DoAssembles() called" );
#endif
  
  for (This = (FileNode *)FirstNode( (List *)&SourceFiles );
       This;
       This = (FileNode *)NextNode( (Node *)This ))
    {
      if (streq( This->ext, "s" ))
	{
	  if (Assemble( This ) != 0)
	    {
	      result = FALSE;
	      
	      break;
	    }
	}
    }
    
  return result;
  
} /* DoAssembles */

/*}}}*/
/*{{{  DoLink */

static bool
DoLink(
#ifdef __STDC__
       void
#endif
       )
/*
 * perform a final link if necessary
 * returns TRUE if this succeeds, FALSE otherwise
 */
{
  NameList	args;
  List *	plist  = (List *)&args;
  int		result = 0;
    
    
#ifdef DEBUG
  debug( "DoLink() called" );
#endif
  
  InitList( plist );

  if (JOIN || APPEND)
    {
      if (_is_transputer_compiler)
	{
	  if (APPEND)
	    {
	      error( "Cannot append to transputer scanned libraries" );

	      return FALSE;	      
	    }
	  
	  AddNamef( plist, "%s", linker    );
	  AddNames( plist, "%s", &LinkOpts );      
	  AddName(  plist, "-p" );
	
	  if (!USE_PIPE || NCfiles == 0) 
	    {
	      AddFiles( plist, "%s.%s", &SourceFiles );
	    }
      
	  if (vfile != NULL)
	    {
	      AddNamef( plist, "-m%s", vfile );
	    }
      
	  if (ObjName != NULL)
	    {
	      AddName(  plist, "-o" 	     );
	      AddNamef( plist, "%s", ObjName );
	    }
	}
      else
	{
	  FILE *	output = Null( FILE );
	  FileNode *	This;
	  
	  
	  /*
	   * we want to concatenate together the files in 'SourceFiles'
	   * into a file called 'ObjName'.  Unfortunately we cannot call
	   * 'cat' as a) it does not have a -o option to redirect its
	   * output and b) it does not understand '-' to read from stdin
	   */

	  result = 0;

	  if (EXECUTE)
	    {
	      /* open output file */
	  
	      if (ObjName == Null( char ))
		{
		  output = stdout;
		}
	      else
		{
		  output = fopen( ObjName, APPEND ? "ab" : "wb" );
	      
		  if (output == Null( FILE ))
		    {
		      warning( "Failed to open output file '%s' for  concatenation", ObjName );

		      return FALSE;	      
		    }
		}
	    }
	  
	  /* tell the world we are about to start */
	  
	  if (VERBOSE || VERIFY)
	    printf( "'cat' " );

	  /* read each of the source files */
	  
	  for (This  = (FileNode *)FirstNode( (List *)&SourceFiles );
	       This != NULL;
	       This  = (FileNode *)NextNode( (Node *)This ) )
	    {
	      FILE *	input;
	      char	name[ ARGBUFSIZE ];


	      /* build the source file's name */
	      
	      sprintf( name, "%s.%s", This->root, This->ext );

	      /* tell the world */
	      
	      if (VERBOSE || VERIFY)
		printf( "%s ", name );

	      if (EXECUTE)
		{
		  /* open the source file */
		  
		  input = fopen( name, "rb" );

		  /* check it */
		  
		  if (input == Null( FILE ))
		    {
		      warning( "Failed to open input file '%s' for concatenation", name );

		      result = 1;
		    }
		  else
		    {
		      /* why bother being clever - the C library will buffer for us anyway */

		      /* copy the source file to the output file */
		      
		      for (;;)
			{
			  int	c;

			  
			  c = fgetc( input );

			  if (feof( input ))
			    break;
			  
			  fputc( c, output );		      
			}

		      /* close the source file */
		      
		      fclose( input );

		      input = Null( FILE );		  /* be paranoid */
		    }
		}
	    }

	  if (VERBOSE || VERIFY)
	    {
	      if (ObjName != NULL)
		printf( "> %s", ObjName );

	      putchar( '\n' );	      
	    }
	  
	  /* close output file */

	  if (EXECUTE)
	    {
	      fclose( output );

	      output = Null( FILE );
	    }	  
	}
    }
  else
    {
      AddNamef( plist, "%s", linker    );
      AddNames( plist, "%s", &LinkOpts );
  
      if (vfile != NULL)
	{
	  AddNamef( plist, "-m%s", vfile );
	}
      
      if (!NOLIBS)
	{
	  if (NFfiles > 0)
	    {
	      AddNamef( plist, "%s%s", c_libdir, link_fstart );
	    }
	  else if (NMfiles > 0)
	    {
	      AddNamef( plist, "%s%s", c_libdir, link_m2start );
	    }
	  else
	    {
	      AddNamef( plist, "%s%s", c_libdir, link_cstart );
	      
	      if (!AddLibrary( c_libdir, link_clib ))
		{
		  warning( "Could not find C library '%s%s'", c_libdir,link_clib );

		  return FALSE;
		}
	    }
	}
	
      if (NSources == 1 && (NCfiles != 0 || NAfiles != 0) && USE_PIPE && !_is_transputer_compiler)
	{
	  AddName( plist, "-" );
	}
      else
	{
	  AddFiles( plist, "%s.%s", &SourceFiles );
	}

      AddNames( plist, "%s", &ScanLibraryNames );

      AddNames( plist, "%s", &ResLibraryNames );
      
      if (state != objed_suppressed)
	{
	  AddNamef( plist, "-n%s", ObjectName );
	  AddNamef( plist, "-s%d", StackSize  );
	  AddNamef( plist, "-h%d", HeapSize   );
	}
      
      if (ObjName != NULL)
	{		
	  AddName(  plist, "-o"		 );
	  AddNamef( plist, "%s", ObjName );
	}
    }

  if (!JOIN && !APPEND || _is_transputer_compiler)
    result = ExecuteList( plist );
  
  /*
   * When one source is compiled and linked, the intermediate file is removed 
   */
  
  if (!JOIN              &&
      !USE_PIPE          &&
      NCompiles   == 1   &&
      LastCompile != NULL )
    {
      RemoveFile( LastCompile );
    }
    
  return (result == 0);
    
} /* DoLink */

/*}}}*/

/*}}}*/
/*{{{  Command Line Construction */

/*{{{  ParseWarnings */

static void
#ifdef __STDC__
ParseWarnings( char * s )
#else
ParseWarnings( s )
  char * s;
#endif
/*
 * parse the warning / error suppression options
 */
{
  for (; *s; s++)
    {
      switch (*s)
	{
	case 'A':
	  if (compiler != UNKNOWN_COMPILER)
	    {
	      Warns = WARN_a | WARN_d | WARN_f | WARN_i | WARN_n | WARN_o | WARN_p | WARN_u | WARN_v ;
	      Errs  = 0;
	    }
	  else
	    {
	      Warns = WARN_a | WARN_d | WARN_f | WARN_s | WARN_v;
	      Errs  = ERR_c  | ERR_p  | ERR_z;
	    }
	  break;
	  
	case 'a':
	  Warns |= WARN_a;
	  break;
	  
	case 'c':
	  Errs  |= ERR_c;
	  break;
	  
	case 'd':
	  Warns |= WARN_d;
	  break;
	  
 	case 'f':
	  Warns |= WARN_f;
	  break;

	case 'i':
	  if (_is_norcroft_compiler)
	    Warns |= WARN_i;
	  break;

	case 'n':
	  if (_is_norcroft_compiler)
	    Warns |= WARN_n;
	  break;

	case 'o':
	  if (_is_norcroft_compiler)
	    Warns |= WARN_o;
	  break;

	case 'p':
	  if (compiler != UNKNOWN_COMPILER)
	    {
	      Warns |= WARN_p;
	    }
	  else
	    {
	      Errs  |= ERR_p;
	    }
	  break;
	  
	case 's':
	  Warns |= WARN_s;
	  break;
	  
	case 'u':
	  if (_is_norcroft_compiler)
	    Warns |= WARN_u;
	  break;

	case 'v':
	  Warns |= WARN_v;
	  break;
	  
	case 'z':
	  Errs  |= ERR_z;
	  break;
	  
	default:
	  warning( "Unknown warning suppression option -w%c, ignored", *s );
	}
    }

  return;
  
} /* ParseWarnings */

/*}}}*/
/*{{{  ParseFeatures */

static void
#ifdef __STDC__
ParseFeatures( char * s )
#else
ParseFeatures( s )
  char * s;
#endif
/*
 * parse the features options
 */
{
  for (; *s; s++)
    {
      switch (*s)
	{
	case 'A':
	  switch (compiler)
	    {
	    default:
	    case C40_COMPILER:
	    case TRANSPUTER_COMPILER:
	      Feats |= FEAT_s | FEAT_g;
	      break;

	    case M68K_COMPILER:
	    case ARM_COMPILER:
	    case I860_COMPILER:
	      break;
	    }
	  break;
	  
	case 'b':
	  if (compiler == C40_COMPILER)
	    Feats |= FEAT_b;
	  break;
	  
	case 'd':
	  if (compiler == C40_COMPILER)
	    Feats |= FEAT_d;
	  break;
	  
	case 'f':
	  if (_is_transputer_compiler)
	    Feats |= FEAT_f;
	  break;
	  
	case 'g':
	  Feats |= FEAT_g;
	  break;
	  
	case 'h':
	  Feats |= FEAT_h;
	  break;
	  
	case 'l':
	  Feats |= FEAT_l;
	  break;
	  
	case 'm':
	  Feats |= FEAT_m;
	  break;
	  
	case 'n':
	  Feats |= FEAT_n;
	  break;
	  
	case 'p':
	  if (compiler == C40_COMPILER)
	    Feats |= FEAT_p;
	  break;
	  
	case 's':
	  Feats |= FEAT_s;
	  break;
	  
	case 'u':
	  Feats |= FEAT_u;
	  break;
	  
	case 'v':
	  Feats |= FEAT_v;
	  break;
	  
	default:
	  warning( "Unknown feature -F%c, ignored", *s );
	}
    }

  return;
  
} /* ParseFeatures */

/*}}}*/
/*{{{  AddWarningsAndFeatures */

static void
AddWarningsAndFeatures(
#ifdef __STDC__
		       void
#endif
		       )
/*
 * adds the parsed warning / error suppressions and the features
 * to the argument list
 */
{
  static char buf[ ARGBUFSIZE ];
  
  
  if (Warns != 0)
    {
      strcpy( buf, "-w" );
      
      if ((Warns & WARN_a) != 0) strcat( buf, "a" );
      if ((Warns & WARN_d) != 0) strcat( buf, "d" );
      if ((Warns & WARN_f) != 0) strcat( buf, "f" );
      if ((Warns & WARN_n) != 0) strcat( buf, "n" );
      if ((Warns & WARN_p) != 0) strcat( buf, "p" );
      if ((Warns & WARN_s) != 0) strcat( buf, "s" );
      if ((Warns & WARN_v) != 0) strcat( buf, "v" );

      AddName( &CompileOpts, buf );
    }
  
  if (Errs != 0)
    {
      if (_is_norcroft_compiler)
	strcpy( buf, "-W" );
      else
	strcpy( buf, "-e" );

      if ((Errs & ERR_c) != 0) strcat( buf, "c" );
      if ((Errs & ERR_p) != 0) strcat( buf, "p" );
      if ((Errs & ERR_z) != 0) strcat( buf, "z" );
      
      AddName( &CompileOpts, buf );
    }
  
  if (Feats != 0)
    {
      strcpy( buf, "-f" );
      
      if ((Feats & FEAT_d) != 0) strcat( buf, "d" );
      if ((Feats & FEAT_h) != 0) strcat( buf, "h" );
      if ((Feats & FEAT_m) != 0) strcat( buf, "m" );
      if ((Feats & FEAT_v) != 0) strcat( buf, "v" );

      if (VERBOSE && _is_norcroft_compiler)
	strcat( buf, "s" );
	
      if ((Warns & WARN_o) != 0) strcat( buf, "o" );
      if ((Warns & WARN_u) != 0) strcat( buf, "a" );
      if ((Warns & WARN_i) != 0) strcat( buf, "p" );      
      
      if ((Feats & FEAT_f) != 0)
	{
	  if (compiler == UNKNOWN_COMPILER)
	    strcat( buf, "f" );
	  else if (compiler == TRANSPUTER_COMPILER)
	    AddName( &CompileOpts, "-pf0" );
	  else
	    warning( "f feature not supported for non-transputer compilers" );
	}
      
      if ((Feats & FEAT_b) != 0)
	{
	  AddName( &CompileOpts, "-Zpm1" );
	}
      
      if ((Feats & FEAT_g) != 0)
	{
	  if (compiler == UNKNOWN_COMPILER)
	    AddName( &CompileOpts, "-pg0" );	/* old transputer compiler uses a pragma */
	  else
	    strcat( buf, "f" );			/* Norcroft compilers use a feature */
	}
      
      if ((Feats & FEAT_n) != 0)
	{
	  if (compiler != UNKNOWN_COMPILER)
	    AddName( &CompileOpts, "-Zpf0" );
	  else
	    AddName( &CompileOpts, "-pf0" );
	}	
      
      if ((Feats & FEAT_p) != 0)
	{
	  AddName( &CompileOpts, "-Zpn1" );
	}

      if ((Feats & FEAT_l) != 0 && compiler == C40_COMPILER)
	{
	  AddName( &CompileOpts, "-Zpl1" );
	}

      if ((Feats & FEAT_s) != 0)
	{
	  if (compiler != UNKNOWN_COMPILER)
	    AddName( &CompileOpts, "-Zps1" );
	  else
	    AddName( &CompileOpts, "-ps1" );
	}

      if ((Feats & FEAT_u) != 0)
	{
	  AddName( &LinkOpts, "-wru" );
	}
      
      AddName( &CompileOpts, buf );
    }

  return;
  
} /* AddWarningsAndFeatures */

/*}}}*/
/*{{{  AddDefines */

static void
AddDefines(
#ifdef __STDC__
	   void
#endif
	   )
/*
 * add the define list to the argument list
 */
{
  if (_is_norcroft_compiler)
    AddNames( &CompileOpts, "-D%s", &Defines );
  else
    AddNames( &CompileOpts, "-d%s", &Defines );

  return;
  
} /* AddDefines */

/*}}}*/
/*{{{  AddInclude */

static void
#ifdef __STDC__
AddInclude( char * path )
#else
AddInclude( path )
  char * path;
#endif
/*
 * add the indicated path(s) to the include argument list
 */
{
  static char	buffer[ ARGBUFSIZE ];
  NameNode *	This;
  char *	end;
  char *	start = path;
  
  
  while (path != NULL)
    {
      end = strchr( start, ',' );
      
      if (end != NULL)
	{
	  *end = '\0';
	}
      else
	{
	  path = NULL;
	}
      
      strcpy( buffer, start );
      
      start = end + 1;
      
      /*
       * add trailing / if none present and name is not blank
       */
      
      if (buffer[ strlen( buffer ) - 1 ] != '/' && strlen( buffer ) > 0)
	{
	  strcat( buffer, "/" );
	}
      
      /*
       * check for and ignore duplicates, for faster compilation
       */
      
      for ( This = (NameNode *)FirstNode( (List *)&IncludeDirs );
	   This;
	   This = (NameNode *)NextNode( (Node *)This) )
	{
	  if (streq( This->name, buffer ))
	    return;
	}
      
      AddName( &IncludeDirs, buffer );
    }

  return;
  
} /* AddInclude */

/*}}}*/
/*{{{  AddSymbol */

static void
#ifdef __STDC__
AddSymbol( char * path )
#else
AddSymbol( path )
  char * path;
#endif
/*
 * add the indicated path(s) to the symbol search argument list (M2)
 */
{
  static char	buffer[ ARGBUFSIZE ];
  NameNode *	This;
  char *	end;
  char *	start = path;
  
  
  while (path != NULL)
    {
      end = strchr( start, ',' );
      
      if (end != NULL)
	{
	  *end = '\0';
	}
      else
	{
	  path = NULL;
	}
      
      strcpy( buffer, start );
      
      start = end + 1;
      
      /*
       * add trailing / if none present and name is not blank
       */
      
      if (buffer[ strlen( buffer ) - 1 ] != '/' && strlen( buffer ) > 0)
	{
	  strcat( buffer, "/" );
	}
      
      /*
       * check for and ignore duplicates, for faster compilation
       */
      
      for ( This = (NameNode *)FirstNode( (List *)&SymbolDirs );
	   This;
	   This = (NameNode *)NextNode( (Node *)This) )
	{
	  if (streq( This->name, buffer ))
	    return;
	}
      
      AddName( &SymbolDirs, buffer );
    }

  return;
  
} /* AddSymbol */

/*}}}*/
/*{{{  AddLibraryPath */

static void
#ifdef __STDC__
AddLibraryPath( char * path )
#else
AddLibraryPath( path )
  char * path;
#endif
/*
 * add the indicated path(s) to the library path list
 */
{
  static char	buffer[ ARGBUFSIZE ];
  NameNode *	This;
  char *	end;
  char *	start = path;
  

  while (path != NULL)
    {
      end = strchr( start, ',' );
      
      if (end != NULL)
	{
	  *end = '\0';
	}
      else
	{
	  path = NULL;
	}
      
      strcpy( buffer, start );
      
      start = end + 1;
      
      /*
       * add trailing / if none present and name is not blank
       */
      
      if (buffer[ strlen( buffer ) - 1 ] != '/' && strlen( buffer ) > 0)
	{
	  strcat( buffer, "/" );
	}
      
      /*
       * check for and ignore duplicates, for faster compilation
       */
      
      for (This = (NameNode *)FirstNode( (List *)&LibraryDirs );
	   This;
	   This = (NameNode *)NextNode( (Node *)This) )
	{
	  if (streq( This->name, buffer ))
	    {
	      return;
	    }
	}

      AddNameToFront( &LibraryDirs, buffer );
    }

  return;
  
} /* AddLibraryPath */

/*}}}*/
/*{{{  RemoveLibraryPath */

static void
#ifdef __STDC__
RemoveLibraryPath( char * pPath )
#else
RemoveLibraryPath( pPath )
  char * pPath;
#endif
/*
 * Remove the indicated path(s) from the library path list
 */
{
  static char	aBuffer[ ARGBUFSIZE ];
  NameNode *	pThis;
  char *	pEnd;
  char *	pStart = pPath;

  
  while (pPath != NULL)
    {
      pEnd = strchr( pStart, ',' );
      
      if (pEnd != NULL)
	{
	  *pEnd = '\0';
	}
      else
	{
	  pPath = NULL;
	}
      
      strcpy( aBuffer, pStart );
      
      pStart = pEnd + 1;
      
      /* add trailing / if none present and name is not blank */
      
      if (aBuffer[ strlen( aBuffer ) - 1 ] != '/' && strlen( aBuffer ) > 0)
	{
	  strcat( aBuffer, "/" );
	}

      /* find name in list and remove */
      
      for (pThis  = (NameNode *)FirstNode( (List *)&LibraryDirs );
	   pThis != NULL;
	   pThis  = (NameNode *)NextNode( (Node *)pThis) )
	{
	  if (streq( pThis->name, aBuffer ))
	    {
	      Remove( (Node *) pThis );
	      break;
	    }
	}

      if (pThis == NULL)
	warning( "Unable to remove library path '%s'", aBuffer );
    }

  return;
  
} /* RemoveLibraryPath */

/*}}}*/
/*{{{  AddIncludeOpts */

static void
AddIncludeOpts(
#ifdef __STDC__
	       void
#endif
	       )
/*
 * add the include path(s) to the C compiler's search list
 */
{
  static char	buffer[ ARGBUFSIZE ];
  NameNode *	This = (NameNode *)FirstNode( (List *)&IncludeDirs );
  
  
  if (This == NULL)
    return;
  
  strcpy( buffer, "-i" );
  
  for ( ;
       This;
       This = (NameNode *)NextNode( (Node *)This) )
    {
      strcat( buffer, This->name );
      strcat( buffer, "," );
    }
  
  buffer[ strlen( buffer ) - 1 ] = '\0'; 	/* remove trailing ',' */
  
  AddName( &CompileOpts, buffer ); 		/* -i version */
  
  /*
   * start -j option 3 places futher on so that we miss the "./,"
   * at the start of the -i option
   */
  
  buffer[ 3 ] = '-';
  buffer[ 4 ] = 'j';
  
  AddName( &CompileOpts, buffer + 3 ); 		/* -j version */

  return;
  
} /* AddIncludeOpts */

/*}}}*/
/*{{{  AddSymbolOpts */

static void
AddSymbolOpts(
#ifdef __STDC__
	      void
#endif
	      )
/*
 * compile a symbol list for passing to the modula compiler
 */
{
  static char	buffer[ ARGBUFSIZE ];
  NameNode *	This = (NameNode *)FirstNode( (List *)&SymbolDirs );
  
  
  if (This == NULL)
    return;
  
  strcpy( buffer, "-i" );
  
  for (;
       This;
       This = (NameNode *)NextNode( (Node *)This ))
    {
      strcat( buffer, This->name );
      strcat( buffer, "," );
    }
  
  buffer[ strlen( buffer ) - 1 ] = '\0'; 	/* remove trailing ',' */
  
  AddName( &ModulaOpts, buffer ); 		/* -i version */

  return;
  
} /* AddSymbolOpts */

/*}}}*/

/*}}}*/
/*{{{  Utilities for main */

/*{{{  CountSources */

static void
CountSources(
#ifdef __STDC__
	     void
#endif
	     )
/*
 * returns number of source files to be compiled
 */
{
  FileNode *	This;
  NameNode *	pname;
  
  
  NOfiles = NAfiles = NCfiles = NFfiles = NSfiles = NDfiles = NMfiles = NSources = 0;
  
  for (This = (FileNode *)FirstNode( (List *)&SourceFiles );
       This;
       This = (FileNode *)NextNode( (Node *)This ))
    {
      NSources++;
      
      switch (*This->ext)
	{
	case 'i':		/* pre-processed C source */
	case 'c':
	  NCfiles++;
	  break;
	  
	case 'f':
	  NFfiles++;
	  break;
	  
	case 's':
	  NSfiles++;
	  break;
	  
	case 'a':
	  break;
	  
	case 'o':
	   /* 
	    * catch the case where someone includes /helios/lib/c0.o
	    * in their object list
	    */
	  
	  if (strneq( This->root, link_cstart, strlen( link_cstart ) - 2 ))
	    link_cstart = NULL;
	  else
	    NOfiles++;

	  break;
	  
	case 'p':
	  break;
	  
	default:
	  if (streq( This->ext, "mod" ))
	    NMfiles++;
	  else if (streq( This->ext, "def" ))
	    NDfiles++;
	  else if (streq( This->ext, "lib" ))
	    break;
	  else
	    fail( "unknown type of source file => %s.%s", This->root, This->ext );
	  break;
	}
    }
  
  for (pname  = (NameNode *)FirstNode( &ScanLibraryNames );
       pname != NULL;
       pname  = (NameNode *)NextNode( (Node *)pname ) )
    {
      /*
       * scanned libraries placed here without a -l at
       * the start are intended to be included in their
       * entirity, and hence count as source files.
       */
      
      if (*pname->name != '-')
	++NSources;
    }

  return;
  
} /* CountSources */

/*}}}*/
/*{{{  usage */

static void
usage(
#ifdef __STDC__
      void
#endif
      )
  /*
   * describe the options to this utility
   */
{
  int	err = dup( 2 );
  int	pid;
  int	pfds[ 2 ];
  
  
  pipe( pfds );
  
  pid = vfork();
  
  if (pid == 0)
    {
      dup2( pfds[ 0 ], 0 );
      
      close( pfds[ 0 ] );
      close( pfds[ 1 ] );
      
      execlp( "more", "more", 0 );
      
      pid = -1;
      
      _exit( 0 );
    }
  
  if (pid == -1)
    close( err );
  
  else dup2( pfds[ 1 ], 2 );
  
  close( pfds[ 0 ] );
  close( pfds[ 1 ] );
  
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.1.1.1 $)", VERSION, REVISION );
  error( "Usage: %s [options] files", ProgName );

{ static char *strings[] = {
"*.c\t\tC source file.\n\
*.i\t\tPre-processed C source file.\n",
#ifndef __ARM
"*.f\t\tFORTRAN source file.",
#endif
"*.s\t\tAssembler source file.\n\
*.a\t\tMacro Assembler source file.",
#ifndef __ARM
"*.def\t\tModula-2 definition source file.\n\
*.mod\t\tModula-2 program source file.",
#endif
"*.o\t\tAssembled file - ready for linking.\n\
-a<text>\tPass <text> as an option to assembler.\n\
-b\t\tDon't link with standard library (helios.lib).\n\
-c\t\tCompile/Assemble only, don't link.\n\
-c40\t\tCompile code for a C40.\n\
-d<name>\tSpecify output file name for library .def compilations.",
#ifndef __ARM
"-e[6|7]\t\tEnforce FORTRAN standard.",
#endif
"-f <name>\tSpecify file name for the assembler's virtual memory system.\n\
-g\t\tCompile for debugging.\n\
-h<val>\t\tSpecify heap size of program.\n\
-j\t\tCreate scanned library.\n\
-l<name>\tLink with standard library <name>\n\
-m\t\tCompile code for shared libraries.\n\
-n\t\tDon't actually execute commands (implies -v).",
"-n<string>\tSpecify object name of program.\n\
-o <name>\tSpecify output name (default *.o or \"a.out\") (\"-\" is stdout)\n\
-p\t\tCompile code for profiling (Transputer only).\n\
-q<fgilpz>\tEnable internal compiler debugging features:\n\
\t\t 'f' Function names.\n\
\t\t 'g' Code generation.\n\
\t\t 'i' Include files.\n\
\t\t 'l' Lexical analysis.\n\
\t\t 'p' Pre-processor.\n\
\t\t 'z' Fatal error handling.\n\
-r\t\tCompile code for device drivers.",
"-s<val>\t\tSpecify stack size of program.\n\
-t\t\tCompile code for (back) tracing.\n\
-tran\t\tCompile code for Transputers.\n\
-u\t\tPrevents removal of intermediary files.\n\
-v\t\tDisplay command(s) being executed.\n\
-w[Aacdfpsvz]\tSuppress warnings and error messages from the C compiler when:",
"\t\t 'a' '=' occurs in a condition context,\n\
\t\t 'c' ANSI disallowed casts are used,\n\
\t\t 'd' (some)deprecated features are used,\n\
\t\t 'f' functions are implicity declared as 'extern int()',\n\
\t\t 'i' pointers are explicitly cast to integers,\n\
\t\t 'n' implicit casting between types,\n\
\t\t 'o' old K&R style function headers are used,",
"\t\t 'p' junk occurs after #else and #endif,\n\
\t\t 's' shorts are used for the first time, (Transputer)\n\
\t\t 'u' unused variables,\n\
\t\t 'v' void functions are written without 'void',\n\
\t\t 'z' zero sized arrays occur,\n\
\t\t 'A' all of the above.\n\
-x<proctype>\tCompile code for <proctype> (arm/c40/m68k/tran).\n\
-y<text>\tPass <text> as an option to the Macro Assembler.",
"-z<text>\tPass <text> as an option to the C compiler.\n\
-A<text>\tPass <text> as an option to the linker.\n\
-B\t\tDo not link with any libraries.  Do not perform objed.\n\
-C\t\tPerform array bound (F77,M2) or memory access checking (C)\n\
-C40\t\tCompile code for C40s.\n\
-D <name>\t#define <name>",
"-D <name>=<val> #define <name> to be <val> (default <val> is \"1\").\n\
-E\t\tPre-process only - do not compile\n\
-F[Afghmnpsuv]  Enable C  compiler features:\n\
\t\t 'b' enables back trace support (C40)\n\
\t\t 'd' disables new stub generation (C40)\n\
\t\t 'f' disables the vector stack (Transputer)\n\
\t\t 'g' removes procedure names from the code\n\
\t\t 'h' warns of discrepencies in function declarations\n\
\t\t 'l' small model (C40)",
"\t\t 'm' warns of unused macros\n\
\t\t 'n' do not put arrays or structs on vector stack (Transputer)\n\
\t\t 'p' disables peepholing by the code generator (C40)\n\
\t\t 's' turns off stack checking\n\
\t\t 'u' warns of unused functions and variables during linking\n\
\t\t 'v' warns of unused global functions and variables in a file\n\
\t\t 'A' turns on selected useful features\n\
-I<dir>\t\tSpecify a directory to be searched for #include or Modula-2\n\
\t\tsymbol files.\n\
-J\t\tAppend to scanned library.",
#ifndef __ARM
"-K<text>\tPass <text> as an option to Modula-2 compiler.",
#endif
"-L<dir>\t\tSpecifies directories to be searched for libraries.",
#ifndef __ARM
"-M<name>\tProduce map file <name> (F77).",
"-M68K\t\tCompile code for M68K processors.",
#endif
"-O\t\tOptimise code, perform full link.\n\
-P<text>\tPass <text> as an option to the pre-processor.",
#ifndef __ARM
"-R\t\tForce use of RAM disk for temporary FORTRAN and Modula-2 files,\n\
\t\teven if RAM disk is not loaded",
#endif
"-S\t\tProduce textual assembler output from *.c in *.s, don't link.",
#ifndef __ARM
"-T[4|5|8|9]\tSpecify Transputer type.(5 => T425)",
#endif
"-V\t\tPass on verbose flag to executed commands.\n\
-U <name>\tRemoves any initial definition of <name>.",
#ifndef __ARM
"-W<val>\t\tSpecify warning level (F77).",
#endif
"-Wc,arg[,args]  Pass on arguments to specific parts of the compilation.\n\
\t\twhere c is one of :-\n\
\t\t 'p' C pre-processor (cf -P),\n\
\t\t '0' C compiler (cf -z),\n\
\t\t '2' C compiler (optimising section),\n\
\t\t 'a' assembler (cf -a),\n\
\t\t 'l' linker (cf -A),\n\
\t\t 'M' Macro Assembler (cf -y),",
#ifndef __ARM
"\t\t 'm' Modula-2 compiler (cf -M).\n\
-X<val>\t\tSpecify cross reference width (F77).\n\
-Z<text>\tPass <text> as an option to FORTRAN compiler.",
#endif
"-help\t\tThis message.",
"",
"The driver uses the following environment variables if present:-\n\
SHELL\t\tPathname of the command line interpreter.\n\
C_COMPILER\tPathname of the C compiler.\n\
PRE_PROCESSOR\tPathname of the C pre-processor.",
#ifndef __ARM
"F77_PASS1\tPathname of the first  pass of the FORTRAN compiler.\n\
F77_PASS2\tPathname of the second pass of the FORTRAN compiler.\n\
M2_COMPILER\tPathname of the Modula-2 compiler.",
#endif
"ASSEMBLER\tPathname of the assembler.\n\
LINKER\t\tPathname of the linker.\n\
REMOVER\t\tPathname of the file removal program.\n\
MACRO\t\tPathname of the assembler macro pre-processor.\n\
MACDIR\t\tPathname of the standard AMPP macro directory.\n\
C_LIBDIR\tPathname of the library directory.\n\
C_INCDIR\tPathname of the standard C header directory.",
#ifndef __ARM
"TMPDIR\t\tPathname of the directory for holding temporary FORTRAN files",
#endif
"LINK_HELIOS\tName\t of the standard Helios link library.\n\
LINK_CSTART\tName\t of the standard C startup file.\n\
LINK_CLIB\tName\t of the standard C link library.",
#ifndef __ARM
"LINK_FSTART\tName\t of the standard FORTRAN startup file.\n\
LINK_M2START\tName\t of the standard Modula-2 startup file.",
#endif
"MACHINENAME\tName\t of the destination hardware, passed on by -D.\n\
OBJNAME\t\tDefault name of output file.\n\
C_NONSTANDARD\tEnables non-standard features.\n\
\t\t (uses pipes to connect processes and\n\
\t\t does not use 'a.out' unless really necessary)",
"NEW_NCC\t\tDescribes the type of Norcroft C compiler being used, could be:\n\
\t\t ARM\t  For the Helios ARM C compiler\n\
\t\t C40\t  For the Helios TMS320C40 C compiler\n\
\t\t I860\t  For the Helios i860 C compiler\n\
\t\t M68K\t  For the Helios m68K C compiler\n\
\t\t TRAN\t  For the new Helios Transputer C compiler\n\
\t\t OLD_TRAN For the old Helios Transputer C compiler (default)",
NULL
};
  int i;
  for (i = 0; strings[i] != NULL; i++)
	error(strings[i]);
}
  
  if (pid >= 0) 
    {
      int 	stat;
      int 	p;
      
      
      close( 2 );
      
      p = wait( &stat );
      
      dup2( err, 2 );
      
      close( err );
    }
  
  return;
  
} /* usage */

/*}}}*/

/*}}}*/
/*{{{  Main */

#define	get_var( var, val, default ) 	\
  if ((var = getenv( val )) == NULL) 	\
    {					\
      var = default;			\
    }
  

int
#ifdef __STDC__
main(
     int	argc,
     char **	argv )
#else
main( argc, argv )
  int		argc;
  char **	argv;
#endif
{
#ifndef UNIX
  Object *	o;
#endif
  int		i 	 = 0x01020304;
  bool		succeeded = TRUE;
  char *	ld;
  char *	cc;
  char *	cld;
  
    
  if ((ProgName = strrchr( argv[ 0 ], '/')) != NULL)
    {
      ProgName++;
    }
  else
    {
      ProgName  = argv[ 0 ];
    }

  get_var( shell,         "SHELL",         SHELL         );
  get_var( pre_processor, "PRE_PROCESSOR", PRE_PROCESSOR );
  get_var( f77_pass1,     "F77_PASS1",     F77_PASS1     );
  get_var( f77_pass2,     "F77_PASS2",     F77_PASS2     );
  get_var( m2_compiler,   "M2_COMPILER",   M2_COMPILER   );
  get_var( assembler,     "ASSEMBLER",     ASSEMBLER     );
  get_var( remover,       "REMOVER",       REMOVER       );
  get_var( macro,         "MACRO",         MACRO         );
  get_var( macdir,        "MACDIR",        MACDIR        );
  get_var( c_incdir,      "C_INCDIR",      C_INCDIR      );
  get_var( symdir,        "SYMDIR",        SYMDIR        );
  get_var( link_helios,   "LINK_HELIOS",   LINK_HELIOS   );
  get_var( link_cstart,   "LINK_CSTART",   LINK_CSTART   );
  get_var( link_clib,     "LINK_CLIB",     LINK_CLIB     );
  get_var( link_fstart,   "LINK_FSTART",   LINK_FSTART   );
  get_var( link_m2start,  "LINK_M2START",  LINK_M2START  );
  get_var( ObjectName,    "OBJNAME",       OBJNAME       );
  get_var( machinename,   "MACHINENAME",   MACHINENAME   );
      
  if (getenv( "C_NONSTANDARD" ))
    {
      use_non_standard_features = true;
    }

#if   defined __ARM
  
  compiler = ARM_COMPILER;

#elif defined __C40

  compiler = C40_COMPILER;
  
#elif defined __I860

  compiler = I860_COMPILER;
  
#elif defined __M68K

  compiler = M68K_COMPILER;
  
#endif
  
  if (getenv( "NEW_NCC" ))
    {
      char *	ptr = getenv( "NEW_NCC" );
      char *	mc  = getenv( "MACHINENAME" );
      
      
      compiler = TRANSPUTER_COMPILER;
      ld       = TRANSPUTER_LINKER;
      cc       = TRANSPUTER_CC;
      cld      = TRANSPUTER_C_LIBDIR;
      
      if (streq( ptr, "C40" ))
	{
	  compiler = C40_COMPILER;
	  ld	   = C40_LINKER;
	  cc	   = C40_CC;
	  cld      = C40_C_LIBDIR;
	  
	  if (mc == NULL)
	    machinename = C40_MACHINENAME;
	}
      else if (streq( ptr, "ARM" ))
	{
	  compiler = ARM_COMPILER;
	  ld       = ARM_LINKER;
	  cc	   = ARM_CC;
	  
	  if (mc == NULL)
	    machinename = ARM_MACHINENAME;
	}
      else if (streq( ptr, "I860" ))
	{
	  compiler = I860_COMPILER;
	  ld	   = I860_LINKER;
	  cc	   = I860_CC;
      
	  if (mc == NULL)
	    machinename = I860_MACHINENAME;
	}
      else if (streq( ptr, "M68K" ))
	{
	  compiler = M68K_COMPILER;
	  ld       = M68K_LINKER;
	  cc	   = M68K_CC;
	  
	  if (mc == NULL)
	    machinename = M68K_MACHINENAME;
	}
      else if (streq( ptr, "OLD_TRAN" ))
	{
	  compiler = UNKNOWN_COMPILER;
	  
	  if (mc == NULL)
	    machinename = TRANSPUTER_MACHINENAME;
	}
      else
	{
	  if (!streq( ptr, "TRANSPUTER" ) && !streq( ptr, "TRAN" ))
	    warning( "unknown NEW_NCC environment option '%s'", ptr );
	  
	  if (mc == NULL)
	    machinename = TRANSPUTER_MACHINENAME;
	}
    }
  else
    {
      ld  = LINKER;
      cc  = C_COMPILER;
      cld = C_LIBDIR;
    }  

  get_var( linker,     "LINKER",     ld  );
  get_var( c_compiler, "C_COMPILER", cc  );
  get_var( c_libdir,   "C_LIBDIR",   cld );
  
  InitList( &IncludeDirs      );
  InitList( &SymbolDirs       );
  InitList( &LibraryDirs      );
  InitList( &ScanLibraryNames );
  InitList( &ResLibraryNames  );
  InitList( &Defines          );
  InitList( &SourceFiles      );
  InitList( &CompileOpts      );
  InitList( &PreProcOpts      );
  InitList( &ModulaOpts       );
  InitList( &AssembleOpts     );
  InitList( &MacroOpts        );
  InitList( &LinkOpts         );

  AddLibraryPath( c_libdir );
  
  FortranP1Opts[ 0 ] = '\0';
  FortranP2Opts[ 0 ] = '\0';
  FortranMapFile     = NULL;
  
  NCompiles = 0;
  Flags     = Warns = Errs = 0;
  ObjName   = ObjectName;
  
  HeapSize  = StackSize = 5000;

  /* There does not seem to be an easy way to define the following */
  /* automatically without introducing some circularity		   */
  
  AddInclude( "." );
  AddSymbol ( "." );
  
#ifdef UNIX
  ram_disk_present = false;
#else

  if ((o = Locate( NULL, "/loader/ram" )) == NULL)
    {
      ram_disk_present = false;
    }
  else
    {
      ram_disk_present = true;
      
      Close( o );
      
      AddInclude( "/ram/include/" );
      AddSymbol ( "/ram/symbols/" );
    }
#endif

  for (i = 1; i < argc; i++ )
    {
      char *	arg = argv[ i ];
      

      if (arg[ 0 ] == '-')
	{
	  switch (arg[ 1 ])
	    {
	    case '\0': /* lone "-" on command line */
	      
	      usage();
	      
	      break;
	      
	    case 'A': /* pass option to linker */

	      if (arg[ 2 ] != '\0')
	  	{
		  AddName( &LinkOpts, &arg[ 2 ] );
		}
	      else
		{
		  if (++i >= argc)
		    {
		      fail( "No text following -A option" );
		    }
		
		  AddName( &LinkOpts, &arg[ 2 ] );		  
		}
	      break;
	      
	    case 'B': /* don't link with any libraries */
	      
	      Flags |= FLAG_B;
	      
	      if (state == normal)
		state = objed_suppressed;
	      
	      break;
	      
	    case 'C': /* perform array bound checking */

	      if (streq( arg, "-C40" ))
		{
		  RemoveLibraryPath( c_libdir );
		  
		  compiler    = C40_COMPILER;
		  linker      = C40_LINKER;
		  c_compiler  = C40_CC;
		  c_libdir    = C40_C_LIBDIR;
		  assembler   = C40_ASSEMBLER;
		  machinename = C40_MACHINENAME;
		  
		  AddLibraryPath( c_libdir );
		}
	      else
		{
		  strcat( FortranP2Opts, "+B" );

		  if (_is_norcroft_compiler)
		    {
		      AddName( &CompileOpts, "-Zpc1" );		  
		    }
		}
	      
	      break;
	      
	    case 'D': /* macro definitions */

	      if (arg[ 2 ] == '\0')
		{
		  if (++i >= argc)
		    {
		      fail( "No text following -D option" );
		    }

		  AddName( &Defines, argv[ i ] );
		}
	      else
		{
		  AddName( &Defines, &arg[ 2 ] );
		}
	      
	      break;
	      
	    case 'E': /* pre-process only */
	      
	      Flags |= FLAG_p;
	      
	      break;
	      
	    case 'F': /* compiler features */
	      if (arg[ 2 ] != '\0')
		{
		  ParseFeatures( &arg[ 2 ] );
		}
	      else
		{
		  warning( "no characters after -F option" );
		}
	      break;
	      
	    case 'I': /* include directory */
	      
	      if (arg[ 2 ] != '\0')
		{
		  AddInclude( &arg[ 2 ] );
		  AddSymbol ( &arg[ 2 ] );
		}
	      else
		{
		  if (++i >= argc)
		    {
		      fail( "No directory name following -I option" );
		    }
		  
		  AddInclude( argv[ i ] );
		  AddSymbol ( argv[ i ] );
		}
	      
	      break;
	      
	    case 'J': /* append to library */
	      Flags |= FLAG_J;
	      
	      break;
	      
#ifndef __ARM	      
	    case 'K': /* pass option to Modula-2 compiler */

	      if (arg[ 2 ] != '\0')
		AddName( &ModulaOpts, &arg[ 2 ] );
	      
	      break;
#endif /* __ARM */
	      
	    case 'L': /* add name to library path */

	      if (arg[ 2 ] == '\0')
		{
		  if (++i >= argc)
		    {
		      fail( "No directory name following -L option" );
		    }
		  
		  AddLibraryPath( argv[ i ] );
		}
	      else
		{
		  AddLibraryPath( &arg[ 2 ] );
		}
	      
	      break;
	      
	    case 'M': /* produce map file */

	      if (streq( arg, "-M68K" ))
		{
		  RemoveLibraryPath( c_libdir );
		  
		  compiler    = M68K_COMPILER;
		  linker      = M68K_LINKER;
		  c_compiler  = M68K_CC;
		  c_libdir    = M68K_C_LIBDIR;
		  assembler   = M68K_ASSEMBLER;
		  machinename = M68K_MACHINENAME;
		  
		  AddLibraryPath( c_libdir );
		}
	      else if (arg[ 2 ] != '\0')
		{
		  FortranMapFile = &arg[ 2 ];
		}	      
	      
	      break;
	      
	    case 'O': /* Optimise */
	      
	      Flags |= FLAG_O;
	      break;
	      
	    case 'P': /* pass on option to pre-processor */

	      if (arg[ 2 ] == 0)
		{
		  if (++i >= argc)
		    {
		      fail( "No text following -P option" );
		    }
		  
		  AddName( &PreProcOpts, argv[ i ] );
		}
	      else
		{
		  AddName( &PreProcOpts, &arg[ 2 ] );
		}
	      
	      break;
	      
	    case 'R': /* use RAM disk for temporary files even if ram disk is not present */
	      
	      ram_disk_present = true;
	      break;
	      
	    case 'S': /* Assemble only */
	      
	      Flags |= FLAG_S;
	      break;
	      
	    case 'T': /* Transputer type */
	      if (compiler != TRANSPUTER_COMPILER && compiler != UNKNOWN_COMPILER)
		warning( "-Tn option not applicable to non transputer processors" );
	      else
		switch (arg[ 2 ])
		  {
		  case '9':
		    AddName( &ModulaOpts,  "-t9" );
		    AddName( &CompileOpts, "-t9" );
		    AddName( &Defines,    "T9000" );		    
		    strcat( FortranP2Opts, "+F" );
		    break;
		    
		  case '8':
		    AddName( &ModulaOpts,  "-t8" );
		    AddName( &CompileOpts, "-t8" );
		    AddName( &Defines,    "T800" );
		    strcat( FortranP2Opts, "+F" );
		    break;
		    
		  case '5':
		    AddName( &ModulaOpts,  "-t5" );
		    AddName( &CompileOpts, "-t5" );
		    AddName( &Defines,    "T400" );
		    break;
		    
		  case '4':
		    AddName( &ModulaOpts,  "-t4" );
		    AddName( &CompileOpts, "-t4" );
		    AddName( &Defines,    "T400" );
		    break;
		    
		  case '\0':
		    warning( "No number after -T option, ignored" );
		    
		    break;
		    
		  default:
		    warning( "Unknown transputer type -T'%c', ignored", arg[ 2 ] );
		    
		    break;
		  }

	      break;
	      
	    case 'U': /* remove macro definition */

	      if (arg[ 2 ] == '\0')
		{
		  if (++i >= argc)
		    {
		      fail( "No text following -U option" );
		    }
		  
		  (void) RemoveName( &Defines, argv[ i ] );
	      
		  if (streq( argv[ i ], "_BSD" ))
		    (void) RemoveName( &ScanLibraryNames, "/helios/libbsd.a" );
		}
	      else
		{
		  (void)RemoveName( &Defines, &arg[ 2 ] );
	      
		  if (streq( &arg[ 2 ], "_BSD" ))
		    (void) RemoveName( &ScanLibraryNames, "/helios/libbsd.a" );
		}
	      
	      break;
	      
	    case 'V': /* verbose */
	      
	      Flags |= FLAG_V;
	      break;
	      
	    case 'W': /* warning level */
	      if (arg[ 2 ] != '\0' && arg[ 3 ] == ',')
		{
		  NameList *	plist;

		  
		  /* we have an argument of the form -Wc,arg[,arg...] */

		  switch (arg[ 2 ])
		    {
		    case 'p':	/* pre - processor */
		      plist = &PreProcOpts;
		      break;
		      
		    case '2':	/* optimising C compiler */
		      
		      /* drop through */
		      
		    case '0':	/* C compiler */
		      plist = &CompileOpts;
		      break;
		      
		    case 'a':	/* assembler */
		      plist = &AssembleOpts;
		      break;
		      
		    case 'l':	/* linker */
		      plist = &LinkOpts;
		      break;

		    case 'M':	/* MacroAssembler */
		      plist = &MacroOpts;
		      break;

		    case 'm':	/* Modula-2 */
		      plist = &ModulaOpts;
		      break;

		    default:
		      warning( "unknown compiler phase '%c', -W option has been ignored", arg[ 2 ] );
		      
		      plist = NULL;
		      
		      break;
		    }

		  if (plist)
		    {
		      char *	end;

		      
		      /* advance past start of argument */

		      arg += 4;	/* "-Wc," */

		      do
			{
			  end = strchr( arg, ',' );

			  if (end)
			    {
			      *end++ = '\0';
			    }

			  AddName( plist, arg );

			  arg = end;
			}
		      while (end);
		    }
		}
	      else
		{
		  strcat( FortranP1Opts, "+W" );

		  if (arg[ 2 ] != '\0')
		    strcat( FortranP1Opts, &arg[ 2 ] );
		}

	      break;
	      
	    case 'X': /* Cross reference width */
	      
	      strcat( FortranP1Opts, "+X" );

	      if (arg[ 2 ] != '\0')
		strcat( FortranP1Opts, &arg[ 2 ] );
	      
	      break;
	      
	    case 'Z': /* pass on option to FORTRAN compiler */
	      
	      if (arg[ 2 ] == '\0')
		{
		  if (++i >= argc)
		    {
		      fail( "No text following -Z option" );
		    }
		  
		  strcat( FortranP1Opts, argv[ i ] );
		}
	      else
		{
		  strcat( FortranP1Opts, &arg[ 2 ] );
		}
	      
	      break;
	      
	    case 'a': /* pass on option to assembler */
	      
	      if (arg[ 2 ] == '\0')
		{
		  if (++i >= argc)
		    {
		      fail( "No text following -a option" );
		    }
		  
		  AddName( &AssembleOpts, argv[ i ] );
		}
	      else
		{
		  AddName( &AssembleOpts, &arg[ 2 ] );
		}
	      
	      break;
	      
	    case 'b': /* don't link with standard maths libraries */
	      
	      Flags |= FLAG_b;
	      
	      break;
	      
	    case 'c': /* compile only */
	      
	      if (streq( arg, "-c40" ))
		{
		  RemoveLibraryPath( c_libdir );
		  
		  compiler    = C40_COMPILER;
		  linker      = C40_LINKER;
		  c_compiler  = C40_CC;
		  assembler   = C40_ASSEMBLER;
		  c_libdir    = C40_C_LIBDIR;
		  machinename = C40_MACHINENAME;
		  
		  AddLibraryPath( c_libdir );
		}
	      else
		{
		  Flags |= FLAG_c;
		}

	      break;
	      
	    case 'd': /* .def output file */

	      if (arg[ 2 ] != '\0')
		AddName( &LinkOpts, &arg[ 0 ] );
	      
	      break;
#ifndef __ARM	      
	    case 'e': /* enforce standards */
	      
	      switch (arg[ 2 ])
		{
		case '6':
		  strcat( FortranP1Opts, "+6" );
		  break;
		  
		case '7':
		  strcat( FortranP1Opts, "+7" );
		  break;

		case '\0':
		  warning( "No number following -e option, ignored" );

		  break;
		  
		default:
		  warning( "Unknown -e option %c, ignored", arg[ 2 ] );
		  
		  break;
		}
	      
	      break;
#endif /* __ARM */	      
	    case 'f': /* virtual memory file name */
	      
	      if (arg[ 2 ] != '\0')
		{
		  vfile = &arg[ 2 ];
		}
	      else
		{
		  if (++i >= argc)
		    {
		      fail( "No filename following -f" );
		    }
		  
		  vfile = argv[ i ];
		}
	      
	      break;
	      
	    case 'g': /* compile for debugging */
	      
	      AddName( &CompileOpts, "-g" );
	      
	      AddName( &ModulaOpts,  "-g" );
	      
	      strcat( FortranP2Opts, "+G" );

	      (void) AddLibrary( c_libdir, "d" );	/* debugging library */
	      
	      break;
	      
	    case 'h': /* specify heap size */
	      
	      if (!strncmp( &arg[ 1 ], "help", 4 ))
		{
		  usage();
		  
		  return 0;
		}
	      else if ((HeapSize = atoi( &arg[ 2 ] )) < 200)
		{				
		  warning( "a heap size of %d is too small, adjusting to 200", HeapSize );

		  HeapSize = 200;
		}
	      
	      state = objed_enabled;
	      
	      break;
	      
	    case 'j': /* join object files */
	      
	      Flags |= FLAG_j;
	      
	      break;
	      
	    case 'l': /* specify library */

	      if (arg[ 2 ] == '\0')
		{
		  if (++i >= argc)
		    {
		      fail( "No library name following -l option" );
		    }

		  FindAndAddLibrary( argv[ i ] );
		}
	      else
		{
		  FindAndAddLibrary( &arg[ 2 ] );
		}
	      
	      break;
	      
	    case 'm': /* compile for library */

	      switch (compiler)
		{
		case UNKNOWN_COMPILER:
		default:
		  AddName( &CompileOpts, "-l" );
		  break;

		case TRANSPUTER_COMPILER:
		  fail( "New Compiler does not support resident libraries (yet)" );    
		  break;

		case ARM_COMPILER:
		case C40_COMPILER:
		  AddName( &CompileOpts, "-Zl");
		  AddName( &AssembleOpts, "-d");
		  break;
		}
	      
	      AddName( &ModulaOpts,  "-m" );
	      
	      strcat( FortranP2Opts, "+M" );

	      break;
	      
	    case 'n': /* report commands executed OR specify object name */
	      
	      if (arg[ 2 ] != '\0')
		{
		  ObjectName = &arg[ 2 ];
		}
	      else
		{
		  Flags |= FLAG_n;
		  Flags |= FLAG_v; 	/* must be verbose too */
		}
	      
	      break;
	      
	    case 'o': /* output file name */
	      
	      Flags |= FLAG_o;
	      
	      if (arg[ 2 ] != '\0')
		{
		  ObjName = &arg[ 2 ];
		  
		  if (streq( ObjectName, OBJNAME ))
		    {
		      ObjectName = ObjName;
		    }
		  
		  if (streq( ObjName, "-" ))
		    {
		      ObjName    = NULL;
		      ObjectName = OBJNAME;
		    }
		}
	      else
		{
		  i++;
		  
		  if (i >= argc)
		    {
		      fail( "No filename following -o option" );
		    }
		  
		  ObjName = argv[ i ];
		  
		  if (streq( ObjectName, OBJNAME ))
		    {
		      ObjectName = ObjName;
		    }
		  
		  if (streq( ObjName, "-" ))
		    {
		      ObjName    = NULL;
		      ObjectName = OBJNAME;
		    }
		}
	      
	      break;
	      
	    case 'p': /* compile for profiling */
	      if (_is_norcroft_compiler)
		{
		  if (_is_transputer_compiler)
		    AddName( &CompileOpts, "-p" );
		  else
		    warning( "-p option is currently only supported for transputers" );
		}
	      else
		AddName( &CompileOpts, "-k" );		/* old Transputer compiler uses -k for profiling */

	      AddName( &ModulaOpts,  "-p" );
	      
	      strcat( FortranP2Opts, "+P" );
	      
	      break;
	      
	    case 'q': /* compiler debugging features */

	      if (_is_norcroft_compiler)
		{
		  AddNamef( &CompileOpts, "-Zq%s", &arg[ 2 ] );
		}
	      else
		{
		  AddNamef( &CompileOpts, "%s", arg );
		}
	      
	      break;
	      
	    case 'r': /* compile for device driver */

	      switch (compiler)
		{
		case UNKNOWN_COMPILER:
		default:
		  AddName( &CompileOpts, "-r" );
		  break;

		case TRANSPUTER_COMPILER:
		  fail( "New Compiler does not support device drivers (yet)" );    
		  break;

		case C40_COMPILER:
		case ARM_COMPILER:
		  AddName( &CompileOpts, "-Zr" );  
		  AddName( &AssembleOpts, "-d" );	/* do not generate module header/trailer */
		  break;
		}

	      AddName( &ModulaOpts,  "-r" );
	      
	      strcat( FortranP2Opts, "+R" );
	      
	      break;
	      
	    case 's': /* specify stack size */
	      
	      if (arg[ 2 ] != '\0')
		{
		  StackSize = atoi( &arg[ 2 ] );
		}
	      else
		{
		  if (++i >= argc)
		    {
		      fail( "no number following -s option" );
		    }
		  else
		    {
		      StackSize = atoi( argv[ i ] );
		    }
		}
	      
	      if (StackSize < 200)
		{
		  warning( "a stack size of %d is too small, adjusting to 200", StackSize );

		  StackSize = 200;
		}
	      
	      state = objed_enabled;
	      
	      break;
	      
	    case 't': /* compile tracing code */

	      if (streq( arg, "-tran" ) || streq( arg, "-transputer" ))
		{
		  RemoveLibraryPath( c_libdir );
		  
		  compiler    = TRANSPUTER_COMPILER;
		  linker      = TRANSPUTER_LINKER;
		  c_compiler  = TRANSPUTER_CC;
		  machinename = TRANSPUTER_MACHINENAME;
		  assembler   = TRANSPUTER_ASSEMBLER;
		  c_libdir    = TRANSPUTER_C_LIBDIR;
		  
		  AddLibraryPath( c_libdir );
		}
	      else
		{
		  AddName( &ModulaOpts, "-t" );
	      
		  strcat( FortranP1Opts, "+T" );

		  if (_is_norcroft_compiler)
		    {
		      AddName( &CompileOpts, "-Zpm1" );
		    }
		}
	      
	      break;
	      
	    case 'u': /* do not delete temporary files */
	      
	      suppress_removes = true;
	      
	      break;
	      
	    case 'v': /* verify */
	      
	      strcat( FortranP1Opts, "+V" );
	      strcat( FortranP2Opts, "+V" );
	      
	      Flags |= FLAG_v;
	      
	      break;

	    case 'w': /* warning flags */
             if (arg[ 2 ] != '\0')
               ParseWarnings( &arg[ 2 ] );
	      
	      break;
	  
	    case 'x': /* processor type */

	      if (i != 1)
		warning( "-x<name> option should be first in command list" );
	      
	      RemoveLibraryPath( c_libdir );
	      
	      if (streq( arg, "-xarm") || streq( arg, "-xARM"))
		{
		  compiler    = ARM_COMPILER;
		  linker      = ARM_LINKER;
		  c_compiler  = ARM_CC;
		  c_libdir    = ARM_C_LIBDIR;
		  assembler   = ARM_ASSEMBLER;
		  machinename = ARM_MACHINENAME;
		}
	      else if (streq( arg, "-xc40") || streq( arg, "-xC40"))
		{
		  compiler    = C40_COMPILER;
		  linker      = C40_LINKER;
		  c_compiler  = C40_CC;
		  assembler   = C40_ASSEMBLER;
		  c_libdir    = C40_C_LIBDIR;
		  machinename = C40_MACHINENAME;
		}
	      else if (streq( arg, "-xm68k") || streq( arg, "-xM68K"))
		{
		  compiler    = M68K_COMPILER;
		  linker      = M68K_LINKER;
		  c_compiler  = M68K_CC;
		  assembler   = M68K_ASSEMBLER;
		  c_libdir    = M68K_C_LIBDIR;
		  machinename = M68K_MACHINENAME;		  
		}
	      else if (streq( arg, "-xtransputer" ) ||
		       streq( arg, "-xTransputer" ) ||
		       streq( arg, "-xtran" )        )
		{
		  compiler    = TRANSPUTER_COMPILER;
		  linker      = TRANSPUTER_LINKER;
		  c_compiler  = TRANSPUTER_CC;
		  assembler   = TRANSPUTER_ASSEMBLER;
		  c_libdir    = TRANSPUTER_C_LIBDIR;
		  machinename = TRANSPUTER_MACHINENAME;
		}
	      else
		{
		  fail( "No processor type following -x option" );
		}
	      
	      AddLibraryPath( c_libdir );
	      break;

	    case 'y': /* pass on option to macro assembler */
	      
	      if (arg[ 2 ] == '\0')
		{
		  if (++i >= argc)
		    {
		      fail( "No text following -y option" );
		    }
		  
		  AddName( &MacroOpts, argv[ i ] );
		}
	      else
		{
		  AddName( &MacroOpts, &arg[ 2 ] );
		}
	      
	      break;
	      
	    case 'z': /* pass on option to C compiler */
	      
	      if (arg[ 2 ] == '\0')
		{
		  if (++i >= argc)
		    {
		      fail( "No text following -z option" );
		    }
		  
		  AddName( &CompileOpts, &arg[ 2 ] );
		}
	      else
		{
		  AddName( &CompileOpts, &arg[ 2 ] );
		}
	      
	      break;
	      
	    case 'G': /* unused */
	    case 'H': /* unused */
	    case 'N': /* unused */
	    case 'Q': /* unused */
	    case 'Y': /* unused */
	    case 'i': /* unused */
	    case 'k': /* unused */
	    default:
	      
	      warning( "Unknown option '%s' passed to linker", &arg[ 0 ] );
	      
	      AddName( &LinkOpts, &arg[ 0 ] );
	      
	      break;
	    }
	}
      else
	{
	  char *	ptmp;
	  int		len = strlen( arg );


	  /*
	   * catch the library named [<path>]lib<name>.a
	   */
	  
	  if ((ptmp = strrchr( arg, '/' )) == NULL)
	    ptmp = arg;
	  else
	    ++ptmp;

	  if (strncmp( ptmp, "lib", 3 )           == 0 &&
	      strncmp( arg + (len - 2), ".a", 2 ) == 0)
	    {

	      /*
	       * Beware of this horrible hack.
	       *
	       * In CountSources() scanned libraries are counted
	       * as being source files if they do not start with
	       * a -l.  The only candidates for such files are
	       * caught here, but I must prepend the -l option or
	       * otherwise the linker will not know about the
	       * file being a scanned library.  Hence the space
	       * before the -l in the string below.
	       */
	      
	      AddLibraryName( false, " -l%s", arg );
	    }
	  else
	    {
	      AddFile( &SourceFiles, arg );
	    }
	}
    }

  if (_is_norcroft_compiler)
    {
      /* Norcroft compilers try to link automatically ... */

      if (ASSEMBLE_ONLY)
	AddName( &CompileOpts, "-S" );
      else
	AddName( &CompileOpts, "-c" );
    }

  /* catch _BSD being defined and add BSD library to library list, if necessary */
  
    {
      NameNode *	pName;
      

      for (pName  = (NameNode *)FirstNode( (List *) &Defines );
	   pName != NULL;
	   pName  = (NameNode *)NextNode( (Node *)pName ))
	{
	  if (streq( pName->name, "_BSD" ))
	    (void) AddLibrary( c_libdir, "bsd" );
	}
    }

  /* Cope with C_COMPILER environment variables which have parameters included */

  if ((cc = strchr( c_compiler, ' ' )) != NULL)
    {
      char *	copy = (char *) malloc( strlen( c_compiler ) + 1 );

      
      if (copy == NULL) fail( "out of memory copying string" );
      
      strcpy( copy, c_compiler );
      
      cc = strchr( copy, ' ' );

      *cc = '\0';

      c_compiler = copy;

      do
	{
	  while (*cc++ == ' ')
	    ;		     			/* point to start of next word */

	  if (*cc == '\0') break;		/* catch end of string */
	  
	  copy = strchr( cc, ' ' );		/* point to end of next word */

	  if (copy != NULL) *copy = '\0';	/* isolate next word */
	  
	  AddName( &CompileOpts, cc );		/* install next word */

	  cc = copy;				/* advance pointer */
	}
      while (cc != NULL);
    }
  
  /* O/S identification */
  
  AddName( &Defines, "helios" );	/* this is archaic and should be allowed to die out */
  AddName( &Defines, "__HELIOS" );
  
  /* Processor identification */

  AddName( &Defines, machinename );

  /* Compiler and Host identification */

  AddName( &MacroOpts, "-d__HELIOS" );
  AddName( &MacroOpts, "1" );
  
  switch (compiler)
    {
    default:
    case TRANSPUTER_COMPILER:
      AddName( &Defines, "transputer" );
      AddName( &Defines, "__TRAN" );
      AddName( &Defines, "__HELIOSTRAN" );
      AddName( &MacroOpts, "-dhelios.TRAN" );
      AddName( &MacroOpts, "1" );
      AddName( &MacroOpts, "-d__TRAN" );
      AddName( &MacroOpts, "1" );      
      AddName( &MacroOpts, "-d__HELIOSTRAN" );
      AddName( &MacroOpts, "1" );      
      break;

    case ARM_COMPILER:
      AddName( &Defines, "__ARM" );
      AddName( &Defines, "__HELIOSARM" );
      AddName( &Defines, "__SMT" );		/* split module table */
      AddName( &MacroOpts, "-dhelios.arm" );
      AddName( &MacroOpts, "1" );
      AddName( &MacroOpts, "-d__ARM" );
      AddName( &MacroOpts, "1" );      
      AddName( &MacroOpts, "-d__HELIOSARM" );
      AddName( &MacroOpts, "1" );      
      AddName( &MacroOpts, "-d__SMT" );
      AddName( &MacroOpts, "1" );      
      break;

    case C40_COMPILER:
      AddName( &Defines, "__C40" );
      AddName( &Defines, "__HELIOSC40" );
      AddName( &Defines, "__SMT" );
      AddName( &MacroOpts, "-dhelios.C40" );
      AddName( &MacroOpts, "1" );
      AddName( &MacroOpts, "-d__C40" );
      AddName( &MacroOpts, "1" );      
      AddName( &MacroOpts, "-d__HELIOSC40" );
      AddName( &MacroOpts, "1" );      
      AddName( &MacroOpts, "-d__SMT" );
      AddName( &MacroOpts, "1" );      
      break;
      
    case I860_COMPILER:
      AddName( &Defines, "__I860" );
      AddName( &Defines, "__HELIOSI860" );
      AddName( &MacroOpts, "-dhelios.I860" );
      AddName( &MacroOpts, "1" );
      AddName( &MacroOpts, "-d__I860" );
      AddName( &MacroOpts, "1" );      
      AddName( &MacroOpts, "-d__HELIOSI860" );
      AddName( &MacroOpts, "1" );      
      break;
      
    case M68K_COMPILER:
      AddName( &Defines, "__M68K" );
      AddName( &Defines, "__HELIOSM68K" );
      AddName( &MacroOpts, "-dhelios.M68K" );
      AddName( &MacroOpts, "1" );
      AddName( &MacroOpts, "-d__M68K" );
      AddName( &MacroOpts, "1" );      
      AddName( &MacroOpts, "-d__HELIOSM68K" );
      AddName( &MacroOpts, "1" );      
      break;      
    }
  
#ifndef UNIX
  AddInclude( "/include" );
#endif
  AddInclude( c_incdir );
  AddSymbol ( symdir );
  
  CountSources();

  if (NSources == 0)
    {
      fail( "nothing to compile" );
    }
  else if (NSources == 1 || NCfiles == 1)
    {
      if (use_non_standard_features && streq( ObjectName, OBJNAME ))
	{
	  char * 	path;


	  /* use the source file name as the output name */
	  
	  ObjName = ((FileNode *)FirstNode( &SourceFiles ))->base;

	  /* but only the file name, not the path */
	     
	  if ((path = strrchr( ObjName, '/' )) != NULL)
	    {
	      ObjName = path + 1;
	    }

	  ObjectName = ObjName;
	}
    }
  else if (NSources > 1 && !LINK && REDIRECT )
    {
      fail( "Invalid -o option: multiple output files" );
    }

  if (use_non_standard_features &&
      (_is_transputer_compiler			/* other compilers seek back to the start of their output */
       && !JOIN					/* do not use pipes if joining together library files */
       && !APPEND				/* or concatentating library files */
       && NSources == 1				/* more than one source file means temp files must be used */
       && (NCfiles > 0 || NAfiles > 0)		/* do not use pipes when just assembling */
       ))
    {
      Flags |= FLAG_P;
    }
  
  AddWarningsAndFeatures();
  AddDefines();
  AddIncludeOpts();
  AddSymbolOpts();
  
  if (OPTIMISE)
    {
      if (_is_transputer_compiler)
	{
	  AddName( &AssembleOpts, "-f" ); /* full link */
	  AddName( &LinkOpts,     "-f" );
	}      
    }
  
  if (VERBOSE)
    {
      AddName( &AssembleOpts, "-v" );
      AddName( &ModulaOpts,   "-v" );
      AddName( &LinkOpts,     "-v" );
    }
  
  if (STDLIBS)
    {
      /* add standard libraries */
      
      if (!AddLibrary( c_libdir, link_helios ) && !COMPILE_ONLY)
	{
	  warning( "Could not find standard Helios library '%s%s'!", c_libdir, link_helios );
	}
    }
  
#ifdef __ARM
  if  (ASSEMBLE_ONLY)
    {
      AddName( &CompileOpts, "-S" );
    }
  else
    {
      AddName( &CompileOpts, "-c" );
    }
  
  /* following line is a fudge! */

  AddName( &CompileOpts, "-WANPVDF" );
  
#endif /* __ARM */
  
  succeeded = DoCompiles();

  if (succeeded && ASSEMBLE)
    {
      /* > 0 because if NSfiles > 0 we must assemble */
      
      if (!LINK || NCfiles + NFfiles + NSfiles + NAfiles + NMfiles > 0)
	succeeded |= DoAssembles();
      
      /* attempt to link only if not all Modula-2 .def files given */
      
      if (NSources != NDfiles && LINK && succeeded)
	{
	  succeeded = DoLink();
	}
    }
  
  if (succeeded && USE_PIPE)
    {
      succeeded = (ExecuteCommandLine() == 0);
    }

  return (succeeded ? EXIT_SUCCESS : EXIT_FAILURE);
  
} /* main */

/*}}}*/

/*}}}*/

/* end of c.c */
@


1.136
log
@added code to support a C_COMPILER environment variable which includes command line options
@
text
@d13 2
a14 2
 * RCS version: $Revision: 1.135 $
 * RCS date:    $Date: 1994/03/22 14:29:46 $
d3919 1
a3919 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.135 $)", VERSION, REVISION );
d5440 1
a5440 1
      if (!AddLibrary( c_libdir, link_helios ))
@


1.135
log
@fixed passing -O to ARM assembler instead of -o
@
text
@d13 2
a14 2
 * RCS version: $Revision: 1.134 $
 * RCS date:    $Date: 1994/03/08 11:02:29 $
d3919 1
a3919 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.134 $)", VERSION, REVISION );
d5249 35
@


1.134
log
@fixed compile time warnings for ARM world
@
text
@d13 2
a14 2
 * RCS version: $Revision: 1.133 $
 * RCS date:    $Date: 1994/03/03 12:10:36 $
a2617 3
#ifdef __ARM
	  AddName( plist, "-O"    );
#else
a2618 1
#endif
d3919 1
a3919 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.133 $)", VERSION, REVISION );
@


1.133
log
@now copes with c_libdir not ending in /, and warns if -x option is not first in list
@
text
@d13 2
a14 2
 * RCS version: $Revision: 1.132 $
 * RCS date:    $Date: 1994/03/01 14:10:17 $
a1702 55
/*{{{  ExecuteCmdList */

#ifdef __ARM
static int
# ifdef __STDC__
ExecuteCmdList( NameList * nlist )
# else
ExecuteCmdList( nlist )
  NameList * nlist;
# endif
/*
 * execute the indicate command with the provided arguments
 * wait for the command to terminate and return its exit code
 */
{
  int		i;
  int		result 	= -1;
  NameNode *	pnode;

  
  command_line[ 0 ]  = '\0';
  command_line2[ 0 ] = '\0';
    
  i = 0;
    
  for (pnode = (NameNode *)FirstNode( (List *)nlist );
       pnode;
       pnode = (NameNode *)NextNode( (Node *)pnode ) )
    {
      strcat( command_line, pnode->name );
      strcat( command_line, " " );
	    
      if (VERIFY)
	printf( "%s ", pnode->name );
    }
    
  if (!USE_PIPE && VERIFY)
    {
      printf( "\n" );
    }
    
  result = ExecuteCommandLine();
    
  if (result != 0)
    {
      warning( "Failed because %s exited with return code of %d", command_line, result );
    }
    
  return result;
    
} /* ExecuteCmdList */

#endif /* __ARM */

/*}}}*/
d2274 1
d2398 1
d2401 1
a2401 1
/*{{{  M2_Compile */
d2403 2
d2434 2
d2439 2
d2514 2
d3923 1
a3923 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.132 $)", VERSION, REVISION );
@


1.132
log
@updated previous delta
@
text
@d13 2
a14 2
 * RCS version: $Revision: 1.131 $
 * RCS date:    $Date: 1994/03/01 13:37:28 $
d1428 2
a1429 1
  bool		resident = false;
d1435 2
a1436 2
      
      sprintf( buf, "%s%s", dir, stem );
d1455 1
a1455 1
      sprintf( buf, "%s%slib.def", dir, stem );
d1460 1
a1460 1
      sprintf( buf, "%s%s.def", dir, stem );
d1465 1
a1465 1
      sprintf( buf, "%s%slib", dir, stem );
d1470 1
a1470 1
      sprintf( buf, "%s%s.lib", dir, stem );
d1475 1
a1475 1
      sprintf( buf, "%s%s", dir, stem );
d1480 1
a1480 1
      sprintf( buf, "%slib%s.a", dir, stem );
d1493 10
a1502 2
	      AddLibraryName( true, "%sfplib.def",  c_libdir );
	      AddLibraryName( true, "%sfpclib.def", c_libdir );
d3631 1
a3631 1
  
d3697 1
a3697 1
  
d3716 1
a3716 3
      /*
       * add trailing / if none present and name is not blank
       */
d3722 2
a3723 4
      
      /*
       * check for and ignore duplicates, for faster compilation
       */
d3968 1
a3968 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.131 $)", VERSION, REVISION );
d5131 4
@


1.131
log
@fixed -E option
@
text
@d13 2
a14 2
 * RCS version: $Revision: 1.130 $
 * RCS date:    $Date: 1994/02/24 13:17:12 $
d2278 1
a2279 1
    
d2284 2
d2289 1
a2289 2
  
  if (!strend( pre_processor, "cpp" ))
a2290 1
  
d2295 9
a2303 1
  AddNamef( plist, "%s.i",  fnode->root   );
d3963 1
a3963 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.130 $)", VERSION, REVISION );
@


1.130
log
@Fixed K&R compilation
@
text
@d13 2
a14 2
 * RCS version: $Revision: 1.129 $
 * RCS date:    $Date: 1994/02/18 09:30:58 $
d272 1
a272 1
#define PRE_PROCESSOR		"/helios/bin/ncc -E"
d524 1
d2285 2
d2288 3
a2290 1
  AddNamef( plist, "%s",    pre_processor );
d3955 1
a3955 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.129 $)", VERSION, REVISION );
@


1.129
log
@added code to initialise nodes before list operations
@
text
@d13 2
a14 2
 * RCS version: $Revision: 1.128 $
 * RCS date:    $Date: 1993/10/05 14:09:31 $
d320 1
a320 1
 #define F77_PASS1		"/helios/bin/f77p1"
d324 1
a324 1
 #define F77_PASS2		"/helios/bin/f77p2"
d328 1
a328 1
 #define M2_COMPILER		"/helios/bin/mc"
d336 1
a336 1
 #define C40_ASSEMBLER		"/helios/bin/as"
d340 1
a340 1
 #define M68K_ASSEMBLER		"/helios/bin/as"
d348 15
a362 15
 #ifdef __TRAN
  #define ASSEMBLER		TRANSPUTER_ASSEMBLER
 #else
  #ifdef __C40
   #define ASSEMBLER		C40_ASSEMBLER
  #else
   #ifdef __ARM
    #define ASSEMBLER		ARM_ASSEMBLER
   #else
    #ifdef __M68K
     #define ASSEMBLER		M68K_ASSEMBLER
    #endif
   #endif
  #endif
 #endif
d366 1
a366 1
 #define TRANSPUTER_LINKER	"/helios/bin/asm"
d370 1
a370 1
 #define C40_LINKER		"/helios/bin/ld"
d374 1
a374 1
 #define M68K_LINKER		"/helios/bin/ld"
d378 1
a378 1
 #define ARM_LINKER		"/helios/bin/ld"
d382 1
a382 1
 #define I860_LINKER		"/helios/bin/ld"
d386 15
a400 15
 #ifdef __TRAN
  #define LINKER			TRANSPUTER_LINKER
 #else
  #ifdef __C40
   #define LINKER			C40_LINKER
  #else
   #ifdef __ARM
    #define LINKER			ARM_LINKER
   #else
    #ifdef __M68K
     #define LINKER			M68K_LINKER
    #endif
   #endif
  #endif
 #endif
d404 1
a404 1
 #define MACRO			"/helios/bin/ampp"
d408 1
a408 1
 #define C40_C_LIBDIR		"/helios/lib/"
d412 1
a412 1
 #define M68K_C_LIBDIR		"/helios/lib/"
d416 1
a416 1
 #define ARM_C_LIBDIR		"/helios/lib/"
d420 1
a420 1
 #define TRANSPUTER_C_LIBDIR	"/helios/lib/"
d424 15
a438 15
 #ifdef __TRAN
  #define C_LIBDIR		TRANSPUTER_C_LIBDIR
 #else
  #ifdef __C40
   #define C_LIBDIR		C40_C_LIBDIR
  #else
   #ifdef __ARM
    #define C_LIBDIR		ARM_C_LIBDIR
   #else
    #ifdef __M68K
     #define C_LIBDIR		M68K_C_LIBDIR
    #endif
   #endif
  #endif
 #endif
d442 1
a442 1
 #define C_INCDIR		"/helios/include/"
d446 1
a446 1
 #define MACDIR			"/helios/include/ampp/"
d450 1
a450 1
 #define SYMDIR			"/helios/symbols/"
d482 19
a500 19
 #ifdef __ARM
  #define MACHINENAME		ARM_MACHINENAME
 #else
  #ifdef __I860
   #define MACHINENAME		I860_MACHINENAME
  #else
   #ifdef __C40
    #define MACHINENAME		C40_MACHINENAME
   #else
    #ifdef __M68K
     #define MACHINENAME	M68K_MACHINENAME
    #else
     #ifdef __TRAN
      #define MACHINENAME	TRANSPUTER_MACHINENAME
     #endif
    #endif
   #endif
  #endif
 #endif
d504 1
a504 1
#  define MACHINENAME		"Unknown_CPU_type"
d3950 1
a3950 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.128 $)", VERSION, REVISION );
d3952 1
d3955 1
a3955 1
*.i\t\tPre-processed C source file.\n"
@


1.128
log
@fixed changing library path using command line switches
@
text
@d1 2
d10 1
a10 1
 * This code is Copyright (c) 1990, 1991, 1992, 1993 Perihelion Software Ltd.
d13 2
a14 2
 * RCS version: $Revision: 1.127 $
 * RCS date:    $Date: 1993/09/15 16:16:59 $
d21 1
d935 23
d1060 1
d1079 2
d1082 1
a1082 1
  AddTail( (List *)plist, (Node *)pnew );
d1131 1
d1157 2
d1160 1
a1160 1
  AddHead( (List *)plist, (Node *)pnew );
d1207 1
d1320 2
d1323 1
a1323 1
  AddTail( (List *)plist, (Node *)New );
d1366 1
d3950 1
a3950 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.127 $)", VERSION, REVISION );
d5482 2
@


1.127
log
@fixed -p option to be for transputers only
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.126 $
 * RCS date:    $Date: 1993/08/10 15:48:32 $
d16 2
a17 2
#define REVISION	63
#define DATE		10/08/93
d145 2
d1061 1
d1393 1
a1393 1
  
d3622 69
d3914 1
a3914 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.126 $)", VERSION, REVISION );
d4312 1
a4312 1
  
d4358 2
d4366 2
a4390 3
	      
		  if (streq( argv[ i ], "_BSD" ))
		    (void) AddLibrary( c_libdir, "bsd" );
a4394 3
	      
		  if (streq( &arg[ 2 ], "_BSD" ))
		    (void) AddLibrary( c_libdir, "bsd" );
d4472 2
d4479 3
a4481 1
		  machinename = M68K_MACHINENAME;		  
d4733 2
d4741 2
d5029 2
d5037 2
d5076 2
d5118 1
a5118 1
		      fail( "No processor type following -x option" );
d5120 2
d5215 1
a5215 1
  
d5225 16
a5240 1
		
d5243 1
a5243 1
  AddName( &Defines, "helios" );		/* this is archaic and should be allowed to die out */
d5413 2
a5414 2
  AddName( &CompileOpts, "-WANPVDF" );  

@


1.126
log
@added support for M68K (and added folding)
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.125 $
 * RCS date:    $Date: 1993/08/08 17:11:59 $
d464 2
a465 2
#ifndef TRAN_MACHINENAME
#define TRAN_MACHINENAME	"TRANSPUTER"
d490 1
a490 1
      #define MACHINENAME	TRAN_MACHINENAME
a768 1
  
a898 2
  

a1028 1
  
a1811 1
  
a3665 2
  

a3706 2

/*}}}*/
d3842 1
a3842 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.125 $)", VERSION, REVISION );
d3874 1
a3874 1
-p\t\tCompile code for profiling.\n\
d3902 1
a3902 1
-x<proctype>\tCompile code for <proctype> (arm/c40/m68k).\n\
d4168 1
a4168 1
	    machinename = TRAN_MACHINENAME;
d4176 1
a4176 1
	    machinename = TRAN_MACHINENAME;
d4864 6
a4869 1
		AddName( &CompileOpts, "-p" );
d4954 1
a4954 1
		  machinename = TRAN_MACHINENAME;
d5020 11
@


1.125
log
@updated for ARM tool selection from command line
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.124 $
 * RCS date:    $Date: 1993/08/04 15:30:48 $
d16 2
a17 2
#define REVISION	62
#define DATE		03/08/93
d19 2
a21 2
 * Revision log:-
 *
d143 2
d147 2
a148 14
#ifdef UNIX
#  define const
#endif

#ifdef R140
#  define SEEK_END 2
#  define L_tmpnam 25
typedef	int	pid_t;
extern int	errno;
#endif /* R140 */

#ifdef RS6000
#define vfork	fork
#endif
d226 17
a242 3
/*
 * constants
 */
d284 4
d297 15
a311 5
#ifdef __TRAN
#define C_COMPILER		TRANSPUTER_CC
#else
#define C_COMPILER		C40_CC
#endif
d315 1
a315 1
#define F77_PASS1		"/helios/bin/f77p1"
d319 1
a319 1
#define F77_PASS2		"/helios/bin/f77p2"
d323 1
a323 1
#define M2_COMPILER		"/helios/bin/mc"
d327 1
a327 1
#define TRANSPUTER_ASSEMBLER	"/helios/bin/asm"
d331 1
a331 1
#define C40_ASSEMBLER		"/helios/bin/as"
d334 4
d339 1
a339 1
#define ARM_ASSEMBLER		"/helios/bin/as"
d343 15
a357 4
#ifdef __TRAN
#define ASSEMBLER		TRANSPUTER_ASSEMBLER
#else
#define ASSEMBLER		C40_ASSEMBLER
a358 1
#endif
d361 1
a361 1
#define TRANSPUTER_LINKER	"/helios/bin/asm"
d365 5
a369 1
#define C40_LINKER		"/helios/bin/ld"
d373 1
a373 1
#define ARM_LINKER		"/helios/bin/ld"
d377 1
a377 1
#define I860_LINKER		"/helios/bin/ld"
d381 15
a395 5
#ifdef __TRAN
#define LINKER			TRANSPUTER_LINKER
#else
#define LINKER			C40_LINKER
#endif
d399 1
a399 1
#define MACRO			"/helios/bin/ampp"
d403 5
a407 1
#define C40_C_LIBDIR		"/helios/lib/"
d411 1
a411 1
#define ARM_C_LIBDIR		"/helios/lib/"
d415 1
a415 1
#define TRANSPUTER_C_LIBDIR	"/helios/lib/"
d419 15
a433 5
#ifdef __TRAN
#define C_LIBDIR		TRANSPUTER_C_LIBDIR
#else
#define C_LIBDIR		C40_C_LIBDIR
#endif
d437 1
a437 1
#define C_INCDIR		"/helios/include/"
d441 1
a441 1
#define MACDIR			"/helios/include/ampp/"
d445 1
a445 1
#define SYMDIR			"/helios/symbols/"
d456 10
a465 2
#ifdef __ARM
#  define MACHINENAME		"ARM"
d467 3
a469 2
#ifdef __I860
#  define MACHINENAME		"i860"
d471 3
a473 2
#if defined __TRAN || defined SUN4
#  define MACHINENAME	      	"TRANSPUTER"
d475 21
a495 2
#ifdef __C40
#  define MACHINENAME		"TMS320C40"
d497 1
d502 4
d507 5
a511 1
#define _is_norcroft_compiler	(compiler == ARM_COMPILER || compiler == C40_COMPILER || compiler == I860_COMPILER)
d514 5
d520 2
a521 3
/*
 * types
 */
d547 1
a547 1
    }
d559 1
d561 1
a561 1
    }
d564 2
a565 3
/*
 * global variables
 */
a635 1

d708 2
a709 15
/*
 * macros
 */

#define NEW( _type )	(_type *)SafeAlloc( sizeof( _type ) )


#define ARGBUFSIZE	1024

#define streq(  s1, s2 )	(strcmp(  s1, s2      ) == 0)
#define strneq( s1, s2, len )	(strncmp( s1, s2, len ) == 0)

/*
 * prototypes
 */
d717 2
d720 1
a720 3
/*
 * System-type utility routines
 */
d724 2
d771 3
d811 3
d855 3
d901 4
d928 6
a933 228
  
static void
usage(
#ifdef __STDC__
      void
#endif
      )
  /*
   * describe the options to this utility
   */
{
  int	err = dup( 2 );
  int	pid;
  int	pfds[ 2 ];
  
  
  pipe( pfds );
  
  pid = vfork();
  
  if (pid == 0)
    {
      dup2( pfds[ 0 ], 0 );
      
      close( pfds[ 0 ] );
      close( pfds[ 1 ] );
      
      execlp( "more", "more", 0 );
      
      pid = -1;
      
      _exit( 0 );
    }
  
  if (pid == -1)
    close( err );
  
  else dup2( pfds[ 1 ], 2 );
  
  close( pfds[ 0 ] );
  close( pfds[ 1 ] );
  
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.124 $)", VERSION, REVISION );
  error( "Usage: %s [options] files", ProgName );
{ static char *strings[] = {
"*.c\t\tC source file.\n\
*.i\t\tPre-processed C source file.\n"
#ifndef __ARM
"*.f\t\tFORTRAN source file.",
#endif
"*.s\t\tAssembler source file.\n\
*.a\t\tMacro Assembler source file.",
#ifndef __ARM
"*.def\t\tModula-2 definition source file.\n\
*.mod\t\tModula-2 program source file.",
#endif
"*.o\t\tAssembled file - ready for linking.\n\
-a<text>\tPass <text> as an option to assembler.\n\
-b\t\tDon't link with standard library (helios.lib).\n\
-c\t\tCompile/Assemble only, don't link.\n\
-c40\t\tCompile code for a C40.\n\
-d<name>\tSpecify output file name for library .def compilations.",
#ifndef __ARM
"-e[6|7]\t\tEnforce FORTRAN standard.",
#endif
"-f <name>\tSpecify file name for the assembler's virtual memory system.\n\
-g\t\tCompile for debugging.\n\
-h<val>\t\tSpecify heap size of program.\n\
-j\t\tCreate scanned library.\n\
-l<name>\tLink with standard library <name>\n\
-m\t\tCompile code for shared libraries.\n\
-n\t\tDon't actually execute commands (implies -v).",
"-n<string>\tSpecify object name of program.\n\
-o <name>\tSpecify output name (default *.o or \"a.out\") (\"-\" is stdout)\n\
-p\t\tCompile code for profiling.\n\
-q<fgilpz>\tEnable internal compiler debugging features:\n\
\t\t 'f' Function names.\n\
\t\t 'g' Code generation.\n\
\t\t 'i' Include files.\n\
\t\t 'l' Lexical analysis.\n\
\t\t 'p' Pre-processor.\n\
\t\t 'z' Fatal error handling.\n\
-r\t\tCompile code for device drivers.",
"-s<val>\t\tSpecify stack size of program.\n\
-t\t\tCompile code for (back) tracing.\n\
-tran\t\tCompile code for Transputers.\n\
-u\t\tPrevents removal of intermediary files.\n\
-v\t\tDisplay command(s) being executed.\n\
-w[Aacdfpsvz]\tSuppress warnings and error messages from the C compiler when:",
"\t\t 'a' '=' occurs in a condition context,\n\
\t\t 'c' ANSI disallowed casts are used,\n\
\t\t 'd' (some)deprecated features are used,\n\
\t\t 'f' functions are implicity declared as 'extern int()',\n\
\t\t 'i' pointers are explicitly cast to integers,\n\
\t\t 'n' implicit casting between types,\n\
\t\t 'o' old K&R style function headers are used,",
"\t\t 'p' junk occurs after #else and #endif,\n\
\t\t 's' shorts are used for the first time, (Transputer)\n\
\t\t 'u' unused variables,\n\
\t\t 'v' void functions are written without 'void',\n\
\t\t 'z' zero sized arrays occur,\n\
\t\t 'A' all of the above.\n\
-x<proctype>\tCompile code for <proctype> (arm/c40).\n\
-y<text>\tPass <text> as an option to the Macro Assembler.",
"-z<text>\tPass <text> as an option to the C compiler.\n\
-A<text>\tPass <text> as an option to the linker.\n\
-B\t\tDo not link with any libraries.  Do not perform objed.\n\
-C\t\tPerform array bound (F77,M2) or memory access checking (C)\n\
-C40\t\tCompile code for C40s.\n\
-D <name>\t#define <name>",
"-D <name>=<val> #define <name> to be <val> (default <val> is \"1\").\n\
-E\t\tPre-process only - do not compile\n\
-F[Afghmnpsuv]  Enable C  compiler features:\n\
\t\t 'b' enables back trace support (C40)\n\
\t\t 'd' disables new stub generation (C40)\n\
\t\t 'f' disables the vector stack (Transputer)\n\
\t\t 'g' removes procedure names from the code\n\
\t\t 'h' warns of discrepencies in function declarations\n\
\t\t 'l' small model (C40)",
"\t\t 'm' warns of unused macros\n\
\t\t 'n' do not put arrays or structs on vector stack (Transputer)\n\
\t\t 'p' disables peepholing by the code generator (C40)\n\
\t\t 's' turns off stack checking\n\
\t\t 'u' warns of unused functions and variables during linking\n\
\t\t 'v' warns of unused global functions and variables in a file\n\
\t\t 'A' turns on selected useful features\n\
-I<dir>\t\tSpecify a directory to be searched for #include or Modula-2\n\
\t\tsymbol files.\n\
-J\t\tAppend to scanned library.",
#ifndef __ARM
"-K<text>\tPass <text> as an option to Modula-2 compiler.",
#endif
"-L<dir>\t\tSpecifies directories to be searched for libraries.",
#ifndef __ARM
"-M<name>\tProduce map file <name> (F77).",
#endif
"-O\t\tOptimise code, perform full link.\n\
-P<text>\tPass <text> as an option to the pre-processor.",
#ifndef __ARM
"-R\t\tForce use of RAM disk for temporary FORTRAN and Modula-2 files,\n\
\t\teven if RAM disk is not loaded",
#endif
"-S\t\tProduce textual assembler output from *.c in *.s, don't link.",
#ifndef __ARM
"-T[4|5|8|9]\tSpecify Transputer type.(5 => T425)",
#endif
"-V\t\tPass on verbose flag to executed commands.\n\
-U <name>\tRemoves any initial definition of <name>.",
#ifndef __ARM
"-W<val>\t\tSpecify warning level (F77).",
#endif
"-Wc,arg[,args]  Pass on arguments to specific parts of the compilation.\n\
\t\twhere c is one of :-\n\
\t\t 'p' C pre-processor (cf -P),\n\
\t\t '0' C compiler (cf -z),\n\
\t\t '2' C compiler (optimising section),\n\
\t\t 'a' assembler (cf -a),\n\
\t\t 'l' linker (cf -A),\n\
\t\t 'M' Macro Assembler (cf -y),",
#ifndef __ARM
"\t\t 'm' Modula-2 compiler (cf -M).\n\
-X<val>\t\tSpecify cross reference width (F77).\n\
-Z<text>\tPass <text> as an option to FORTRAN compiler.",
#endif
"-help\t\tThis message.",
"",
"The driver uses the following environment variables if present:-\n\
SHELL\t\tPathname of the command line interpreter.\n\
C_COMPILER\tPathname of the C compiler.\n\
PRE_PROCESSOR\tPathname of the C pre-processor.",
#ifndef __ARM
"F77_PASS1\tPathname of the first  pass of the FORTRAN compiler.\n\
F77_PASS2\tPathname of the second pass of the FORTRAN compiler.\n\
M2_COMPILER\tPathname of the Modula-2 compiler.",
#endif
"ASSEMBLER\tPathname of the assembler.\n\
LINKER\t\tPathname of the linker.\n\
REMOVER\t\tPathname of the file removal program.\n\
MACRO\t\tPathname of the assembler macro pre-processor.\n\
MACDIR\t\tPathname of the standard AMPP macro directory.\n\
C_LIBDIR\tPathname of the library directory.\n\
C_INCDIR\tPathname of the standard C header directory.",
#ifndef __ARM
"TMPDIR\t\tPathname of the directory for holding temporary FORTRAN files",
#endif
"LINK_HELIOS\tName\t of the standard Helios link library.\n\
LINK_CSTART\tName\t of the standard C startup file.\n\
LINK_CLIB\tName\t of the standard C link library.",
#ifndef __ARM
"LINK_FSTART\tName\t of the standard FORTRAN startup file.\n\
LINK_M2START\tName\t of the standard Modula-2 startup file.",
#endif
"MACHINENAME\tName\t of the destination hardware, passed on by -D.\n\
OBJNAME\t\tDefault name of output file.\n\
C_NONSTANDARD\tEnables non-standard features.\n\
\t\t (uses pipes to connect processes and\n\
\t\t does not use 'a.out' unless really necessary)",
"NEW_NCC\t\tDescribes the type of Norcroft C compiler being used, could be:\n\
\t\t ARM\t  For the Helios ARM C compiler\n\
\t\t C40\t  For the Helios TMS320C40 C compiler\n\
\t\t I860\t  For the Helios i860 C compiler\n\
\t\t TRAN\t  For the new Helios Transputer C compiler\n\
\t\t OLD_TRAN For the old Helios Transputer C compiler (default)",
NULL
};
  int i;
  for (i = 0; strings[i] != NULL; i++)
	error(strings[i]);
}
  
  if (pid >= 0) 
    {
      int 	stat;
      int 	p;
      
      
      close( 2 );
      
      p = wait( &stat );
      
      dup2( err, 2 );
      
      close( err );
    }
  
  return;
  
} /* usage */
a934 5
  
/*
 * List Routines
 */
  
d957 3
a959 1
  
d983 3
d1009 3
d1033 3
d1061 2
d1101 2
d1135 3
a1137 1
  
d1174 2
d1241 3
a1243 1
  
d1297 3
a1299 1
  
d1330 2
d1363 3
a1365 1
  
d1495 2
d1544 5
a1548 1
  
d1553 2
d1657 2
d1712 2
a1713 1

d1789 2
d1818 3
d2053 2
a2054 5

/*
 * Action routines
 */

d2089 2
d2225 2
d2270 2
d2397 2
d2429 2
d2505 2
d2563 2
d2674 2
d2724 1
a2724 2
	  if (compiler != ARM_COMPILER &&	/* these compiler produce object */
	      compiler != C40_COMPILER &&	/* code output, not assembler    */
d2742 1
a2742 2
	  if (compiler != TRANSPUTER_COMPILER &&
	      compiler != UNKNOWN_COMPILER)
d2787 2
d2828 2
d3083 1
d3085 2
a3086 3
/*
 * utility routines for parsing command line and building arguments
 */
d3088 1
d3186 2
d3213 1
d3231 1
a3231 1
	  if (compiler == TRANSPUTER_COMPILER || compiler == UNKNOWN_COMPILER)
d3281 2
d3404 2
d3426 2
d3491 2
d3556 2
d3623 2
d3672 4
d3711 8
d3807 237
d4118 4
d4143 1
a4143 1
	    machinename = "TMS320C40";
d4152 1
a4152 1
	    machinename = "ARM";
d4161 10
a4170 1
	    machinename = "i860";
d4177 1
a4177 1
	    machinename = "TRANSPUTER";
d4185 1
a4185 1
	    machinename = "TRANSPUTER";
d4300 1
a4300 1
		  machinename = "TMS320C40";
d4409 13
a4421 2
	      if (arg[ 2 ] != '\0')
		FortranMapFile = &arg[ 2 ];
d4673 1
a4673 1
		  machinename = "TMS320C40";
d4958 1
a4958 1
		  machinename = "TRANSPUTER";
d5005 1
a5005 1
		  machinename = "ARM";
d5014 10
a5023 1
		  machinename = "TMS320C40";
d5200 11
d5334 4
@


1.124
log
@Cleaned up the -help text to reduce its size, saving code and data space
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.123 $
 * RCS date:    $Date: 1993/07/12 12:48:04 $
d316 4
d360 4
d867 1
a867 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.123 $)", VERSION, REVISION );
d927 1
d4056 1
a4056 1
		{
d4065 1
a4065 1
		  
a4067 1
	      
d4686 1
a4686 1

a4688 4
		  break;
		  
		case C40_COMPILER:
		  AddName( &CompileOpts, "-Zr" );  
d4767 4
d4772 25
a4796 3
	    case 'w': /* warning flags */
	      if (arg[ 2 ] != '\0')
		ParseWarnings( &arg[ 2 ] );
d4798 1
a4798 1
	      
a4841 1
	    case 'x': /* unused */
@


1.123
log
@fixed compile time warnings
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.122 $
 * RCS date:    $Date: 1993/07/05 12:54:58 $
d16 2
a17 2
#define REVISION	61
#define DATE		10/06/93
d141 2
d859 1
a859 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.122 $)", VERSION, REVISION );
d861 3
a863 2
  error( "*.c             C source file." );
  error( "*.i             Pre-processed C source file." );
d865 1
a865 1
  error( "*.f             FORTRAN source file.");
d867 2
a868 2
  error( "*.s             Assembler source file." );
  error( "*.a             Macro Assembler source file." );
d870 2
a871 2
  error( "*.def           Modula-2 definition source file." );
  error( "*.mod           Modula-2 program source file." );
d873 6
a878 6
  error( "*.o             Assembled file - ready for linking." );
  error( "-a<text>        Pass <text> as an option to assembler." );
  error( "-b              Don't link with standard library (helios.lib)." );
  error( "-c              Compile/Assemble only, don't link." );
  error( "-c40            Compile code for a C40." );
  error( "-d<name>        Specify output file name for library .def compilations." );
d880 1
a880 1
  error( "-e[6|7]         Enforce FORTRAN standard.");
d882 63
a944 63
  error( "-f <name>       Specify file name for the assembler's virtual memory system." );
  error( "-g              Compile for debugging." );
  error( "-h<val>         Specify heap size of program." );
  error( "-j              Create scanned library." );
  error( "-l<name>        Link with standard library <name>" );
  error( "-m              Compile code for shared libraries." );
  error( "-n              Don't actually execute commands (implies -v)." );
  error( "-n<string>      Specify object name of program." );
  error( "-o <name>       Specify output name (default *.o or \"a.out\") (\"-\" is stdout)" );
  error( "-p              Compile code for profiling.");
  error( "-q<fgilpz>      Enable internal compiler debugging features:" );
  error( "                  'f' Function names." );
  error( "                  'g' Code generation." );
  error( "                  'i' Include files." );
  error( "                  'l' Lexical analysis." );
  error( "                  'p' Pre-processor." );
  error( "                  'z' Fatal error handling." );
  error( "-r              Compile code for device drivers." );
  error( "-s<val>         Specify stack size of program." );
  error( "-t              Compile code for (back) tracing.");
  error( "-tran           Compile code for Transputers.");
  error( "-u              Prevents removal of intermediary files.");
  error( "-v              Display command(s) being executed." );
  error( "-w[Aacdfpsvz]   Suppress warnings and error messages from the C compiler when:" );
  error( "                  'a' '=' occurs in a condition context," );
  error( "                  'c' ANSI disallowed casts are used," );
  error( "                  'd' (some)deprecated features are used," );
  error( "                  'f' functions are implicity declared as 'extern int()'," );
  error( "                  'i' pointers are explicitly cast to integers," );
  error( "                  'n' implicit casting between types," );
  error( "                  'o' old K&R style function headers are used," );
  error( "                  'p' junk occurs after #else and #endif," );
  error( "                  's' shorts are used for the first time, (Transputer)" );
  error( "                  'u' unused variables," );
  error( "                  'v' void functions are written without 'void'," );
  error( "                  'z' zero sized arrays occur," );
  error( "                  'A' all of the above." );
  error( "-y<text>        Pass <text> as an option to the Macro Assembler." );
  error( "-z<text>        Pass <text> as an option to the C compiler." );
  error( "-A<text>        Pass <text> as an option to the linker." );
  error( "-B              Do not link with any libraries.  Do not perform objed." );
  error( "-C              Perform array bound (F77,M2) or memory access checking (C)" );
  error( "-C40            Compile code for C40s." );
  error( "-D <name>       #define <name>" );
  error( "-D <name>=<val> #define <name> to be <val> (default <val> is \"1\")." );
  error( "-E              Pre-process only - do not compile" );
  error( "-F[Afghmnpsuv]  Enable C  compiler features:" );
  error( "                 'b' enables back trace support (C40)" );  
  error( "                 'd' disables new stub generation (C40)" );  
  error( "                 'f' disables the vector stack (Transputer)," );
  error( "                 'g' removes procedure names from the code," );
  error( "                 'h' warns of discrepencies in function declarations," );
  error( "                 'l' small model (C40)," );
  error( "                 'm' warns of unused macros," );
  error( "                 'n' do not put arrays or structs on vector stack (Transputer)," );	
  error( "                 'p' disables peepholing by the code generator (C40)," );
  error( "                 's' turns off stack checking," );
  error( "                 'u' warns of unused functions and variables during linking," );
  error( "                 'v' warns of unused global functions and variables in a file," );
  error( "                 'A' turns on selected useful features." );
  error( "-I<dir>         Specify a directory to be searched for #include or Modula-2" );
  error( "                 symbol files." );
  error( "-J              Append to scanned library." );
d946 1
a946 1
  error( "-K<text>        Pass <text> as an option to Modula-2 compiler." );
d948 1
a948 1
  error( "-L<dir>         Specifies directories to be searched for libraries." );
d950 1
a950 1
  error( "-M<name>        Produce map file <name> (F77).");
d952 2
a953 2
  error( "-O              Optimise code, perform full link." );
  error( "-P<text>        Pass <text> as an option to the pre-processor." );
d955 2
a956 2
  error( "-R              Force use of RAM disk for temporary FORTRAN and Modula-2 files," );
  error( "                 even if RAM disk is not loaded" );
d958 1
a958 1
  error( "-S              Produce textual assembler output from *.c in *.s, don't link." );
d960 1
a960 1
  error( "-T[4|5|8|9]     Specify Transputer type.(5 => T425)" );
d962 2
a963 2
  error( "-V              Pass on verbose flag to executed commands." );
  error( "-U <name>       Removes any initial definition of <name>." );
d965 1
a965 1
  error( "-W<val>         Specify warning level (F77).");
d967 8
a974 8
  error( "-Wc,arg[,args]  Pass on arguments to specific parts of the compilation." );
  error( "                 where c is one of :-" );
  error( "                  'p' C pre-processor (cf -P)," );
  error( "                  '0' C compiler (cf -z)," );
  error( "                  '2' C compiler (optimising section)," );
  error( "                  'a' assembler (cf -a)," );
  error( "                  'l' linker (cf -A)," );
  error( "                  'M' Macro Assembler (cf -y)," );
d976 3
a978 3
  error( "                  'm' Modula-2 compiler (cf -M)." );
  error( "-X<val>         Specify cross reference width (F77).");
  error( "-Z<text>        Pass <text> as an option to FORTRAN compiler." );
d980 6
a985 6
  error( "-help           This message." );
  error( "" );
  error( "%s uses the following environment variables if present:-", ProgName );
  error( "SHELL           Pathname of the command line interpreter." );
  error( "C_COMPILER      Pathname of the C compiler." );
  error( "PRE_PROCESSOR   Pathname of the C pre-processor." );
d987 3
a989 3
  error( "F77_PASS1       Pathname of the first  pass of the FORTRAN compiler." );
  error( "F77_PASS2       Pathname of the second pass of the FORTRAN compiler." );
  error( "M2_COMPILER     Pathname of the Modula-2 compiler.");
d991 7
a997 7
  error( "ASSEMBLER       Pathname of the assembler." );
  error( "LINKER          Pathname of the linker." );
  error( "REMOVER         Pathname of the file removal program." );
  error( "MACRO           Pathname of the assembler macro pre-processor." );
  error( "MACDIR          Pathname of the standard AMPP macro directory." );
  error( "C_LIBDIR        Pathname of the library directory." );
  error( "C_INCDIR        Pathname of the standard C header directory." );
d999 1
a999 1
  error( "TMPDIR          Pathname of the directory for holding temporary FORTRAN files" );
d1001 3
a1003 3
  error( "LINK_HELIOS     Name     of the standard Helios link library.");
  error( "LINK_CSTART     Name     of the standard C startup file." );
  error( "LINK_CLIB       Name     of the standard C link library.");
d1005 2
a1006 2
  error( "LINK_FSTART     Name     of the standard FORTRAN startup file." );
  error( "LINK_M2START    Name     of the standard Modula-2 startup file." );
d1008 17
a1024 11
  error( "MACHINENAME     Name     of the destination hardware, passed on by -D." );
  error( "OBJNAME         Default name of output file." );
  error( "C_NONSTANDARD   Enables non-standard features." );
  error( "                 (uses pipes to connect processes and" );
  error( "                 does not use 'a.out' unless really necessary)" );
  error( "NEW_NCC         Describes the type of Norcroft C compiler being used, could be:" );
  error( "                  ARM      For the Helios ARM C compiler" );
  error( "                  C40      For the Helios TMS320C40 C compiler" );
  error( "                  I860     For the Helios i860 C compiler" );
  error( "                  TRAN     For the new Helios Transputer C compiler" );
  error( "                  OLD_TRAN For the old Helios Transputer C compiler (the default)" );
@


1.122
log
@added support for -T9 (a la -T8)
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.121 $
 * RCS date:    $Date: 1993/06/25 10:29:43 $
d857 1
a857 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.121 $)", VERSION, REVISION );
d1344 1
a1344 1
  FileNode *	new = NEW( FileNode );
d1351 1
a1351 1
      new->ext = DupName( "" );
d1356 1
a1356 1
      new->ext = DupName( p );
d1370 3
a1372 3
  new->base = DupName( p );
  new->oext = new->ext;
  new->root = DupName( tmp );
d1374 1
a1374 1
  AddTail( (List *)plist, (Node *)new );
d1399 1
a1399 1
  NameNode *	this;
d1402 3
a1404 3
  for (this = (NameNode *)FirstNode( (List *)plist );
       this;
       this = (NameNode *)NextNode( (Node *)this ))
d1406 1
a1406 1
      AddNamef( nlist, format, this->name );
d1430 1
a1430 1
  FileNode *	this;
d1433 3
a1435 3
  for (this = (FileNode *)FirstNode( (List *)plist );
       this;
       this = (FileNode *)NextNode( (Node *)this ))
d1437 1
a1437 1
      AddNamef( nlist, format, this->root, this->ext );
d2669 1
a2669 1
      FileNode *	this;
d2678 3
a2680 3
      for (this  = (FileNode *)FirstNode( (List *)&SourceFiles );
	   this != NULL;
	   this  = (FileNode *)NextNode( (Node *)this ) )
d2682 1
a2682 1
	  if (this == fnode)
d2685 1
a2685 1
	  if (streq( this->ext, "o" ) && streq( this->root, fnode->root ))
d2688 1
a2688 1
		    this->root, this->oext, fnode->root, fnode->oext );
d2738 1
a2738 1
  FileNode *	this;
d2747 3
a2749 3
  for (this = (FileNode *)FirstNode( (List *)&SourceFiles );
       (this != NULL) && result;
       this = next)
d2753 1
a2753 1
      next = (FileNode *)NextNode( (Node *)this );
d2755 1
a2755 1
      switch (*this->ext)
d2760 1
a2760 1
	      if (Pre_Process( this ) != 0)
d2769 1
a2769 1
	  if (C_Compile( this ) != 0)
d2778 1
a2778 1
	      if (Assemble( this ) != 0)
d2785 1
a2785 1
	  if (F77_Compile( this ) != 0)
d2790 1
a2790 1
	  if (MacroAssemble( this ) != 0)
d2796 1
a2796 1
	      if (Assemble( this ) != 0)
d2802 1
a2802 1
	      if (Assemble( this ) != 0)
d2814 1
a2814 1
	  if (streq( this->ext, "mod" ))
d2816 1
a2816 1
	      if (M2_CompileMod( this ) != 0)
d2819 1
a2819 1
	  else if (streq( this->ext, "def" ))
d2821 1
a2821 1
	      if (M2_CompileDef( this ) != 0)
d2824 1
a2824 1
	      /* delete this node from the list of source  */
d2828 1
a2828 1
	      Remove( (Node *)this );
d2851 1
a2851 1
  FileNode *	this;
d2859 3
a2861 3
  for (this = (FileNode *)FirstNode( (List *)&SourceFiles );
       this;
       this = (FileNode *)NextNode( (Node *)this ))
d2863 1
a2863 1
      if (streq( this->ext, "s" ))
d2865 1
a2865 1
	  if (Assemble( this ) != 0)
d2935 1
a2935 1
	  FileNode *	this;
d2975 3
a2977 3
	  for (this  = (FileNode *)FirstNode( (List *)&SourceFiles );
	       this != NULL;
	       this  = (FileNode *)NextNode( (Node *)this ) )
d2985 1
a2985 1
	      sprintf( name, "%s.%s", this->root, this->ext );
d3479 1
a3479 1
  NameNode *	this;
d3514 3
a3516 3
      for ( this = (NameNode *)FirstNode( (List *)&IncludeDirs );
	   this;
	   this = (NameNode *)NextNode( (Node *)this) )
d3518 1
a3518 1
	  if (streq( this->name, buffer ))
d3542 1
a3542 1
  NameNode *	this;
d3577 3
a3579 3
      for ( this = (NameNode *)FirstNode( (List *)&SymbolDirs );
	   this;
	   this = (NameNode *)NextNode( (Node *)this) )
d3581 1
a3581 1
	  if (streq( this->name, buffer ))
d3605 1
a3605 1
  NameNode *	this;
d3640 3
a3642 3
      for (this = (NameNode *)FirstNode( (List *)&LibraryDirs );
	   this;
	   this = (NameNode *)NextNode( (Node *)this) )
d3644 1
a3644 1
	  if (streq( this->name, buffer ))
d3669 1
a3669 1
  NameNode *	this = (NameNode *)FirstNode( (List *)&IncludeDirs );
d3672 1
a3672 1
  if (this == NULL)
d3678 2
a3679 2
       this;
       this = (NameNode *)NextNode( (Node *)this) )
d3681 1
a3681 1
      strcat( buffer, this->name );
d3715 1
a3715 1
  NameNode *	this = (NameNode *)FirstNode( (List *)&SymbolDirs );
d3718 1
a3718 1
  if (this == NULL)
d3724 2
a3725 2
       this;
       this = (NameNode *)NextNode( (Node *)this ))
d3727 1
a3727 1
      strcat( buffer, this->name );
d3750 1
a3750 1
  FileNode *	this;
d3756 3
a3758 3
  for (this = (FileNode *)FirstNode( (List *)&SourceFiles );
       this;
       this = (FileNode *)NextNode( (Node *)this ))
d3762 1
a3762 1
      switch (*this->ext)
d3786 1
a3786 1
	  if (strneq( this->root, link_cstart, strlen( link_cstart ) - 2 ))
d3797 1
a3797 1
	  if (streq( this->ext, "mod" ))
d3799 1
a3799 1
	  else if (streq( this->ext, "def" ))
d3801 1
a3801 1
	  else if (streq( this->ext, "lib" ))
d3804 1
a3804 1
	    fail( "unknown type of source file => %s.%s", this->root, this->ext );
@


1.121
log
@fixed to set up correct patsh for both C40 and transputer incarnations
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.120 $
 * RCS date:    $Date: 1993/06/10 17:04:50 $
d857 1
a857 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.120 $)", VERSION, REVISION );
d957 1
a957 1
  error( "-T[4|5|8]       Specify Transputer type.(5 => T425)" );
d4224 7
a4234 1
		    
a4235 1
		    
a4241 1
		    
a4247 1
		    
@


1.120
log
@fixed for building old style transputer binaries
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.119 $
 * RCS date:    $Date: 1993/06/09 15:01:18 $
d306 8
d315 4
a318 1
#define ASSEMBLER		"/helios/bin/asm"
d320 1
d350 8
d359 5
a363 1
#define C_LIBDIR		"/helios/lib/"
d857 1
a857 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.119 $)", VERSION, REVISION );
d874 1
d3853 1
a3873 1
  get_var( c_libdir,      "C_LIBDIR",      C_LIBDIR      );
d3912 1
d3919 1
d3960 3
a3962 2
      ld = LINKER;
      cc = C_COMPILER;
d3965 3
a3967 2
  get_var( linker,     "LINKER",     ld );
  get_var( c_compiler, "C_COMPILER", cc );
d4069 2
d4423 13
a4435 1
	      Flags |= FLAG_c;
d4720 2
@


1.119
log
@fixed for building on RS6000
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.118 $
 * RCS date:    $Date: 1993/03/16 14:10:38 $
d16 2
a17 2
#define REVISION	60
#define DATE		12/08/92
d139 2
d271 1
a271 1
#define TRANSPUTER_CC			"/helios/bin/cc"
d833 1
a833 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.118 $)", VERSION, REVISION );
d986 5
a990 4
  error( "                  ARM     For the Helios ARM C compiler" );
  error( "                  C40     For the Helios TMS320C40 C compiler" );
  error( "                  I860    For the Helios i860 C compiler" );
  error( "                  TRAN    For the Helios Transputer C compiler (the default)" );
d2158 1
a2158 1
  if (REDIRECT && /*_is_transputer_compiler &&*/ COMPILE_ONLY)
d3915 7
d3924 1
a3924 1
	  if (!streq( ptr, "TRANSPUTER" ))
@


1.118
log
@oops, fixed previous elta
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.117 $
 * RCS date:    $Date: 1993/03/15 12:06:02 $
d215 4
d831 1
a831 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.117 $)", VERSION, REVISION );
@


1.117
log
@fixed -t to use correct compiler option
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.116 $
 * RCS date:    $Date: 1993/01/15 11:22:14 $
d827 1
a827 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.116 $)", VERSION, REVISION );
d4672 1
a4672 1
		      AddName( &CompileOpts, "-Fb" );
@


1.116
log
@Added #define to convert vfork to fork for RS6000 since it is not a BSD
system.
@
text
@d8 1
a8 1
 * This code is Copyright (c) 1990, 1991, 1992 Perihelion Software Ltd.
d11 2
a12 2
 * RCS version: $Revision: 1.115 $
 * RCS date:    $Date: 1992/12/08 14:22:56 $
d827 1
a827 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.115 $)", VERSION, REVISION );
d4672 1
a4672 1
		      AddName( &CompileOpts, "-Zm" );
@


1.115
log
@removed -Fd from -r command line
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.114 $
 * RCS date:    $Date: 1992/12/03 11:05:19 $
d152 4
d827 1
a827 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.114 $)", VERSION, REVISION );
@


1.114
log
@added -d option when compiling assembly files for shared libraries
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.113 $
 * RCS date:    $Date: 1992/12/03 11:04:07 $
d823 1
a823 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.113 $)", VERSION, REVISION );
a4611 1
		  AddName( &CompileOpts, "-Fd" );  	/* old style stubs */
@


1.113
log
@added automatic generation of -d command line option for assembly code compiled with -r option
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.112 $
 * RCS date:    $Date: 1992/11/13 14:00:20 $
d823 1
a823 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.112 $)", VERSION, REVISION );
d4499 1
@


1.112
log
@oops, removed debugging left in by previous delta
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.111 $
 * RCS date:    $Date: 1992/11/13 13:47:14 $
d550 7
a556 6
#define FEAT_m		(1 <<  5)
#define FEAT_n		(1 <<  6)
#define FEAT_p		(1 <<  7)
#define FEAT_s		(1 <<  8)
#define FEAT_u		(1 <<  9)
#define FEAT_v		(1 << 10)
d823 1
a823 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.111 $)", VERSION, REVISION );
d896 1
d3251 4
d3385 5
d4612 1
@


1.111
log
@yup fixed that bug again
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.110 $
 * RCS date:    $Date: 1992/11/12 18:26:03 $
d589 1
a589 1
 #define DEBUG 
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.110 $)", VERSION, REVISION );
@


1.110
log
@fixed another bug
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.109 $
 * RCS date:    $Date: 1992/11/04 18:55:38 $
d589 1
a589 1
/* #define DEBUG */
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.109 $)", VERSION, REVISION );
d2145 1
a2145 1
  if (REDIRECT && _is_transputer_compiler && !ASSEMBLE)
d2147 6
a2152 1
      /* XXX - not sure what this is for, but beware of compromising 'c fred.c -o fred' */
@


1.109
log
@fixed incorrect generation of output file names
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.108 $
 * RCS date:    $Date: 1992/11/04 18:45:32 $
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.108 $)", VERSION, REVISION );
d2145 1
a2145 1
  if (REDIRECT && (!_is_transputer_compiler || !ASSEMBLE))
d2147 2
d2165 1
a2165 1
	  
@


1.108
log
@fixed bug generating name of output file
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.107 $
 * RCS date:    $Date: 1992/10/28 16:40:35 $
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.107 $)", VERSION, REVISION );
d2145 1
a2145 1
  if (REDIRECT && !ASSEMBLE)
@


1.107
log
@fixed another pipe related bug - OH HOW I WISH I COULD REMOVE THIS FEATURE
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.106 $
 * RCS date:    $Date: 1992/10/28 16:21:30 $
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.106 $)", VERSION, REVISION );
d2161 3
d2166 11
d2179 1
a2179 1
	      AddNamef( plist, "%s.s", fnode->root );
d2183 1
a2183 1
	      AddNamef( plist, "%s.o", fnode->root );
d4863 3
d4868 9
a4876 1
	  ObjName    = ((FileNode *)FirstNode( &SourceFiles ))->base;
@


1.106
log
@fixed linking for transputers
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.105 $
 * RCS date:    $Date: 1992/10/21 09:17:03 $
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.105 $)", VERSION, REVISION );
d2190 3
a2192 1
	   && ObjName != NULL && ObjName != ((FileNode *)FirstNode( &SourceFiles ))->base)
d2197 1
a2197 1
      
@


1.105
log
@fixed output of compiler naming
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.104 $
 * RCS date:    $Date: 1992/10/21 09:05:32 $
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.104 $)", VERSION, REVISION );
d2855 1
a2855 1
	  if (!USE_PIPE || NCfiles == 0)
d3024 1
a3024 1
      if (NSources == 1 && (NCfiles != 0 || NAfiles != 0) && USE_PIPE)
@


1.104
log
@prevented use of pipes to join compilation stages for non-transputer compilers as these must be able to seek on their output
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.103 $
 * RCS date:    $Date: 1992/10/20 10:59:32 $
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.103 $)", VERSION, REVISION );
d2167 1
a2167 1
	  else if (streq( ObjName, OBJNAME ) || !COMPILE_ONLY)
a2169 4
	    }
	  else
	    {
	      AddNamef( plist, "%s", ObjName );
@


1.103
log
@fixed solo assembling
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.102 $
 * RCS date:    $Date: 1992/10/14 16:57:29 $
d370 1
a370 1
#define _is_transputer_helios	(compiler == TRANSPUTER_COMPILER || compiler == UNKNOWN_COMPILER)
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.102 $)", VERSION, REVISION );
d2586 1
a2586 1
  if (_is_transputer_helios)
d2846 1
a2846 1
      if (_is_transputer_helios)
d3055 1
a3055 1
  if (!JOIN && !APPEND || _is_transputer_helios)
d4863 5
a4867 3
      (!_is_norcroft_compiler
       || (!JOIN && !APPEND && NSources == 1 &&	/* do not use pipes when compiling more than one file */
	   (NCfiles > 0 || NAfiles > 0))	/* do not use pipes when just assembling */
d4880 1
a4880 1
      if (_is_transputer_helios)
@


1.102
log
@fixed spelling mistake
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.101 $
 * RCS date:    $Date: 1992/10/12 11:30:53 $
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.101 $)", VERSION, REVISION );
d2687 1
a2687 1
  debug( "DOCompiles() called" );
d4863 3
a4865 2
      (!_is_norcroft_compiler ||
       (!JOIN && !APPEND && NSources == 1)	/* do not use pipes when compiling more than one file */
d4922 3
a4924 1
      if (!LINK || NCfiles + NFfiles + NSfiles + NAfiles + NMfiles > 1)
@


1.101
log
@added definction od __SMT for AMPP builds
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.100 $
 * RCS date:    $Date: 1992/10/12 09:41:48 $
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.100 $)", VERSION, REVISION );
d864 1
a864 1
  error( "-u              Prevents removal of intermeadiary files.");
@


1.100
log
@added automatic inclusion of debugging library with -g command line option
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.99 $
 * RCS date:    $Date: 1992/10/06 10:47:53 $
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.99 $)", VERSION, REVISION );
d4805 2
d4818 2
@


1.99
log
@fixed -Fg for C40's (I hope)
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.98 $
 * RCS date:    $Date: 1992/09/30 13:50:50 $
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.98 $)", VERSION, REVISION );
d4406 2
@


1.98
log
@oops, removed debug left in previous delta
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.97 $
 * RCS date:    $Date: 1992/09/30 13:49:25 $
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.97 $)", VERSION, REVISION );
d901 1
a901 1
  error( "                 'A' turns onselected useful features." );
d3223 1
a3223 4
	  if (_is_norcroft_compiler)
	    Feats |= FEAT_f;		/* feature overloading ! */
	  else
	    Feats |= FEAT_g;
@


1.97
log
@fixed verification omissions
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.96 $
 * RCS date:    $Date: 1992/09/16 17:21:26 $
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.96 $)", VERSION, REVISION );
a4866 2
  debug( "NSources = %d, VERIFY = %d", NSources, VERIFY );

@


1.96
log
@gues what - fixed another error
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.95 $
 * RCS date:    $Date: 1992/09/15 15:16:42 $
d589 2
d822 1
a822 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.95 $)", VERSION, REVISION );
d1608 4
a1629 5
      argv[ i++ ] = pnode->name;

      while (isspace( argv[ i - 1 ][ 0 ]))
	argv[ i - 1 ] += 1;

d1637 6
a1642 1
	
d1645 2
d1863 4
a1866 1
    
d2099 4
d2135 4
d2250 4
d2522 4
d2578 4
d2686 4
d2798 4
d2838 4
d4069 1
a4831 5
  if (use_non_standard_features && (!_is_norcroft_compiler || !JOIN))
    {
      Flags |= FLAG_P;
    }
  
d4858 8
d4867 2
@


1.95
log
@fixed command line options for removing procedure names
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.94 $
 * RCS date:    $Date: 1992/09/15 10:07:07 $
d820 1
a820 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.94 $)", VERSION, REVISION );
d3153 1
a3160 3
	      
	    case C40_COMPILER:
	      Feats |= FEAT_s | FEAT_f;
@


1.94
log
@oops, forgot to allow tranny joins to be executed
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.93 $
 * RCS date:    $Date: 1992/09/02 16:45:08 $
d820 1
a820 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.93 $)", VERSION, REVISION );
a3274 1
      if ((Feats & FEAT_f) != 0) strcat( buf, "f" );
d3286 9
a3294 1
      AddName( &CompileOpts, buf );
d3298 1
a3298 1
	    AddName( &CompileOpts, "-Zpm1" );
d3303 4
a3306 1
	  AddName( &CompileOpts, "-pg0" );
d3333 3
a3335 1
	}	
@


1.93
log
@fixed bugs with -S option
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.92 $
 * RCS date:    $Date: 1992/09/01 13:49:14 $
d820 1
a820 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.92 $)", VERSION, REVISION );
d2800 1
a2800 1
    
d3012 1
a3012 1
  if (!JOIN && !APPEND)
@


1.92
log
@fixed bug introduced by previous delta
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.91 $
 * RCS date:    $Date: 1992/09/01 13:25:36 $
d820 1
a820 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.91 $)", VERSION, REVISION );
d2163 1
a2163 1
  else if (_is_norcroft_compiler && !COMPILE_ONLY)
d2174 2
a2175 1
  else if (COMPILE_ONLY && ObjName != NULL && ObjName != ((FileNode *)FirstNode( &SourceFiles ))->base)
a3892 3
  if (_is_norcroft_compiler)
    AddName( &CompileOpts, "-c" );	/* Norcroft compilers try to link automatically ... */
		
d4703 10
@


1.91
log
@fixed bug building output file name
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.90 $
 * RCS date:    $Date: 1992/08/21 16:32:33 $
d820 1
a820 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision: 1.90 $)", VERSION, REVISION );
d2174 1
a2174 1
  else if (COMPILE_ONLY && ObjName != NULL)
@


1.90
log
@fixed bug with new library linking scheme
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.89 $
 * RCS date:    $Date: 1992/08/20 15:31:07 $
d820 1
a820 1
  error( "Helios compiler driver, version %d.%d (RCS $Revision$)", VERSION, REVISION );
d2174 11
@


1.89
log
@added -tran and -C40 command line options
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.88 $
 * RCS date:    $Date: 1992/08/19 16:16:25 $
d820 1
a820 1
  error( "Helios compiler driver, version %d.%d", VERSION, REVISION );
d1625 4
a1628 1
	
d1638 1
a1638 1
	printf( "%s ", pnode->name );
@


1.88
log
@fixed scanned library naming
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.87 $
 * RCS date:    $Date: 1992/08/19 13:33:52 $
d260 2
a261 2
#ifndef TRAN_CC
#define TRAN_CC			"/helios/bin/cc"
d278 1
a278 1
#define C_COMPILER		TRAN_CC
d861 1
d883 1
d2897 1
a2897 1
		      forever
d3780 1
a3780 1
      cc       = TRAN_CC;
a3855 65
  /* O/S identification */
  
  AddName( &Defines, "helios" );		/* this is archaic and should be allowed to die out */
  AddName( &Defines, "__HELIOS" );
  
  /* Processor identification */

  AddName( &Defines, machinename );

  /* Compiler and Host identification */

  AddName( &MacroOpts, "-d__HELIOS" );
  AddName( &MacroOpts, "1" );
  
  switch (compiler)
    {
    default:
    case TRANSPUTER_COMPILER:
      AddName( &Defines, "transputer" );
      AddName( &Defines, "__TRAN" );
      AddName( &Defines, "__HELIOSTRAN" );
      AddName( &MacroOpts, "-dhelios.TRAN" );
      AddName( &MacroOpts, "1" );
      AddName( &MacroOpts, "-d__TRAN" );
      AddName( &MacroOpts, "1" );      
      AddName( &MacroOpts, "-d__HELIOSTRAN" );
      AddName( &MacroOpts, "1" );      
      break;

    case ARM_COMPILER:
      AddName( &Defines, "__ARM" );
      AddName( &Defines, "__HELIOSARM" );
      AddName( &Defines, "__SMT" );		/* split module table */
      AddName( &MacroOpts, "-dhelios.arm" );
      AddName( &MacroOpts, "1" );
      AddName( &MacroOpts, "-d__ARM" );
      AddName( &MacroOpts, "1" );      
      AddName( &MacroOpts, "-d__HELIOSARM" );
      AddName( &MacroOpts, "1" );      
      break;

    case C40_COMPILER:
      AddName( &Defines, "__C40" );
      AddName( &Defines, "__HELIOSC40" );
      AddName( &Defines, "__SMT" );
      AddName( &MacroOpts, "-dhelios.C40" );
      AddName( &MacroOpts, "1" );
      AddName( &MacroOpts, "-d__C40" );
      AddName( &MacroOpts, "1" );      
      AddName( &MacroOpts, "-d__HELIOSC40" );
      AddName( &MacroOpts, "1" );      
      break;
      
    case I860_COMPILER:
      AddName( &Defines, "__I860" );
      AddName( &Defines, "__HELIOSI860" );
      AddName( &MacroOpts, "-dhelios.I860" );
      AddName( &MacroOpts, "1" );
      AddName( &MacroOpts, "-d__I860" );
      AddName( &MacroOpts, "1" );      
      AddName( &MacroOpts, "-d__HELIOSI860" );
      AddName( &MacroOpts, "1" );      
      break;
    }
  
a3923 2
	      
	      strcat( FortranP2Opts, "+B" );
d3925 8
a3932 1
	      if (_is_norcroft_compiler)
d3934 6
a3939 1
		  AddName( &CompileOpts, "-Zpc1" );		  
d4556 11
a4566 2
	      
	      AddName( &ModulaOpts, "-t" );
d4568 1
a4568 1
	      strcat( FortranP1Opts, "+T" );
d4570 4
a4573 3
	      if (_is_norcroft_compiler)
		{
		  AddName( &CompileOpts, "-Zm" );
d4689 65
@


1.87
log
@fixed counting of source files
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.86 $
 * RCS date:    $Date: 1992/08/13 08:11:44 $
d4712 14
a4725 1
	      AddLibraryName( false, "%s", arg );
@


1.86
log
@fixed bug with new cat
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.85 $
 * RCS date:    $Date: 1992/08/12 17:01:27 $
d3618 1
d3675 14
d4712 1
a4712 1
	      AddLibraryName( false, "-l%s", arg );
a4716 2
	  
	      NSources++;
d4733 1
a4733 1
  
@


1.85
log
@added -J option to append to scanned libraries
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.84 $
 * RCS date:    $Date: 1992/08/12 13:41:38 $
d2840 1
a2840 1
		  output = fopen( ObjName, APPEND ? "wba" : "wb" );
d2995 1
a2995 1
  if (!JOIN)
@


1.84
log
@added support for -wn (and included in -wA), suppressing warnings about implicit casts
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.83 $
 * RCS date:    $Date: 1992/07/30 11:28:03 $
d16 2
a17 2
#define REVISION	59
#define DATE		06/07/92
d137 2
d492 12
a503 11
#define FLAG_O		(1 << 1)
#define FLAG_P		(1 << 2)
#define FLAG_S		(1 << 3)
#define FLAG_V		(1 << 4)
#define FLAG_b		(1 << 5)
#define FLAG_c		(1 << 6)
#define FLAG_j		(1 << 7)
#define FLAG_n		(1 << 8)
#define FLAG_o		(1 << 9)
#define FLAG_p		(1 << 10)
#define FLAG_v		(1 << 11)
d515 1
d900 1
d2784 1
a2784 1
  if (JOIN)
d2788 7
d2840 1
a2840 1
		  output = fopen( ObjName, "wb" );
d4042 5
d4402 1
a4402 1
	    case 'j': /* join asm files */
a4663 1
	    case 'J': /* unused */
@


1.83
log
@fixed -q option
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.82 $
 * RCS date:    $Date: 1992/07/30 10:46:31 $
d524 6
a529 5
#define WARN_o		(1 << 4)
#define WARN_p		(1 << 5)
#define WARN_s		(1 << 6)
#define WARN_u		(1 << 7)
#define WARN_v		(1 << 8)
d865 1
d3026 1
a3026 1
	      Warns = WARN_a | WARN_d | WARN_f | WARN_p | WARN_v | WARN_o | WARN_u | WARN_i;
d3057 5
d3219 1
@


1.82
log
@improved help messages and fixed -r to engage old style stubs for the C40
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.81 $
 * RCS date:    $Date: 1992/07/29 15:46:26 $
d4497 9
a4505 2
	      
	      AddNamef( &CompileOpts, "%s", &arg[ 0 ] );
@


1.81
log
@fixed bug in assembler command line
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.80 $
 * RCS date:    $Date: 1992/07/29 15:39:40 $
d817 2
a818 2
  error( "*.c           C source file." );
  error( "*.i           Pre-processed C source file." );
d820 1
a820 1
  error( "*.f           FORTRAN source file.");
d822 2
a823 2
  error( "*.s           Assembler source file." );
  error( "*.a           Macro Assembler source file." );
d825 2
a826 2
  error( "*.def         Modula-2 definition source file." );
  error( "*.mod         Modula-2 program source file." );
d828 5
a832 5
  error( "*.o           Assembled file - ready for linking." );
  error( "-a<text>      Pass <text> as an option to assembler." );
  error( "-b            Don't link with standard library (helios.lib)." );
  error( "-c            Compile/Assemble only, don't link." );
  error( "-d<name>      Specify output file name for library .def compilations." );
d834 1
a834 1
  error( "-e[6|7]       Enforce FORTRAN standard.");
d836 41
a876 37
  error( "-f <name>     Specify file name for the assembler's virtual memory system." );
  error( "-g            Compile for debugging." );
  error( "-h<val>       Specify heap size of program." );
  error( "-j            Join objects but don't link." );
  error( "-l<name>      Link with standard library <name>" );
  error( "-m            Compile code for libraries." );
  error( "-n            Don't actually execute commands (implies -v)." );
  error( "-n<string>    Specify object name of program." );
  error( "-o <name>     Specify output name (default *.o or \"a.out\") (\"-\" is stdout)" );
  error( "-p            Compile code for profiling.");
  error( "-q<abdfghilmopqrstuwxyz>	Enable compiler debugging features." );
  error( "-r            Suppress static data structures." );
  error( "-s<val>       Specify stack size of program." );
  error( "-t            Compile code for tracing.");
  error( "-u            Prevents removal of intermeadiary files.");
  error( "-v            Display command(s) being executed." );
  error( "-w[Aacdfpsvz] Suppress warnings and error messages from the C compiler when :-" );
  error( "                'a' '=' occurs in a condition context," );
  error( "                'c' ANSI disallowed casts are used," );
  error( "                'd' (some)deprecated features are used," );
  error( "                'f' functions are implicity declared as 'extern int()'," );
  error( "                'i' pointers are explicitly cast to integers," );
  error( "                'o' old K&R style function headers are used," );
  error( "                'p' junk occurs after #else and #endif," );
  error( "                's' shorts are used for the first time," );
  error( "                'u' unused variables," );
  error( "                'v' void functions are written without 'void'," );
  error( "                'z' zero sized arrays occur," );
  error( "                'A' all of the above." );
  error( "-y<text>      Pass <text> as an option to the Macro Assembler." );
  error( "-z<text>      Pass <text> as an option to the C compiler." );
  error( "-A<text>      Pass <text> as an option to the linker." );
  error( "-B            Do not link with any libraries.  Do not perform objed." );
#ifndef __ARM
  error( "-C            Perform array bound checking (F77,M2).");
#endif
  error( "-D <name>     #define <name>" );
d878 16
a893 16
  error( "-E            Pre-process only - do not compile" );
  error( "-F[Afghmnpsuv] Enable compiler features :-" );
  error( "                'b' enables back trace support (C40)" );  
  error( "                'd' disables new stub generation (C40)" );  
  error( "                'f' disables the vector stack (transputer)," );
  error( "                'g' removes procedure names from the code," );
  error( "                'h' warns of discrepencies in function declarations," );
  error( "                'm' warns of unused macros," );
  error( "                'n' do not put arrays or structs on vector stack (transputer)," );	
  error( "                'p' disables peepholing by the code generator (C40)," );
  error( "                's' turns off stack checking," );
  error( "                'u' warns of unused functions and variables during linking," );
  error( "                'v' warns of unused global functions and variables in a file," );
  error( "                'A' turns onselected useful features." );
  error( "-I<dir>       Specify a directory to be searched for #include or Modula-2 symbol" );
  error( "                files." );
d895 1
a895 1
  error( "-K<text>      Pass <text> as an option to Modula-2 compiler." );
d897 1
a897 1
  error( "-L<dir>       Specifies directories to be searched for libraries." );
d899 1
a899 1
  error( "-M<name>      Produce map file <name> (F77).");
d901 2
a902 2
  error( "-O            Optimise code, perform full link." );
  error( "-P<text>      Pass <text> as an option to the pre-processor." );
d904 2
a905 2
  error( "-R            Force use of RAM disk for temporary FORTRAN and Modula-2 files," );
  error( "                even if RAM disk is not loaded" );
d907 1
a907 1
  error( "-S            Produce textual assembler output from *.c in *.s, don't link." );
d909 1
a909 1
  error( "-T[4|5|8]     Specify Transputer type.(5 => T425)" );
d911 2
a912 2
  error( "-V            Pass on verbose flag to executed commands." );
  error( "-U <name>     Removes any initial definition of <name>." );
d914 1
a914 1
  error( "-W<val>       Specify warning level (F77).");
d916 8
a923 8
  error( "-Wc,arg[,arg ...] Pass on arguments to specific parts of the compilation." );
  error( "              where c is one of :-" );
  error( "                'p' C pre-processor (cf -P)," );
  error( "                '0' C compiler (cf -z)," );
  error( "                '2' C compiler (optimising section)," );
  error( "                'a' assembler (cf -a)," );
  error( "                'l' linker (cf -A)," );
  error( "                'M' Macro Assembler (cf -y)," );
d925 3
a927 3
  error( "                'm' Modula-2 compiler (cf -M)." );
  error( "-X<val>       Specify cross reference width (F77).");
  error( "-Z<text>      Pass <text> as an option to FORTRAN compiler." );
d929 1
a929 1
  error( "-help         This message." );
d932 3
a934 3
  error( "SHELL         Pathname of the command line interpreter." );
  error( "C_COMPILER    Pathname of the C compiler." );
  error( "PRE_PROCESSOR Pathname of the C pre-processor." );
d936 11
a946 11
  error( "F77_PASS1     Pathname of the first  pass of the FORTRAN compiler." );
  error( "F77_PASS2     Pathname of the second pass of the FORTRAN compiler." );
  error( "M2_COMPILER   Pathname of the Modula-2 compiler.");
#endif
  error( "ASSEMBLER     Pathname of the assembler." );
  error( "LINKER        Pathname of the linker." );
  error( "REMOVER       Pathname of the file removal program." );
  error( "MACRO         Pathname of the assembler macro pre-processor." );
  error( "MACDIR        Pathname of the standard AMPP macro directory." );
  error( "C_LIBDIR      Pathname of the library directory." );
  error( "C_INCDIR      Pathname of the standard C header directory." );
d948 1
a948 1
  error( "TMPDIR        Pathname of the directory for holding temporary FORTRAN files" );
d950 3
a952 3
  error( "LINK_HELIOS   Name     of the standard Helios link library.");
  error( "LINK_CSTART   Name     of the standard C startup file." );
  error( "LINK_CLIB     Name     of the standard C link library.");
d954 2
a955 2
  error( "LINK_FSTART   Name     of the standard FORTRAN startup file." );
  error( "LINK_M2START  Name     of the standard Modula-2 startup file." );
d957 3
a959 3
  error( "MACHINENAME   Name     of the destination hardware, passed on by -D." );
  error( "OBJNAME       Default name of output file." );
  error( "C_NONSTANDARD Enables non-standard features." );
d962 5
a966 5
  error( "NEW_NCC       Describes the type of Norcroft C compiler being used, values are :-" );
  error( "        ARM   For the Helios ARM C compiler" );
  error( "        C40   For the Helios TMS320C40 C compiler" );
  error( "        TRAN  For the Helios Transputer C compiler (the default)" );
  error( "        I860  For the Helios i860 C compiler" );
d3954 5
d4517 3
d4522 1
d4566 5
@


1.80
log
@oops, fixed typo in previous delta
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.79 $
 * RCS date:    $Date: 1992/07/29 15:37:43 $
a2531 5
  if (!USE_PIPE)
    {
      AddNamef( plist, "%s.s", fnode->root );
    }
  
d2580 5
@


1.79
log
@fixed assembler comman dline option
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.78 $
 * RCS date:    $Date: 1992/07/29 14:50:17 $
d2527 1
a2527 1
  if (is_transputer_helios)
@


1.78
log
@fixed minor bugs
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.77 $
 * RCS date:    $Date: 1992/07/28 17:06:19 $
d2527 3
a2529 3
#ifdef __TRAN
  AddName(  plist, "-p"                ); /* only assemble */
#endif
@


1.77
log
@removed quote and blank processing from command line argumnets, as this is no longer a problem with the new way of running commands
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.76 $
 * RCS date:    $Date: 1992/07/28 14:47:36 $
d2877 1
a2877 1
		      while (!feof( input ))
d2879 9
a2887 1
			  fputc( fgetc( input ), output );		      
d2943 1
a2943 1
		  warning( "Could not find c library '%s'", link_clib );
d4698 5
a4702 2
      AddName( &AssembleOpts, "-f" ); /* full link */
      AddName( &LinkOpts,     "-f" );
d4718 1
a4718 1
	  warning( "Could not find standard helios library '%s'!", link_helios );
@


1.76
log
@fixed -j option (I hope)
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.75 $
 * RCS date:    $Date: 1992/07/24 07:58:43 $
d1095 1
a1095 73
  
  if (strchr( pname, '\"' ))
    {
      char *	ptr   = pname;
      char *	pcopy;
      int	count = 0;
      bool	seen_slash;
      char	prev_c;
      
      
      /*
       * oh dear - in order to preserve double quotes
       * across command lines we must prepend a
       * backquote to each one (unless, of course
       * one already exists)
       */
      
      while ((ptr = strchr( ptr, '\"' )) != NULL)
	++count,
	++ptr;
      
      pnew->name = pcopy = SafeAlloc( (unsigned long)strlen( pname ) + 1 + count );
      
      ptr = pname;
      
      prev_c     = '\0';
      seen_slash = false;
      
      while (*ptr != '\0')
	{
	  char	c;
	  
	  
	  c = *ptr++;
	  
	  switch (c)
	    {
	    case '\"':
	      if (!seen_slash)
		*pcopy++='\\';
	      seen_slash = false;
	      break;
	      
	    case '\\':
	      if (prev_c == '\\')
		seen_slash = false;
	      else
		seen_slash = true;
	      break;
	      
	    default:
	      seen_slash = false;
	      break;
	    }
	  
	  *pcopy++ = c;
	  
	  prev_c = c;
	}
      
      *pcopy = '\0';      
    }
  else
    {
      pnew->name = DupName( pname );
    }
  
#ifndef __ARM
  if (strchr( pname, ' ' ))
    {
      warning( "blank(s) found in argument '%s'", pname );
    }
#endif    
@


1.75
log
@fixed -p option
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.74 $
 * RCS date:    $Date: 1992/07/14 14:56:27 $
a341 4
#ifndef CAT
#define CAT			"cat"
#endif

a465 1
static char *		cat;
d631 1
a631 1
  error( char * format, ... )
d669 1
a669 1
  warning( char * format, ... )
d710 1
a710 1
  fail( char * format, ... )
d752 1
a752 1
  SafeAlloc( unsigned long size )
d775 1
a775 1
  usage(
d777 1
a777 1
	void
d779 1
a779 1
	)
a936 3
#ifdef __ARM
  error( "CAT		Pathname of the cat program (for scanned libs)." );
#endif
d990 1
a990 1
  FirstNode( List * plist )
d1013 1
a1013 1
  NextNode( Node * pnode )
d1037 1
a1037 1
  ListSize( List * plist )
d1060 1
a1060 1
  DupName( char * pname )
d1081 3
a1083 3
  AddName(
	  NameList *	plist,
	  char *	pname )
d1178 3
a1180 3
  RemoveName(
	     NameList *	plist,
	     char * 	pname )
d1216 3
a1218 3
  AddNameToFront(
		 NameList *	plist,
		 char *		pname )
d1248 4
a1251 4
  AddNamef(
	   NameList *	plist,
	   char *	format,
	   ... )
d1255 1
a1255 1
  char *		format;
d1285 4
a1288 4
  AddLibraryName(
		 bool	resident,
		 char * format,
		 ... )
d1350 3
a1352 3
  AddFile(
	  FileList *	plist,
	  char *	file )
d1404 4
a1407 4
  AddNames(
	   NameList *	nlist,
	   char *	format,
	   NameList *	plist )
d1435 4
a1438 4
  AddFiles(
	   NameList *	nlist,
	   char *	format,
	   FileList *	plist )
d1474 3
a1476 3
  AddLibrary(
	     char *	dir,
	     char *	stem )
d2465 3
a2467 3
  List *	plist  = (List *)&args;
  int		result = 0;
  char *	extension;	
d2865 1
a2865 1
	      AddName(  plist, "-o" 	 );
d2871 44
a2914 3
	  AddNamef( plist, "%s", cat );
	
	  if (!USE_PIPE || NCfiles == 0)
d2916 45
a2960 1
	      AddFiles( plist, "%s.%s", &SourceFiles );
d2962 2
a2963 2
      
	  if (ObjName != NULL)
d2965 4
a2968 2
	      AddName( plist, ">" );
	      AddNamef( plist, "%s", ObjName );
d2970 9
d3041 1
a3041 5
#ifdef __ARM
  if (JOIN)
    result = ExecuteCmdList( plist );
  else
#endif
a3761 1
  get_var( cat,           "CAT",           CAT           );
a3965 5
  if (use_non_standard_features)
    {
      Flags |= FLAG_P;
    }
  
d4721 5
@


1.74
log
@fixed bug with -j option, and improved command line flags for AMPP building
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.73 $
 * RCS date:    $Date: 1992/07/13 17:22:12 $
d4461 5
a4465 2
	    case 'p': /* compile for profiling */	      
	      AddName( &CompileOpts, "-p" );
@


1.73
log
@might have improved ampp automatic defines ....
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.72 $
 * RCS date:    $Date: 1992/07/10 15:00:34 $
d342 2
a343 4
#ifdef __ARM
#  ifndef CAT
#    define CAT			"cat"
#  endif
d371 2
a372 1
#define is_full_norcroft( c )	((c) == ARM_COMPILER || (c) == C40_COMPILER || (c) == I860_COMPILER)
a469 1
#ifdef __ARM
a470 1
#endif
d2194 1
a2194 1
	  if (is_full_norcroft( compiler ))
d2204 1
a2204 1
      if (is_full_norcroft( compiler ))
d2227 1
a2227 1
  else if (is_full_norcroft( compiler ) && !COMPILE_ONLY)
d2245 1
a2245 1
  if (is_full_norcroft( compiler ))
d2855 5
a2859 2
#ifdef __ARM
      AddNamef( plist, "%s", cat );
d2861 15
a2875 3
      if (!USE_PIPE || NCfiles == 0)
	{
	  AddFiles( plist, "%s.%s", &SourceFiles );
d2877 1
a2877 2
      
      if (ObjName != NULL)
d2879 1
a2879 6
	  AddNamef( plist, "> %s", ObjName );
	}
#else /* ! __ARM */      
      AddNamef( plist, "%s", linker    );
      AddNames( plist, "%s", &LinkOpts );      
      AddName(  plist, "-p" );
d2881 4
a2884 4
      if (!USE_PIPE || NCfiles == 0)
	{
	  AddFiles( plist, "%s.%s", &SourceFiles );
	}
d2886 5
a2890 9
      if (vfile != NULL)
	{
	  AddNamef( plist, "-m%s", vfile );
	}
      
      if (ObjName != NULL)
	{
	  AddName(  plist, "-o" 	 );
	  AddNamef( plist, "%s", ObjName );
a2891 1
#endif
d2952 1
a2952 1
    
d2957 1
a2957 1
#endif   
d3027 1
a3027 1
	  if (is_full_norcroft( compiler ))
d3032 1
a3032 1
	  if (is_full_norcroft( compiler ))
d3052 1
a3052 1
	  if (is_full_norcroft( compiler ))
d3122 1
a3122 1
	  if (is_full_norcroft( compiler ))
d3197 1
a3197 1
      if (is_full_norcroft( compiler ))
d3219 2
a3220 1
      if (VERBOSE && is_full_norcroft( compiler )) strcat( buf, "s" );
d3280 1
a3280 1
  if (is_full_norcroft( compiler ))
a3677 1
#ifdef __ARM
a3678 1
#endif
d3806 3
d3817 6
a3822 1
      AddName( &MacroOpts, "-dhelios.TRAN 1 -d__TRAN 1 -d__HELIOSTRAN 1 -d__HELIOS 1" );
d3829 6
a3834 1
      AddName( &MacroOpts, "-dhelios.arm 1 -d__ARM 1 -d__HELIOSARM 1 -D__SMT 1 -d__HELIOS 1" );
d3841 6
a3846 1
      AddName( &MacroOpts, "-dhelios.C40 1 -d__C40 1 -d__HELIOSC40 1 -D__SMT 1 -d__HELIOS 1" );
d3852 6
a3857 1
      AddName( &MacroOpts, "-dhelios.I860 1 -d__I860 1 -d__HELIOSI860 1 -d__HELIOS 1" );
d3888 1
a3888 1
  if (is_full_norcroft( compiler ))
@


1.72
log
@added new warnings and features
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.71 $
 * RCS date:    $Date: 1992/07/10 08:29:58 $
d3814 1
d3821 1
d3828 1
d3834 1
@


1.71
log
@fixed typo in help message
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.70 $
 * RCS date:    $Date: 1992/07/08 08:56:15 $
d249 1
a249 1
#define PRE_PROCESSOR		"/helios/local/bin/cpp"
d374 1
a374 1
  
d404 1
a404 1
  }
d417 1
a417 1
  }
d461 1
a461 1
			
d531 6
a536 4
#define WARN_n		(1 << 3)
#define WARN_p		(1 << 4)
#define WARN_s		(1 << 5)
#define WARN_v		(1 << 6)
d548 12
a559 10
#define FEAT_f		(1 << 0)
#define FEAT_g		(1 << 1)
#define FEAT_h		(1 << 2)
#define FEAT_m		(1 << 3)
#define FEAT_n		(1 << 4)
#define FEAT_p		(1 << 5)
#define FEAT_s		(1 << 6)
#define FEAT_u		(1 << 7)
#define FEAT_v		(1 << 8)

d599 2
a600 2
	char * format;
	va_dcl
d602 3
a604 3
/*
 * print an debugging message
 */
d607 2
a608 2
    
    
d614 1
a614 1
    
d616 1
a616 1
    
d618 1
a618 1

d623 1
a623 1
    
d625 1
a625 1
    
d627 1
a627 1
    
d629 1
a629 1

d633 1
a633 2


d635 1
d639 1
a639 1
error( char * format, ... )
d642 2
a643 2
	char *	format;
	va_dcl
d645 3
a647 3
/*
 * print an error message
 */
d650 2
a651 2
    
    
d657 1
a657 1
    
d659 1
a659 1
    
d661 1
a661 1
    
d663 1
a663 1
    
d665 1
a665 1
    
d667 1
a667 1
    
d669 1
a669 1

d674 1
a674 1

d677 1
a677 1
warning( char * format, ... )
d680 2
a681 2
	char *	format;
	va_dcl
d683 3
a685 3
/*
 * print a warning message
 */
d688 2
a689 2
    
    
d695 1
a695 1
    
d697 1
a697 1
    
d699 1
a699 1
    
d704 1
a704 1
    
d706 1
a706 1
    
d708 1
a708 1
    
d710 1
a710 1

d715 1
a715 1

d718 1
a718 1
fail( char * format, ... )
d721 2
a722 2
	char *	format;
	va_dcl
d724 3
a726 3
/*
 * print a reason message and terminate
 */
d729 2
a730 2
    

d738 1
a738 1
    
d748 1
a748 1
    
d750 1
a750 1
    
d752 1
a752 1

d754 1
a754 1
    
d757 1
a757 1

d760 1
a760 1
SafeAlloc( unsigned long size )
d765 3
a767 3
/*
 * allocate 'size' bytes of memory or fail
 */
d770 2
a771 2
    
    
d776 1
a776 1
    
d778 1
a778 1
    
d781 1
a781 1

d783 1
a783 1
usage(
d785 1
a785 1
      void
d787 4
a790 4
      )
/*
 * describe the options to this utility
 */
d795 2
a796 2
    
    
d798 1
a798 1
    
d800 1
a800 1
    
d859 1
a859 1
  error( "-v            Verify command being executed." );
d865 2
d869 1
d884 2
d887 1
a887 1
  error( "                'g' removes procedure names from the code (transputer)," );
d894 1
a894 1
  error( "                'v' warns of unused functions and variables during compilation," );
d989 1
a989 1

d994 1
a994 1

d998 1
a998 1

d1001 1
a1001 1
FirstNode( List * plist )
d1006 3
a1008 3
/*
 * returns the first node in the given list or NULL if the list is empty
 */
d1016 1
a1016 1

d1018 1
a1018 1
    
d1021 1
a1021 1

d1024 1
a1024 1
NextNode( Node * pnode )
d1029 4
a1032 4
/*
 * returns the next node in the list containing 'pnode' or NULL if this
 * is the last node in the list or the node is not attached to a list
 */
d1042 1
a1042 1
    
d1045 1
a1045 1

d1048 1
a1048 1
ListSize( List * plist )
d1053 3
a1055 3
/*
 * returns the number of elements in the list provided
 */
d1059 2
a1060 2
    
    
d1063 1
a1063 1
    
d1065 1
a1065 1
    
d1068 1
a1068 1

d1071 1
a1071 1
DupName( char * pname )
d1076 3
a1078 3
/*
 * returns a copy of the string provided
 */
d1088 2
a1089 2


d1092 3
a1094 3
AddName(
	NameList *	plist,
	char *		pname )
d1100 3
a1102 3
/*
 * add a new node to the list containing the string 'name'
 */	
d1105 1
a1105 1

d1122 1
a1122 1

d1126 1
a1126 1

d1128 1
a1128 1

d1130 1
a1130 1

d1137 1
a1137 1

d1140 1
a1140 1

d1160 1
a1160 1

d1162 1
a1162 1

d1172 1
a1172 1

d1179 1
a1179 1

d1181 1
a1181 1

d1186 1
a1186 1

d1189 3
a1191 3
RemoveName(
	   NameList *	plist,
	   char * 	pname )
d1197 5
a1201 5
/*
 * remove a name from the given list
 * returns TRUE upon success, FALSE otherwise
 * only removes the first occurance of pname
 */
d1204 2
a1205 2


d1213 1
a1213 1

d1215 1
a1215 1

d1219 1
a1219 1

d1224 1
a1224 1

d1227 3
a1229 3
AddNameToFront(
	       NameList *	plist,
	       char *		pname )
d1235 4
a1238 4
/*
 * add a new node to the list containing the string 'name'
 * name is added to the head of the list
 */	
d1241 2
a1242 2
    
    
d1244 1
a1244 1
    
d1249 1
a1249 1
    
d1251 1
a1251 1

d1256 1
a1256 1

d1259 4
a1262 4
AddNamef(
	 NameList *	plist,
	 char *		format,
	 ... )
d1265 3
a1267 3
	 NameList *	plist;
	 char *		format;
	 va_dcl
d1269 3
a1271 3
/*
 * adds a node to a list containing a constructed string
 */	
d1275 2
a1276 2
    
    
d1282 1
a1282 1

d1284 1
a1284 1

d1286 1
a1286 1
    
d1288 1
a1288 1

d1293 1
a1293 1

d1296 4
a1299 4
AddLibraryName(
	       bool	resident,
	       char * 	format,
	       ... )
d1306 3
a1308 3
/*
 * adds a name to the Library Name list
 */	
d1314 2
a1315 2
    

d1326 1
a1326 1
    
d1332 1
a1332 1

d1334 1
a1334 1

d1336 1
a1336 1
    
d1338 1
a1338 1
    
d1346 1
a1346 1
    
d1350 1
a1350 1
	
d1353 1
a1353 1

d1358 1
a1358 1

d1361 3
a1363 3
AddFile(
	FileList *	plist,
	char *		file )
d1369 4
a1372 4
/*
 * adds a file name to the the file name list
 * seperates the filename and extension
 */	
d1377 2
a1378 2
    
    
d1388 1
a1388 1
    
d1390 1
a1390 1
    
d1399 1
a1399 1
    
d1403 1
a1403 1
    
d1405 1
a1405 1
    
d1407 1
a1407 1

d1412 1
a1412 1

d1415 4
a1418 4
AddNames(
	 NameList *	nlist,
	 char *		format,
	 NameList *	plist )
d1425 3
a1427 3
/*
 * merge two name lists
 */	
d1430 2
a1431 2
    
    
d1438 1
a1438 1

d1443 1
a1443 1

d1446 4
a1449 4
AddFiles(
	 NameList *	nlist,
	 char *		format,
	 FileList *	plist )
d1456 3
a1458 3
/*
 * merge two file name lists
 */	
d1461 2
a1462 2
    
    
d1469 1
a1469 1

d1474 1
a1474 1

d1481 2
a1482 2


d1485 3
a1487 3
AddLibrary(
	   char *	dir,
	   char *	stem )
d1493 5
a1497 5
/*
 * search for a library called 'stem' in directory 'dir'
 * if the library is found, add its name to the library list
 * returns true iff the library was found, false otherwise
 */
d1503 1
a1503 1
   
d1507 1
a1507 1
	
d1509 1
a1509 1
	
d1513 2
a1514 2
	    
	    
d1528 1
a1528 1
	
d1531 1
a1531 1
        
d1533 1
a1533 1
	
d1536 1
a1536 1
	
d1538 1
a1538 1
	
d1541 1
a1541 1
	
d1543 1
a1543 1
	
d1546 1
a1546 1
	
d1548 1
a1548 1
	
d1551 1
a1551 1
	
d1553 1
a1553 1
	
d1556 1
a1556 1
	
d1562 1
a1562 1
	    
d1568 1
a1568 1
	    
d1572 1
a1572 1
    
d1574 3
a1576 3
    
got_resident:

d1583 1
a1583 1

d1587 1
a1587 1

d1590 1
a1590 1
got_scanned:
d1597 1
a1597 1

d1599 1
a1599 1

d1601 1
a1601 1
    
d1676 1
a1676 1
    
d2610 1
a2610 1
#ifndef __ARM
d2612 1
a2613 1
#endif
d2999 1
a2999 1
	      Warns = WARN_a | WARN_d | WARN_f | WARN_n | WARN_p | WARN_v;
d3021 1
a3021 1
	case 'f':
d3025 8
a3032 2
	case 'n':
	  Warns |= WARN_n;
d3034 1
a3034 1
	  
d3050 5
d3099 1
a3099 1

d3101 1
a3101 2
	      Feats |= FEAT_s;
	      break;
d3105 10
d3116 2
a3117 1
	  Feats |= FEAT_f;
d3121 4
a3124 1
	  Feats |= FEAT_g;
a3186 1
      if ((Warns & WARN_n) != 0) strcat( buf, "n" );
d3190 1
a3190 1
      
d3212 1
d3217 6
d3226 5
d3233 2
a3234 5
	  if (compiler != UNKNOWN_COMPILER)
	    AddName( &CompileOpts, "-Zpg0" );
	  else
	    AddName( &CompileOpts, "-pg0" );
	}	
@


1.70
log
@fixed incorrect assumption of new transputer compiler status
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.69 $
 * RCS date:    $Date: 1992/07/06 16:44:41 $
d963 1
a963 1
  error( "        TRAN  For the Helios Transouter C compiler (the default)" );
@


1.69
log
@removed spurious debug and fixed AMPP compilation
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.68 $
 * RCS date:    $Date: 1992/06/26 16:21:33 $
a3659 4

#elif defined __TRAN
  
  compiler = TRANSPUTER_COMPILER;
@


1.68
log
@Fixed to run on sparky, again
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.67 $
 * RCS date:    $Date: 1992/06/25 14:25:17 $
d16 2
a17 2
#define REVISION	58
#define DATE		24/3/92
d135 2
d231 1
a231 1
#define SHELL		"/bin/sh"
d235 1
a235 1
#define PRE_PROCESSOR	"/lib/cpp"
d239 1
a239 1
#define REMOVER		"/bin/rm"
d245 1
a245 1
#define SHELL		"/helios/bin/shell"
d249 1
a249 1
#define PRE_PROCESSOR	"/helios/local/bin/cpp"
d253 1
a253 1
#define REMOVER		"/helios/bin/rm"
d258 16
d275 5
a279 1
#define C_COMPILER	"/helios/bin/cc"
d283 1
a283 1
#define F77_PASS1	"/helios/bin/f77p1"
d287 1
a287 1
#define F77_PASS2	"/helios/bin/f77p2"
d291 1
a291 1
#define M2_COMPILER	"/helios/bin/mc"
d295 17
a311 1
#define ASSEMBLER	"/helios/bin/asm"
d315 5
a319 1
#define LINKER		"/helios/bin/asm"
d323 1
a323 1
#define MACRO		"/helios/bin/ampp"
d327 1
a327 1
#define C_LIBDIR	"/helios/lib/"
d331 1
a331 1
#define C_INCDIR	"/helios/include/"
d335 1
a335 1
#define MACDIR		"/helios/include/ampp/"
d339 1
a339 1
#define SYMDIR		"/helios/symbols/"
d344 1
a344 1
#    define CAT		"cat"
d348 7
a354 7
#define LINK_HELIOS	"helios.lib"
#define LINK_CSTART	"c0.o"
#define LINK_CLIB	"c.lib"
#define LINK_FSTART	"fstart.o"
#define LINK_M2START	"m2start.o"
#define BASIC		"basic.m"
#define OBJNAME		"a.out"
d357 1
a357 1
#  define MACHINENAME	"ARM"
d360 1
a360 1
#  define MACHINENAME	"i860"
d363 1
a363 1
#  define MACHINENAME	"TRANSPUTER"
d366 1
a366 1
#  define MACHINENAME	"TMS320C40"
d369 1
a369 1
#  define MACHINENAME	"Unknown_CPU_type"
a587 1

a2731 2
	      warning( "assembling" );
	      
d2747 7
d3616 2
a3629 1
  get_var( c_compiler,    "C_COMPILER",    C_COMPILER    );
a3637 1
  get_var( linker,        "LINKER",        LINKER        );
d3682 3
a3684 1

d3688 3
a3690 1

d3697 2
d3706 2
d3714 3
d3721 5
d3727 3
@


1.67
log
@fixed output redirection
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.66 $
 * RCS date:    $Date: 1992/06/25 10:47:20 $
d320 1
a320 1
#ifdef __TRAN
d327 1
a327 1
#  define MACHINENAME	"Unknown CPU type"
@


1.66
log
@fixed norcroft style to allow for compiler output to stdout
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.65 $
 * RCS date:    $Date: 1992/06/24 17:06:20 $
d481 1
d483 1
d2165 1
a2165 1
	  else if (streq( ObjName, OBJNAME ) || !(Flags & FLAG_c))
d2180 1
a2180 1
  else if (is_full_norcroft( compiler ))
d2188 2
a2189 2
	  
      AddName( plist, "-" );      
@


1.65
log
@fixed bug for Norcroft compilers
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.64 $
 * RCS date:    $Date: 1992/06/24 08:51:04 $
d2177 11
@


1.64
log
@fixed compiler warnings
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.63 $
 * RCS date:    $Date: 1992/06/15 11:58:56 $
d3746 3
a4130 3
	      if (is_full_norcroft( compiler ))
		AddName( &CompileOpts, "-c" );
		
d4499 1
a4499 1

@


1.63
log
@fixed for std proc names
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.62 $
 * RCS date:    $Date: 1992/03/30 11:52:48 $
d722 1
a722 1
  char *	ptr = (char *)malloc( size );
d1028 1
a1028 1
  char *	ptr = SafeAlloc( strlen( pname ) + 1 );
d1075 1
a1075 1
      pnew->name = pcopy = SafeAlloc( strlen( pname ) + 1 + count );
d1620 1
a1620 1
  char **	argv 	= (char **)SafeAlloc( (argc + 1) * sizeof( char * ) );
@


1.62
log
@tidied up process creation
,
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.53 $
 * RCS date:    $Date: 1992/02/13 13:51:55 $
d3598 1
a3598 1
#if   defined __HELIOSARM
d3602 1
a3602 1
#elif defined __HELIOSTRAN
d3606 1
a3606 1
#elif defined __HELIOSC40
d3610 1
a3610 1
#elif defined __HELIOSI860
@


1.61
log
@fixed typo in generation of features
@
text
@d1913 1
a1913 1
      
a1917 3
	  int	return_code;

	  
d1930 1
a1930 1

d1933 1
a1933 5
	  return_code = execvp( argv[ 0 ], argv );

	  /* oops, failed */
	  
	  _exit( return_code );
a1935 4
      /* mark first command line as used */
      
      command_line[ 0 ]  = '\0';

d1940 1
a1940 1
	  fail( "Failed to execute %s", argv );
a1950 3
	  int	return_code;
	

d1966 1
a1966 5
	  return_code = execvp( argv[ 0 ], argv );

	  /* oops, failed */
	  
	  _exit( return_code );
a1968 4
      /* reset the second command line */
      
      command_line2[ 0 ] = '\0';

d1973 1
a1973 1
	  fail( "Failed to execute %s", argv );
d2009 10
d2047 1
a2047 6
	  int	return_code;
	
	  
	  return_code = execvp( argv[ 0 ], argv );
	  
	  _exit( return_code );
a2049 2
      command_line[ 0 ]  = '\0';
    
d2052 1
a2052 1
	  fail( "Failed to execute %s", argv );
d2063 4
a2068 5
  if (result != 0)
    {
      warning( "Failed because %s exited with return code of %d", argv, result );
    }
  
d2073 5
@


1.60
log
@extended new process starting code
@
text
@d3146 2
a3148 2
	  else
	    AddName( &CompileOpts, "-Zpg0" );
@


1.59
log
@added code to run two seperate processes for C_NONSTANDARD
and to handle signals myself
@
text
@d683 3
a685 1
    
d705 1
a705 1
    
d1866 2
a1877 1
      void (*	old_handler)();
a1879 1
      char **	argv;
a2034 4

      /* reset signal handler */

      (void) signal( SIGINT, old_handler );
d2050 7
d2059 1
a2059 2
	  char *	name;
	  int		return_code;
d2062 1
a2062 4
	  if ((name = strrchr( shell, '/' )) == NULL)
	    {
	      name = shell;
	    }
a2063 2
	  return_code = execlp( shell, name, "-c", command_line, NULL );
	  
d2071 1
a2071 1
	  fail( "Failed to execute %s", shell );
d2086 1
a2086 1
      warning( "Failed because %s exited with return code of %d", shell, result );
d2088 4
@


1.58
log
@better determination of machine name
@
text
@d210 1
d1599 2
a1600 1
static char 	command_line[ 1024 ];		/* XXX */
d1620 2
a1622 1
    
d1625 3
a1627 1
      strcat( command_line, "| " );
d1629 4
d1644 2
a1645 2
	  strcat( command_line, pnode->name );
	  strcat( command_line, " " );
d1714 2
a1715 1
  command_line[ 0 ] = '\0';
d1749 102
a1851 1
ExecuteCommandLine(
d1853 3
a1855 1
		   void
a1856 1
		   )
d1862 1
d1864 2
a1865 1
  int		result 	= -1;
a1866 3
#ifdef __ARM
  if (command_line[ 0 ] == '\0')
#else
a1867 1
#endif
d1871 2
a1872 2
    
  if (VERIFY)
d1874 11
a1884 2
      printf( "%s\n", command_line );
    }
d1886 4
a1889 3
  if (!EXECUTE)
    {
      command_line[ 0 ] = '\0';
d1891 70
a1960 7
      return 0;
    }
    
  if ((pid = vfork()) == 0)
    {
      char *	name;
      int	return_code;
d1962 30
a1991 2
	
      if ((name = strrchr( shell, '/' )) == NULL)
d1993 1
a1993 1
	  name = shell;
d1995 19
d2015 22
a2036 3
      return_code = execlp( shell, name, "-c", command_line, NULL );
	
      _exit( return_code );
d2038 6
d2045 6
a2050 1
  command_line[ 0 ] = '\0';
d2052 17
a2068 4
  if (pid == -1)
    {
      fail( "Failed to execute %s", shell );
    }
d2070 4
a2073 2
  while (wait( &result ) == -1 && errno == EINTR)
    ;
d2075 10
d2089 1
a2089 1
    
@


1.57
log
@added support for the C40
@
text
@d3346 1
a3346 1

d3348 1
d3354 3
d3361 3
d3368 3
d3372 5
d3415 4
a3444 2
  
  AddName( &Defines, machinename );
@


1.56
log
@fixed addition of strings containing double quotes to defines list
@
text
@d16 2
a17 2
#define REVISION	57
#define DATE		12/2/92
d133 2
a147 6
#ifdef __ARM
#  ifndef NCC
#    define NCC
#  endif
#endif /* __ARM */

d330 3
d367 10
d450 1
a450 1
static bool		new_ncc = false;
d506 4
a509 3
#define FEAT_s		(1 << 5)
#define FEAT_u		(1 << 6)
#define FEAT_v		(1 << 7)
a810 3
#ifdef NCC
  error( "                not yet implemented" );
#else
a819 1
#endif /* NCC */
d830 3
a832 6
  error( "-F[Afghmnsuv] Enable compiler features :-" );
#ifdef NCC
  error( "                not yet implemented" );
#else
  error( "                'f' disables the vector stack," );
  error( "                'g' removes procedure names from the code," );
d835 2
a836 1
  error( "                'n' do not put arrays or structs on vector stack," );	
d840 1
a840 2
  error( "                'A' turns on -Fs and -Fg." );
#endif /* NCC */
d914 5
d1867 1
a1867 1
    
d1872 5
a1876 5
#ifdef NCC
	  AddName(  plist, "-o"    );
#else
	  AddName(  plist, "-s"    );
#endif
d1882 3
a1884 2
#ifdef NCC
      AddName( plist, "-o" );
d1886 12
a1897 3
      if (ASSEMBLE_ONLY)
	{
	  AddNamef( plist, "%s.s", fnode->root );
a1898 4
      else if (streq( ObjName, OBJNAME ) || !(Flags & FLAG_c))
	{
	  AddNamef( plist, "%s.o", fnode->root );
	}
d1901 2
a1902 1
	  AddNamef( plist, "%s", ObjName );
a1903 4
#else
      AddName(  plist, "-s"                );
      AddNamef( plist, "%s.s", fnode->root );
#endif      
d1912 1
a1912 2
#ifdef NCC
  if (ASSEMBLE_ONLY)
d1914 8
a1921 1
      fnode->ext  = DupName( "s" );
d1925 1
a1925 1
      fnode->ext  = DupName( "o" );
a1926 3
#else
  fnode->ext  = DupName( "s" );
#endif
d2400 4
a2403 2
#ifndef __ARM	  
	  if ((NCfiles > 1 || NAfiles > 0 || NOfiles > 0))
d2405 2
a2409 1
#endif
d2411 1
d2656 1
a2656 1
	  if (new_ncc)
d2689 1
a2689 1
	  if (new_ncc)
d2737 15
a2751 1
	  Feats |= FEAT_s | FEAT_g;
d2774 5
a2816 3
#ifdef NCC
      strcpy( buf, "-W" );
#else
a2817 1
#endif
d2832 4
a2835 5
#ifdef NCC
      strcpy( buf, "-W" );
#else
      strcpy( buf, "-e" );
#endif
a2845 3
#ifdef NCC
      strcpy( buf, "-F" );
#else
a2846 1
#endif
d2857 4
a2860 5
#ifdef __ARM
	  AddName( &CompileOpts, "-Zpg0" );
#else
	  AddName( &CompileOpts, new_ncc ? "-Zpg0" : "-pg0" );
#endif
d2865 4
a2868 5
#ifdef __ARM
          AddName( &CompileOpts, "-Zpf0" );
#else
          AddName( &CompileOpts, new_ncc ? "-Zpf0" : "-pf0" );
#endif
d2871 5
d2878 4
a2881 5
#ifdef __ARM
	  AddName( &CompileOpts, "-Zps1" );
#else
	  AddName( &CompileOpts, new_ncc ? "-Zps1" : "-ps1" );
#endif
d2905 4
a2908 5
#ifdef NCC
  AddNames( &CompileOpts, "-D%s", &Defines );
#else
  AddNames( &CompileOpts, "-d%s", &Defines );
#endif
a3122 3
#ifdef NCC
  strcpy( buffer, "-I" );
#else
a3123 1
#endif
a3142 3
#ifdef NCC
  buffer[ 4 ] = 'J';
#else
a3143 1
#endif
d3324 2
d3327 16
d3345 17
a3361 1
      new_ncc = true;
d3363 1
a3363 1
  
d3395 1
a3395 1
  AddName( &Defines, "helios" );
a3398 6
  
#ifdef __ARM
  AddName( &Defines, "__ARM" );
  AddName( &Defines, "__HELIOSARM" );
  AddName( &Defines, "__SMT" );		/* split module table */
#endif
d3400 8
a3407 5
#ifdef __C40
  AddName( &Defines, "__C40" );
  AddName( &Defines, "__HELIOSC40" );
  AddName( &Defines, "__SMT" );
#endif
d3409 5
a3413 4
#ifdef __I860
  AddName( &Defines, "__I860" );
  AddName( &Defines, "__HELIOSI860" );
#endif
d3415 12
a3426 6
#ifdef __TRAN
  AddName( &Defines, "transputer" );
  AddName( &Defines, "__TRAN" );
  AddName( &Defines, "__HELIOSTRAN" );
#endif
    
a3534 1
#ifndef NCC
a3542 1
#endif   
d3632 38
a3669 27
#if defined(__ARM) || defined(C40) || defined(I860)
              warning( "-Tn option not applicable to non transputer processors" );
#else
	      switch (arg[ 2 ])
		{
		case '8':
		  AddName( &ModulaOpts,  "-t8" );
		  AddName( &CompileOpts, "-t8" );
		  AddName( &Defines,    "T800" );
		  
		  strcat( FortranP2Opts, "+F" );
		  
		  break;
		  
		case '5':
		  AddName( &ModulaOpts,  "-t5" );
		  AddName( &CompileOpts, "-t5" );
		  AddName( &Defines,    "T400" );
		  
		  break;
		  
		case '4':
		  AddName( &ModulaOpts,  "-t4" );
		  AddName( &CompileOpts, "-t4" );
		  AddName( &Defines,    "T400" );
		  
		  break;
a3670 11
		case '\0':
		  warning( "No number after -T option, ignored" );
		  
		  break;
		  
		default:
		  warning( "Unknown transputer type -T'%c', ignored", arg[ 2 ] );
		  
		  break;
		}
#endif /* __ARM */	      
a3702 1
#ifndef NCC
d3780 1
a3780 1
#endif /* NCC */	      
d3837 4
a3840 1
	      
d3947 17
a3964 9
#if defined __ARM 
	      AddName( &CompileOpts, "-Zl");
#else
	      if (new_ncc)
		/* AddName( &CompileOpts, "-zl" ); */
		fail( "New Compiler does not support resident libraries (yet)" );    
	      else
		AddName( &CompileOpts, "-l" );
		
d3968 1
a3968 1
#endif /* __ARM */
a4029 3
#ifdef NCC	      
	      AddName( &CompileOpts, "-P" );
#else
d4031 1
a4031 1
#endif
d4045 19
a4063 11
	      
#ifdef __ARM
	      AddName( &CompileOpts, "-Zr" );  
#else
	      if (new_ncc)
		fail( "New Compiler does not support device drivers (yet)" );    
	        /* AddName( &CompileOpts, "-zr" ); */
	      else
		AddName( &CompileOpts, "-r" );
		
#endif /* __ARM */	      
a4122 1
#ifndef NCC
a4124 1
#endif   
@


1.55
log
@added support (or not) for resideent libraries and device drivers with new compiler
@
text
@a1041 3
    
    
  pnew->name = DupName( pname );
d1043 67
d3453 1
a3453 1
		  
@


1.54
log
@fixed generation of features for new Norcroft compiler
@
text
@d3825 1
a3825 1
#ifdef __ARM
d3828 6
a3833 2
	      AddName( &CompileOpts, "-l" );
	      
d3921 6
a3926 1
	      AddName( &CompileOpts, "-r" );
@


1.53
log
@added new option (enabled by NEW_NCC in environment) which makes compiler
compatible with the new Norcroft compiler
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.52 $
 * RCS date:    $Date: 1991/11/12 12:34:14 $
d2768 1
a2768 1
	  AddName( &CompileOpts, "-pg0" );
d2777 1
a2777 1
          AddName( &CompileOpts, "-pf0" );
d2786 1
a2786 1
	  AddName( &CompileOpts, "-ps1" );
@


1.52
log
@added definition of EXIT_SUCCESS and EXIT_FAILURE - not standard across
all platforms
@
text
@d8 1
a8 1
 * This code is Copyright (c) 1990, 1991 Perihelion Software Ltd.
d11 2
a12 2
 * RCS version: $Revision: 1.51 $
 * RCS date:    $Date: 1991/11/12 11:53:42 $
d16 2
a17 2
#define REVISION	56
#define DATE		12/11/91
d131 2
d160 3
a162 3
#define bool 	int
#define false 	0
#define true  	1
d164 2
a165 2
#define TRUE  	1
#define FALSE 	0
d339 5
a343 3
{
  Node 		node;
  char *	name;
a344 2
} NameNode;

d348 8
a355 6
{
  Node 		node;
  char *	ext;		/* extension */
  char *	oext;		/* original extension */
  char *	root;		/* name of file less extension */
  char *	base;		/* name of file less directory and extension */
a356 2
} FileNode;

d358 6
a363 4
{
  normal,
  objed_suppressed,
  objed_enabled
a364 2
} State;

d441 2
d477 4
a480 2
#define WARN_s		(1 << 3)
#define WARN_v		(1 << 4)
d2574 10
a2583 2
	  Warns = ~0;
	  Errs  = ~0;
d2590 4
d2601 4
d2606 11
a2624 8
	case 'c':
	  Errs  |= ERR_c;
	  break;
	  
	case 'p':
	  Errs  |= ERR_p;
	  break;
	  
d2725 2
d3238 5
@


1.51
log
@fixed return codes so that they conform to the POSIX specification
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.50 $
 * RCS date:    $Date: 1991/10/14 09:41:45 $
d213 8
d3171 1
a3171 1
  bool		succeded = TRUE;
d4106 1
a4106 1
  succeded = DoCompiles();
d4108 1
a4108 1
  if (succeded && ASSEMBLE)
d4111 1
a4111 1
	succeded |= DoAssembles();
d4115 1
a4115 1
      if (NSources != NDfiles && LINK && succeded)
d4117 1
a4117 1
	  succeded = DoLink();
d4121 1
a4121 1
  if (succeded && USE_PIPE)
d4123 1
a4123 1
      succeded = (ExecuteCommandLine() == 0);
d4126 1
a4126 1
  return (succeded ? EXIT_SUCCESS : EXIT_FAILURE);
@


1.50
log
@cleaned up for C40 and new names for linkers + -D__SMT
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.49 $
 * RCS date:    $Date: 1991/09/27 15:08:04 $
d16 2
a17 2
#define REVISION	55
#define DATE		26/09/91
d129 2
d4118 1
a4118 1
  return (succeded ? 0 : -1);
@


1.49
log
@removed generation of -b C compiler switch as this is no longer needed
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.48 $
 * RCS date:    $Date: 1991/09/02 11:21:15 $
d132 1
a132 1
#define const
d136 2
a137 7

#ifndef __ARM
#define __ARM
#endif

#define SEEK_END 2
#define L_tmpnam 25
a139 1

d143 3
a145 5

#ifndef NCC
#define NCC
#endif

d292 3
a294 5

#ifndef CAT
#define CAT		"cat"
#endif

d306 13
a318 3
#define MACHINENAME	"ARM"
#else
#define MACHINENAME	"TRANSPUTER"
d1601 1
a1601 1
#ifdef __STDC__
d1603 1
a1603 1
#else
d1606 1
a1606 1
#endif
a3239 1

d3242 8
d3251 4
a3254 1
#else
d3256 1
a3258 3

  /* shorthand for both */
  
d3260 1
a3260 2

#endif /* __ARM */
d3469 2
a3470 2
#ifdef __ARM	      
              warning( "-Tn option not available on ARM" );
@


1.48
log
@now passes -g (debugging) option to Fortran compiler
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.47 $
 * RCS date:    $Date: 1991/06/07 14:48:17 $
d16 2
a17 2
#define REVISION	54
#define DATE		06/06/91
d128 1
a3160 3
#ifndef __ARM
  int		byteswap = *((char *)&i) == '\001';
#endif
a3228 7
#ifndef __ARM
  if (byteswap)
    {
      AddName( &CompileOpts, "-b" );
    }
#endif
  
@


1.47
log
@Sings, dances, but doesn't work ... fixed new ARM problems
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.46 $
 * RCS date:    $Date: 91/06/05 16:50:28 $
d3736 2
@


1.46
log
@integrated with Ben and Bart changes in deltas 1.44 and 1.43
now sings, dances AND makes the tea
@
text
@d11 2
a12 2
 * RCS version: $Revision$
 * RCS date:    $Date$
d1029 1
d1034 2
a1035 1
    
d1664 3
a1666 1
    
d1668 1
@


1.45
log
@added -u option to prevent intermediary files from being deleted
added -Fu to report about unused functions detected by the linker
improved the library scanning code to cope with pathnames
@
text
@d16 2
a17 2
#define REVISION	52
#define DATE		28/05/91
d124 4
d134 21
d157 17
a173 1
#ifndef UNIX
d175 8
d185 1
a185 1
#include <stdlib.h>
d187 3
d191 1
a191 1
#include <queue.h>
a192 1
#include <string.h>
d197 1
d199 3
d203 1
d207 7
d222 2
d225 2
d228 3
d232 3
d236 5
a240 1
#else
d242 3
d246 3
d251 4
d256 1
d258 1
d260 3
d264 3
d268 3
d272 3
d276 3
d280 3
d284 22
a310 3
#define C_INCDIR	"/helios/include/"
#define MACDIR		"/helios/include/ampp/"
#define SYMDIR		"/helios/symbols/"
d313 4
d318 1
d406 3
d447 1
d501 3
d505 7
d520 1
d522 5
d534 1
d536 3
d563 1
d565 5
d577 1
d579 3
d601 1
d603 5
d615 1
d617 3
d642 1
d644 5
d656 1
d658 3
d682 1
d684 4
d706 5
a710 1
usage( void )
d750 1
d752 1
d755 1
d758 1
d764 1
d766 1
d784 3
d796 1
d801 1
d803 1
d808 3
d820 1
d823 1
d825 1
d827 1
d829 1
d832 1
d835 1
d837 1
d839 1
d842 1
d844 1
d853 1
d857 1
d864 1
d868 1
d870 3
d879 1
d881 1
d885 1
d888 1
d920 1
d922 4
d943 6
a948 1
NextNode( Node * node )
d950 1
a950 1
 * returns the next node in the list containing 'node' or NULL if this
d954 3
a956 3
  if (node 		== Null( Node ) ||
      node->Next 	== Null( Node ) ||
      node->Next->Next 	== Null( Node ) )
d961 1
a961 1
  return node->Next;
d967 1
d969 4
d990 6
a995 1
DupName( char * name )
d1000 1
a1000 1
  char *	ptr = SafeAlloc( strlen( name ) + 1 );
d1003 1
a1003 1
  strcpy( ptr, name );
d1011 1
d1014 6
a1019 1
	char *		name )
d1024 1
a1024 1
  NameNode *	new = NEW( NameNode );
d1027 3
a1029 3
  new->name = DupName( name );
    
  if (strchr( name, ' ' ))
d1031 1
a1031 1
      warning( "blank(s) found in argument '%s'", name );
d1034 1
a1034 1
  AddTail( (List *)plist, (Node *)new );
d1042 1
d1046 5
d1080 1
d1083 6
a1088 1
	       char *		name )
d1094 1
a1094 1
  NameNode *	new = NEW( NameNode );
d1097 1
a1097 1
  new->name = DupName( name );
d1099 1
a1099 1
  if (strchr( name, ' ' ))
d1101 1
a1101 1
      warning( "blank(s) found in argument '%s'", name );
d1104 1
a1104 1
  AddHead( (List *)plist, (Node *)new );
d1112 1
d1117 6
d1131 6
a1136 1
  va_start( args,   format );
d1138 1
d1149 1
d1154 6
d1181 6
a1186 1
  va_start( args,   format );
d1188 1
d1214 1
d1218 5
d1268 1
d1273 6
d1299 1
d1304 6
d1338 1
d1342 5
d1350 1
d1460 1
d1462 4
d1510 1
d1512 4
d1596 1
d1598 6
a1603 1
ExecuteCommandLine( void )
d1605 50
d1722 1
d1724 4
d1752 1
d1754 4
d1778 3
d1782 1
d1788 16
d1806 1
d1815 10
d1826 1
d1834 1
d1836 4
d1873 1
d1875 4
d1998 1
d2000 4
d2028 1
d2030 4
d2102 1
d2104 4
d2154 1
d2156 4
d2172 3
a2174 1
  AddNamef( plist, "%s", assembler     );
d2177 1
d2184 1
d2189 1
d2195 3
d2199 1
d2259 5
a2263 1
DoCompiles( void )
d2300 1
a2300 1
	  
d2306 1
a2306 1
	  
d2308 1
a2308 1
	  
d2313 1
a2313 1
	  
d2329 3
d2348 1
a2348 1
	  
d2359 5
a2363 1
DoAssembles( void )
d2394 5
a2398 1
DoLink( void )
a2410 3
  AddNamef( plist, "%s", linker    );
  AddNames( plist, "%s", &LinkOpts );
  
d2413 15
d2445 1
d2449 3
d2499 1
a2499 1

d2507 6
a2512 1
  result = ExecuteList( plist );
d2537 1
d2539 4
d2599 1
d2601 4
d2660 5
a2664 1
AddWarningsAndFeatures( void )
d2675 3
d2679 1
d2692 3
d2696 2
d2707 3
d2711 1
d2722 3
d2726 1
d2731 5
a2735 1
	  AddName( &CompileOpts, "-pf0" );
d2740 3
d2744 1
d2759 5
a2763 1
AddDefines( void )
d2768 3
d2772 1
d2780 1
d2782 4
d2843 1
d2845 4
d2906 1
d2908 4
d2971 5
a2975 1
AddIncludeOpts( void )
d2987 3
d2991 1
d3011 3
d3015 1
d3025 8
a3032 1
AddSymbolOpts( void )
d3061 5
a3065 1
CountSources( void )
d3141 1
d3145 5
d3155 1
d3157 1
d3177 3
d3225 2
a3226 1
  
d3231 1
d3243 7
d3252 1
a3252 1
  
d3256 3
a3258 1
  
d3367 1
a3367 1

d3376 1
a3376 1
	      
d3398 1
a3398 1
	      
d3405 1
a3406 1
	      
d3466 3
a3468 1
	      
d3504 1
a3504 1
	      
d3537 1
a3537 1

d3615 1
a3615 1
	      
d3681 1
a3681 1
	      
d3706 1
a3706 1
	      
d3778 3
d3786 1
a3786 1
	      
d3847 4
a3850 2
	    case 'p': /* compile for profiling */
	      
d3852 1
a3852 1
	      
d3867 3
d3871 1
a3871 1
	      
d3931 1
a3931 1

d3934 1
a3934 1
	      
d4020 1
d4022 1
d4069 4
a4072 1
      AddLibrary( c_libdir, link_helios );
d4074 16
@


1.44
log
@Cured -o<name> bug in ARM version
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.43 $
 * RCS date:    $Date: 1991/05/07 14:42:40 $
d16 2
a17 2
#define REVISION	51
#define DATE		21/03/91
d120 3
a122 1
 * 52 - can now be used as a host utility on Sun4 etc.
a123 2
 * 53 - moved all machine dependent defines to makefile
 *
a129 19
#ifdef R140
#ifndef __ARM
#define __ARM
#endif

#define SEEK_END 2
#define L_tmpnam 25
typedef	int	pid_t;
extern int	errno;


#endif

#ifdef __ARM
#ifndef NCC
#define NCC
#endif
#endif

a133 9
#include <queue.h>
#else
#define bool int
#define false 0
#define FALSE 0
#define true  1
#define TRUE  1
#define Null(a) ((a *) NULL)
#include "queue.h"
a135 1
#ifndef R140
a136 5
#else
#include <sys/types.h>
#endif

#ifdef __STDC__
a137 3
#else
#include <varargs.h>
#endif
d139 2
a146 1
#ifndef R140
a150 1
#endif
d159 5
a163 3
/* NB defines below are default values; should be defined in m. dep makefile. */

#ifndef SHELL
d165 2
a167 2

#ifndef C_COMPILER
a168 1
#endif
a169 5
#ifndef PRE_PROCESSOR
#define PRE_PROCESSOR	"/helios/local/bin/cpp"
#endif

#ifndef F77_PASS1
a170 3
#endif

#ifndef F77_PASS2
a171 3
#endif

#ifndef M2_COMPILER
a172 15
#endif

#ifdef __ARM

#ifndef CAT
#define CAT		"cat"
#endif

#endif

#ifndef REMOVER
#define REMOVER		"/helios/bin/rm"
#endif

#ifndef ASSEMBLER
a173 3
#endif

#ifndef LINKER
d175 1
a175 7
#endif

#ifndef AMPP
#define AMPP		"/helios/bin/ampp"
#endif

#ifndef C_LIBDIR
a176 15
#endif

#ifndef C_INCDIR
#define C_INCDIR	"/helios/include/"
#endif

#ifndef MACDIR
#define MACDIR		"/helios/include/ampp/"
#endif

#ifndef SYMDIR
#define SYMDIR		"/helios/symbols/"
#endif


d182 3
a186 3
#ifdef __ARM
#define MACHINENAME	"ARM"
#else
a187 1
#endif
d189 1
d231 2
a232 1
static NameList		LibraryNames;
d269 1
a274 3
#ifdef __ARM
static char *		cat;
#endif
d284 1
a284 1
static char *		libdir;
d286 1
a286 1
static char *		incdir;
d346 2
a347 1
#define FEAT_v		(1 << 6)
a348 1

a365 8
/*
 * prototypes
 */
#ifdef __STDC__
static int ExecuteCommandLine(void);
#else
static int ExecuteCommandLine();
#endif
d372 2
a374 1
#ifdef __STDC__
a375 5
#else
debug( format, va_alist )
	char * format;
	va_dcl
#endif
d382 1
a382 2

#ifdef __STDC__    
a383 3
#else
  va_start( args );
#endif
d405 2
a407 1
#ifdef __STDC__
a408 5
#else
error( format, va_alist )
	char *	format;
	va_dcl
#endif
d415 1
a415 2

#ifdef __STDC__    
a416 3
#else
  va_start( args );
#endif
a435 1
#ifdef __STDC__
a436 5
#else
warning( format, va_alist )
	char *	format;
	va_dcl
#endif
a443 1
#ifdef __STDC__    
a444 3
#else
  va_start( args );
#endif
a466 1
#ifdef __STDC__
a467 5
#else
fail( format, va_alist )
	char *	format;
	va_dcl
#endif
a474 1
#ifdef __STDC__    
a475 3
#else
  va_start( args );
#endif
d497 1
a497 2
SafeAlloc( size )
unsigned long size;
d516 1
a516 1
usage( )
a555 1
#ifndef __ARM
a556 1
#endif
a558 1
#ifndef __ARM
a560 1
#endif
a565 1
#ifndef __ARM
a566 1
#endif
d581 1
a583 1
#ifndef NCC
a592 3
#else
  error( "                not yet implemented" );
#endif
a596 1
#ifndef __ARM
a597 1
#endif
d601 1
a601 2
  error( "-F[Afghmnsv]  Enable compiler features :-" );
#ifndef NCC
d608 2
a609 1
  error( "                'v' warns of unused functions and variables," );
a610 4
#else
  error( "                not yet implemented" );
#endif

a612 1
#ifndef __ARM
a613 1
#endif
a614 1
#ifndef __ARM
a615 1
#endif
a617 1
#ifndef __ARM
a619 1
#endif
a620 1
#ifndef __ARM
a621 1
#endif
a623 1
#ifndef __ARM
d625 1
a625 2
#endif
  error( "-Wc,arg[,arg ... Pass on arguments to specific parts of the compilation." );
a632 1
#ifndef __ARM
a635 1
#endif
a641 1
#ifndef __ARM
a644 1
#endif
a645 3
#ifdef __ARM
  error( "CAT		Pathname of the cat program (for scanned libs)." );
#endif
a651 1
#ifndef __ARM
a652 2
#endif
  error( "C_LIBDIR      Pathname of the library directory." );
a655 1
#ifndef __ARM
a657 1
#endif
d689 1
a689 2
FirstNode( plist )
List *plist;
d696 1
a696 1
      plist->Head->Next 	== Null( Node ) )
d707 1
a707 2
NextNode( node )
Node *node;
d726 1
a726 2
ListSize( plist )
List *plist;
d744 1
a744 2
DupName( name )
char *name;
d760 3
a762 3
AddName( plist, name)
	NameList *	plist;
	char *		name;
d771 1
a771 3

#ifndef NCC

a775 2

#endif
d785 3
a787 3
RemoveName( plist, pname)
	   NameList *	plist;
	   char * 	pname;
d817 3
a819 3
AddNameToFront( plist, name)
	NameList *	plist;
	char *		name;
a842 1
#ifdef __STDC__
a846 6
#else
AddNamef( plist, format, va_alist )
	 NameList *	plist;
	 char *		format;
	 va_dcl
#endif
d855 1
a855 6
#ifdef __STDC__    
  va_start( args, format );
#else
  va_start( args );
#endif

a856 1

d867 4
a870 7
#ifdef __STDC__
AddLibraryName( char * format, ... )
#else
AddLibraryName( format, va_alist )
	char *	format;
	va_dcl
#endif
d877 1
a877 1
  NameList *	plibs = &LibraryNames;
d880 10
a889 1
    
d892 1
a892 6
#ifdef __STDC__    
  va_start( args, format );
#else
  va_start( args );
#endif

a893 1

d919 3
a921 3
AddFile( plist, file)
	FileList *	plist;
	char *		file;
d967 4
a970 4
AddNames( nlist, format, plist)
	 NameList *	nlist;
	 char *		format;
	 NameList *	plist;
d991 4
a994 4
AddFiles( nlist, format, plist)
	 NameList *	nlist;
	 char *		format;
	 FileList *	plist;
d1023 3
a1025 3
AddLibrary( dir, stem)
	   char *	dir;
	   char *	stem;
d1033 2
a1034 1
    
d1097 2
a1098 2
	      AddLibraryName( "%sfplib.def",  libdir );
	      AddLibraryName( "%sfpclib.def", libdir );
d1119 2
d1123 9
a1131 2
  AddLibraryName( "-l%s", buf );
    
d1138 1
a1138 2
FindAndAddLibrary( pfile_name )
char *pfile_name;
d1148 1
a1148 3
  for (pdir_name  = (NameNode *)FirstNode( (List *)pdirs );
       pdir_name != NULL;
       pdir_name  = (NameNode *)NextNode( (Node *)pdir_name ))
d1150 4
a1153 1
      if (AddLibrary( pdir_name->name, pfile_name ))
d1155 2
d1160 15
a1174 1

d1183 1
a1183 2
ExecuteList( nlist )
NameList * nlist;
a1262 43
static int
ExecuteCmdList( nlist )
NameList * nlist;
/*
 * execute the indicate command with the provided arguments
 * wait for the command to terminate and return its exit code
 */
{
  pid_t		pid;
  int		i;
  int		result 	= -1;
  NameNode *	pnode;
    
  command_line[0] = '\0';
    
  i = 0;
    
  for (pnode = (NameNode *)FirstNode( (List *)nlist );
       pnode;
       pnode = (NameNode *)NextNode( (Node *)pnode ) )
    {
      strcat( command_line, pnode->name );
      strcat( command_line, " " );
	    
      if (VERIFY)
	printf( "%s ", pnode->name );
    }
    
  if (!USE_PIPE && VERIFY)
    {
      printf( "\n" );
    }
    
  result = ExecuteCommandLine();
    
  if (result != 0)
    {
      warning( "Failed because %s exited with return code of %d", command_line, result );
    }
    
  return result;
    
} /* ExecuteCmdList */
a1263 1
#ifdef __STDC__
d1265 1
a1265 5
ExecuteCommandLine(void)
#else
static int
ExecuteCommandLine()
#endif
d1275 1
a1275 1
  if (command_line[ 0 ] == '\0')
d1334 1
a1334 2
RemoveFile( pfile )
FileNode * pfile;
d1342 4
a1345 1
    
d1359 1
a1359 2
C_Compile( fnode )
FileNode * fnode;
a1379 3
#ifdef NCC
	  AddName(  plist, "-o"    );
#else
a1380 1
#endif
d1386 2
a1387 17

#ifdef NCC
        AddName(  plist, "-o"      );

        if (Flags & FLAG_S)
                AddNamef( plist, "%s.s", fnode->root );
        else
	{
		if (streq( ObjName, OBJNAME ) || !(Flags & FLAG_c))
			AddNamef( plist, "%s.o", fnode->root );
		else
                	AddNamef( plist, "%s", ObjName );
	}
#else
      	AddName(  plist, "-s"                );
      	AddNamef( plist, "%s.s", fnode->root );
#endif
d1395 1
a1395 7

#ifdef NCC
  if (Flags & FLAG_S)
        fnode->ext  = DupName( "s" );
  else
        fnode->ext  = DupName( "o" );
#else
d1397 1
a1397 2
#endif

d1404 1
a1404 2
Pre_Process( fnode )
FileNode * fnode;
d1438 1
a1438 2
F77_Compile( fnode )
FileNode * fnode;
d1558 1
a1558 2
M2_CompileDef( fnode )
FileNode * fnode;
d1583 1
a1583 2
M2_CompileMod( fnode )
FileNode * fnode;
d1601 2
d1605 1
a1605 2
      AddName(  plist, "-w"		);
      AddName(  plist, "/ram/tmp"     );
d1609 1
a1609 2
      AddName(  plist, "-w"		);
      AddName(  plist, "/helios/tmp"	);
d1620 1
d1628 1
d1635 2
a1636 1
      extension = "o";
d1652 1
a1652 2
MacroAssemble( fnode )
FileNode * fnode;
a1692 33
#ifdef NEVER
#ifdef __ARM 
  
  InitList( plist );

  AddNamef( plist, "%s", assembler );
  
  if (REDIRECT && !ASSEMBLE)
    {
      if (ObjName != NULL)
	{
	  AddNamef( plist, "-O%s", ObjName );
	}
    }
  else if (!USE_PIPE)
    {
      AddNamef( plist, "-O%s.o", fnode->root );
    }
  
  AddNamef( plist, "-i%s", macdir );

  AddNamef( plist, "%s.s", fnode->root );

  NCompiles++;
  
  fnode->ext = DupName( "o" );

  result |= ExecuteList( plist );
  

#endif
#endif  
 
d1699 1
a1699 2
Assemble( fnode )
FileNode * fnode;
d1711 1
a1711 1

a1712 2

#ifndef __ARM
a1713 1

a1714 1
#endif
a1720 1
#ifndef __ARM
a1724 1
#endif
a1729 3
#ifdef __ARM
	  AddName( plist, "-O"    );
#else
a1730 1
#endif
d1790 1
a1790 1
DoCompiles( )
d1835 1
a1835 2

#ifndef __ARM	  
a1839 1
#endif
d1852 1
a1852 6

	case 's':
	
          result = !(Assemble( this ));
          break;
          	  
a1855 4
#ifdef __ARM
	  result = TRUE;
#else

d1872 1
a1872 1
#endif	  
d1883 1
a1883 1
DoAssembles( )
d1914 1
a1914 1
DoLink( )
d1927 3
d1932 1
a1932 4
#ifndef __ARM
      AddNamef( plist, "%s", linker    );
      AddName(  plist, "-p"	       );
      AddNames( plist, "%s", &LinkOpts );
a1948 15
#else
      AddNamef( plist, "%s", cat    );
	
      if (!USE_PIPE || NCfiles == 0)
	{
	  AddFiles( plist, "%s.%s", &SourceFiles );
	}
      
      if (ObjName != NULL)
	{
	  AddName(  plist, "> " 	 );
	  AddNamef( plist, "%s", ObjName );
	}
#endif

a1951 3
      AddNamef( plist, "%s", linker    );
      AddNames( plist, "%s", &LinkOpts );
      
d1961 1
a1961 1
	      AddNamef( plist, "%s%s", libdir, link_fstart );
d1965 1
a1965 1
	      AddNamef( plist, "%s%s", libdir, link_m2start );
d1969 1
a1969 1
	      AddNamef( plist, "%s%s", libdir, link_cstart );
d1971 1
a1971 1
	      if (!AddLibrary( libdir, link_clib ))
d1988 4
a1992 2
      AddNames( plist, "%s", &LibraryNames );
      
d1999 1
a1999 1
      
d2006 1
a2006 5
#ifdef __ARM
  if (JOIN)
    result = ExecuteCmdList(plist);
  else
#endif   
d2032 1
a2032 2
ParseWarnings( s )
char * s;
d2089 1
a2089 2
ParseFeatures( s )
char * s;
d2126 4
d2145 1
a2145 1
AddWarningsAndFeatures( )
a2155 4

#ifdef NCC
      strcpy( buf, "-W" );
#else
a2156 1
#endif
a2168 3
#ifdef NCC
      strcpy( buf, "-W" );
#else
a2169 2
#endif

a2178 3
#ifdef NCC
      strcpy( buf, "-F" );
#else
a2179 1
#endif
a2189 3
#ifdef __ARM
	  AddName( &CompileOpts, "-Zpg0" );
#else
a2190 1
#endif
d2195 1
a2195 5
#ifdef __ARM
          AddName( &CompileOpts, "-Zpf0" );
#else
          AddName( &CompileOpts, "-pf0" );
#endif
a2199 3
#ifdef __ARM
	  AddName( &CompileOpts, "-Zps1" );
#else
a2200 1
#endif
d2202 5
d2215 1
a2215 1
AddDefines( )
a2219 3
#ifdef NCC
  AddNames( &CompileOpts, "-D%s", &Defines );
#else
a2220 1
#endif
d2228 1
a2228 2
AddInclude( path )
char * path;
d2259 1
a2259 7

#ifdef NEVER
      if (buffer[ strlen( buffer ) - 1 ] == '/' && strlen( buffer ) > 0)
        {
          buffer[ strlen( buffer ) - 1 ] == '\0';
        }
#endif      
d2264 1
a2264 2

  
d2286 1
a2286 2
AddSymbol( path )
char * path;
d2344 1
a2344 2
AddLibraryPath( path )
char * path;
d2404 1
a2404 1
AddIncludeOpts( )
a2410 3
#ifdef NCC
  char	*	ind;
#endif
d2412 1
a2415 3
#ifdef NCC
  strcpy( buffer, "-I" );
#else
d2417 1
a2417 2
#endif

a2422 8

#ifdef NEVER
      if (buffer[strlen(buffer)-1] == '/')
                   buffer[strlen(buffer)-1] = '\0';

      strcat( buffer, " -I");
#endif

a2423 1

d2425 3
a2427 6
#ifdef NEVER
  buffer[ strlen( buffer ) - 3 ] = '\0';                /* remove trailing ' -I$
#else  
  buffer[ strlen( buffer ) - 1 ] = '\0'; 		/* remove trailing ',' */
#endif

d2434 1
a2434 15

#ifdef NEVER

  buffer[ 4 ] = '-';
  buffer[ 5 ] = 'J';

  for (ind = buffer + 5; (*ind); ind++)
  {
        if (*ind == 'I')
                *ind = 'J';
  }
  AddName( &CompileOpts, buffer + 4 );          /* -j version */

#else  

a2435 4

#ifdef NCC
  buffer[ 4 ] = 'J';
#else
d2437 1
a2437 2
#endif

a2439 2
#endif

d2446 1
a2446 1
AddSymbolOpts( )
d2465 1
a2465 1
  buffer[ strlen( buffer ) - 1 ] = '\0'; 		/* remove trailing ',' */
d2475 1
a2475 1
CountSources( )
d2543 7
d2551 3
a2553 3
main( argc, argv )
     int		argc;
     char **		argv;
a2558 1
#ifndef __ARM
a2559 2
#endif

d2571 22
a2593 114
  if ((shell = getenv( "SHELL" )) == NULL)
    {
      shell = SHELL;
    }
  
  if ((c_compiler = getenv( "C_COMPILER" )) == NULL)
    {
      c_compiler = C_COMPILER;
    }
  
  if ((pre_processor = getenv( "PRE_PROCESSOR" )) == NULL)
    {
      pre_processor = PRE_PROCESSOR;
    }
  
  if ((f77_pass1 = getenv( "F77_PASS1" )) == NULL)
    {
      f77_pass1 = F77_PASS1;
    }
  
  if ((f77_pass2 = getenv( "F77_PASS2" )) == NULL)
    {
      f77_pass2 = F77_PASS2;
    }
  
  if ((m2_compiler = getenv( "M2_COMPILER" )) == NULL)
    {
      m2_compiler = M2_COMPILER;
    }
  
  if ((assembler = getenv( "ASSEMBLER" )) == NULL)
    {
      assembler = ASSEMBLER;
    }

#ifdef __ARM

  if ((cat = getenv( "CAT" )) == NULL)
    {
      cat = CAT;
    }
  
#endif

  if ((linker = getenv( "LINKER" )) == NULL)
    {
      linker = LINKER;
    }
  
  if ((remover = getenv( "REMOVER" )) == NULL)
    {
      remover = REMOVER;
    }
  
  if ((macro = getenv( "MACRO" )) == NULL)
    {
      macro = AMPP;
    }
  
  if ((macdir= getenv( "MACDIR" )) == NULL)
    {
      macdir = MACDIR;
    }
  
  if ((libdir = getenv( "C_LIBDIR" )) == NULL)
    {
      libdir = C_LIBDIR;
    }
  
  if ((incdir= getenv( "C_INCDIR" )) == NULL)
    {
      incdir = C_INCDIR;
    }
  
  if ((symdir= getenv( "SYMDIR" )) == NULL)
    {
      symdir = SYMDIR;
    }
  
  if ((link_helios = getenv( "LINK_HELIOS" )) == NULL)
    {
      link_helios= LINK_HELIOS;
    }
  
  if ((link_cstart = getenv( "LINK_CSTART" )) == NULL)
    {
      link_cstart= LINK_CSTART;
    }
  
  if ((link_clib = getenv( "LINK_CLIB" )) == NULL)
    {
      link_clib= LINK_CLIB;
    }
  
  if ((link_fstart = getenv( "LINK_FSTART" )) == NULL)
    {
      link_fstart= LINK_FSTART;
    }
  
  if ((link_m2start = getenv( "LINK_M2START" )) == NULL)
    {
      link_m2start= LINK_M2START;
    }
  
  if ((ObjectName = getenv( "OBJNAME" )) == NULL)
    {
      ObjectName = OBJNAME;
    }
  
  if ((machinename = getenv( "MACHINENAME" )) == NULL)
    {
      machinename = MACHINENAME;
    }
  
d2599 13
a2611 12
  InitList( &IncludeDirs  );
  InitList( &SymbolDirs   );
  InitList( &LibraryDirs  );
  InitList( &LibraryNames );
  InitList( &Defines      );
  InitList( &SourceFiles  );
  InitList( &CompileOpts  );
  InitList( &PreProcOpts  );
  InitList( &ModulaOpts   );
  InitList( &AssembleOpts );
  InitList( &MacroOpts    );
  InitList( &LinkOpts     );
d2613 1
a2613 1
  AddLibraryPath( libdir );
d2624 1
a2624 2

#ifndef __ARM  
a2628 1
#endif
d2631 1
a2631 1
  /* automatically without introducing some circularity		 */
d2639 1
a2639 6
#ifdef __ARM

  AddName( &Defines, "__ARM" );
  AddName( &Defines, "__HELIOSARM" );

#else
d2646 1
a2646 2
#endif

d2655 1
a2675 6
#ifdef DEBUG
  printf("argv:");
  for (i =1 ; i < argc; i++ )
    printf(" %s",argv[i]);
  printf("\n");
#endif	
d2680 1
d2736 1
a2736 1
		    (void) AddLibrary( libdir, "bsd" );
d2743 1
a2743 1
		    (void) AddLibrary( libdir, "bsd" );
d2755 1
a2755 1
#ifndef NCC
d2764 1
a2764 1
#endif   
d2786 1
a2786 2

#ifndef __ARM	      
a2792 1
#endif	      
d2794 1
a2853 2

#ifndef __ARM
d2890 1
a2890 3
#else
              warning("-Tn option not available on ARM");
#endif
d2905 1
a2905 1
		    (void) RemoveName( &LibraryNames, "/helios/libbsd.a" );
d2912 1
a2912 1
		    (void) RemoveName( &LibraryNames, "/helios/libbsd.a" );
d2923 1
a2923 1
#ifndef NCC
d3001 1
a3001 1
#endif	      
d3067 1
a3067 2

#ifndef __ARM	      
a3091 1
#endif
a3163 3
#ifdef __ARM
	      AddName( &CompileOpts, "-Zl");
#else
d3169 1
a3169 1
#endif	      
d3231 1
a3231 3
#ifdef NCC	      
	      AddName( &CompileOpts, "-P" );
#else
d3233 1
a3233 1
#endif	      
d3248 2
a3249 6

#ifdef __ARM
	      AddName( &CompileOpts, "-Zr" );  
#else
	      AddName( &CompileOpts, "-r" ); 
#endif
d3293 6
d3309 1
a3309 1
#ifndef NCC
d3312 1
a3312 1
#endif    
a3358 1
	    case 'u': /* unused */
d3387 1
a3387 1
	      AddLibraryName( "-l%s", arg );
a3397 1
#ifndef UNIX
d3399 1
a3399 3
#endif

  AddInclude( incdir );
a3436 1
#ifndef __ARM
a3437 1
#endif
d3445 1
a3445 4
      if (!AddLibrary( libdir, link_helios ))
	{
	  warning( "Could not find standard helios library '%s'!", link_helios );
	}
d3447 1
a3447 10

#ifdef __ARM
  if  (Flags & FLAG_S)
        AddName( &CompileOpts, "-S" );
  else
        AddName( &CompileOpts, "-c" );
			/* following line is a fudge! */
        AddName( &CompileOpts, "-WANPVDF" );
#endif

d3454 1
a3454 1

d3458 3
a3460 1
	succeded = DoLink();
@


1.43
log
@Fixed object name bug in R140 version
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.42 $
 * RCS date:    $Date: 1991/05/07 09:25:44 $
d1610 1
a1610 1
		if (streq( ObjName, OBJNAME ))
d3657 3
d3665 1
a3665 1
	      
@


1.42
log
@Temporarily added compulsory `-Wa' options to ARM version to facilitate
X compilation. Also added CAT support for building ARM libraries
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.41 $
 * RCS date:    $Date: 1991/04/23 13:28:20 $
d456 1
a456 1

d458 3
a461 1

d1472 1
a1472 1

d1475 4
d1609 6
a1614 1
                AddNamef( plist, "%s.o", fnode->root );
@


1.41
log
@Amended for correct NCC include format, and added automatic NCC
warning supression (useful for X)
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.40 $
 * RCS date:    $Date: 1991/04/15 18:26:25 $
d453 3
d457 3
d1472 1
a1472 1
ExecuteCommandLine( )
d1922 1
d1953 1
a1953 1
  
d2506 2
a2507 2
#ifdef NCC
          warning("-pg0 not available in NCC");
d2515 2
a2516 2
#ifdef NCC
          warning("-pf0 not available in NCC");
d2524 2
a2525 2
#ifdef NCC
          warning("-ps1 not available in NCC");
d2806 1
a2806 1
ifdef NCC
d2808 1
a2808 1
else
d2810 1
a2810 1
endif
d3732 6
a3737 2
	      AddName( &CompileOpts, "-r" );
	      
@


1.40
log
@fixed include bug under UNIX
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.39 $
 * RCS date:    $Date: 1991/04/12 15:01:27 $
d222 8
d359 3
d713 1
d723 3
d737 1
d746 4
d799 3
d1420 43
d1464 1
d1476 1
a1476 1
  if (!USE_PIPE || command_line[ 0 ] == '\0')
d2206 1
d2226 15
d2299 5
a2303 1
    
d2580 2
a2581 1
#ifdef NCC
d2586 1
a2586 1
#else      
d2591 1
a2591 1
#endif
d2759 2
a2760 1
#ifdef NCC
d2765 2
a2766 1
#else
d2768 1
a2768 1
#endif
d2770 1
a2770 1
#ifdef NCC
a2781 1
#ifdef NCC
d2783 2
d2796 1
d2798 4
d2803 1
d2806 1
d2971 7
d2979 2
d3223 1
a3223 1

d3232 1
a3232 1
	      
d3322 2
a3324 1
	    case 'T': /* Transputer type */
d3361 3
a3363 1
	      
a3365 1
#endif
d3396 1
a3396 1

a3429 1
#ifndef __ARM
d3433 1
a3433 1
#endif
d3474 1
a3474 1
	      
d3780 1
a3780 1

d3783 1
a3783 1
	      
d3933 2
@


1.39
log
@Added hobjasm support for ARM
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.38 $
 * RCS date:    $Date: 1991/04/10 15:46:59 $
d184 1
a184 1
#ifdef UNIX
@


1.38
log
@Implemented for R140 (K+R with UNIX)
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.37 $
 * RCS date:    $Date: 1991/04/09 16:46:50 $
d1849 32
a1900 2
 debug("assembling...");
    
d1925 3
d1929 1
d3833 1
a3833 1
      
@


1.37
log
@*** empty log message ***
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.36 $
 * RCS date:    $Date: 1991/04/09 14:19:18 $
d184 1
a184 2
endif
ifdef UNIX
d187 1
d1868 2
d1873 1
a1873 1
#ifndef NCC
a1874 1
#endif
d1877 1
d1884 1
d1889 1
d2019 6
a2024 1
	  
a2957 1
  AddName( &Defines, "ARM" );
d3728 1
d3730 2
@


1.36
log
@NCC and ARM version
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.35 $
 * RCS date:    $Date: 91/04/05 16:45:55 $
d131 1
d135 8
d144 1
d147 1
d164 1
d166 3
d182 1
d184 2
a185 1
#ifndef UNIX
@


1.35
log
@De-Ansified it, and got it running for cross-compiling on the Sun4.
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.34 $
 * RCS date:    $Date: 1991/03/21 17:41:35 $
d122 2
d130 8
d179 3
a181 9
#ifdef UNIX
#define SHELL		"/bin/sh"
#define PRE_PROCESSOR	"/lib/cpp"
#define F77_PASS1	"echo"
#define F77_PASS2	"echo"
#define M2_COMPILER	"echo"
#define REMOVER		"/bin/rm"
#define SYMDIR		"/"
#else
d183 3
d187 3
d191 3
d195 3
d199 3
d203 3
d207 3
d211 3
d215 3
d219 3
d223 3
d227 3
d231 3
d236 2
d245 3
d249 1
a250 1

d652 1
d654 1
d657 1
d660 1
d666 1
d668 1
d698 1
d700 1
d715 1
d717 1
d719 1
d721 1
d724 1
d727 1
d729 1
d731 1
d734 1
d736 1
d745 1
d749 1
d756 1
d760 1
d768 1
d770 1
d775 1
d778 1
d896 3
a898 1
    
d903 2
d1496 3
d1500 1
d1506 12
a1517 2
      AddName(  plist, "-s"                );
      AddNamef( plist, "%s.s", fnode->root );
d1525 7
a1531 1
  
d1533 2
a1534 1
  
d1853 2
d1856 2
d1979 2
a1980 1
	  
d1985 1
d2002 4
d2022 1
a2022 1
	  
d2304 4
d2309 1
d2322 3
d2326 2
d2337 3
d2341 1
d2352 3
d2356 1
d2361 5
a2365 1
	  AddName( &CompileOpts, "-pf0" );
d2370 3
d2374 1
d2389 3
d2393 1
d2433 6
a2438 1
      
d2443 2
a2444 1
      
d2593 3
a2596 1
  
d2600 3
d2604 2
a2605 1
  
d2611 6
d2618 1
d2620 3
a2622 1
  
d2624 2
a2625 1
  
d2632 13
a2644 1
  
d2647 1
a2647 1
  
d2649 1
d2763 1
d2765 2
d2913 2
a2914 1
  
d2919 1
d2930 7
a2936 1
  
d2943 2
a2944 1
  
d3088 2
a3089 1
	      
d3096 1
a3097 1
	      
d3156 1
d3197 1
d3262 1
d3266 1
a3266 1

d3373 2
a3374 1
	      
d3399 1
d3539 3
a3541 1
	      
d3543 1
a3543 1
	      
d3742 1
d3744 1
d3757 8
a3764 1
  
@


1.34
log
@added /include to search path for include server
@
text
@d11 2
a12 2
 * RCS version: $Revision$
 * RCS date:    $Date$
d120 2
d132 9
d144 2
d147 3
a150 2
#include <queue.h>

d171 6
a178 1
#endif
a179 3
#ifdef UNIX
#define PRE_PROCESSOR	"/lib/cpp"
#else
a180 1
#endif
d184 1
a186 5
#ifdef UNIX
#define REMOVER		"/bin/rm"
#else
#define REMOVER		"/helios/bin/rm"
#endif
d189 4
a197 3
#define C_INCDIR	"/helios/include/"
#define MACDIR		"/helios/include/ampp/"
#define SYMDIR		"/helios/symbols/"
d384 1
d386 5
d397 2
a398 1
    
d400 3
d425 1
d427 5
d438 2
a439 1
    
d441 3
d463 1
d465 5
d477 1
d479 3
d504 1
d506 5
d518 1
d520 3
d544 2
a545 1
SafeAlloc( unsigned long size )
d564 1
a564 1
usage( void )
d671 1
a671 1
  error( "-Wc,arg[,arg ...] Pass on arguments to specific parts of the compilation." );
d736 2
a737 1
FirstNode( List * plist )
d755 2
a756 1
NextNode( Node * node )
d775 2
a776 1
ListSize( List * plist )
d794 2
a795 1
DupName( char * name )
d811 3
a813 3
AddName(
	NameList *	plist,
	char *		name )
d836 3
a838 3
RemoveName(
	   NameList *	plist,
	   char * 	pname )
d868 3
a870 3
AddNameToFront(
	NameList *	plist,
	char *		name )
d894 1
d899 6
d913 6
a918 1
  va_start( args,   format );
d920 1
d931 1
d933 5
d950 6
a955 1
  va_start( args,   format );
d957 1
d983 3
a985 3
AddFile(
	FileList *	plist,
	char *		file )
d1031 4
a1034 4
AddNames(
	 NameList *	nlist,
	 char *		format,
	 NameList *	plist )
d1055 4
a1058 4
AddFiles(
	 NameList *	nlist,
	 char *		format,
	 FileList *	plist )
d1087 3
a1089 3
AddLibrary(
	   char *	dir,
	   char *	stem )
d1192 2
a1193 1
FindAndAddLibrary( char * pfile_name )
d1221 2
a1222 1
ExecuteList( NameList * nlist )
d1304 1
a1304 1
ExecuteCommandLine( void )
d1373 2
a1374 1
RemoveFile( FileNode * pfile )
d1396 2
a1397 1
C_Compile( FileNode * fnode )
d1442 2
a1443 1
Pre_Process( FileNode * fnode )
d1477 2
a1478 1
F77_Compile( FileNode * fnode )
d1598 2
a1599 1
M2_CompileDef( FileNode * fnode )
d1624 2
a1625 1
M2_CompileMod( FileNode * fnode )
d1691 2
a1692 1
MacroAssemble( FileNode * fnode )
d1739 2
a1740 1
Assemble( FileNode * fnode )
d1831 1
a1831 1
DoCompiles( void )
d1924 1
a1924 1
DoAssembles( void )
d1955 1
a1955 1
DoLink( void )
d2073 2
a2074 1
ParseWarnings( char * s )
d2131 2
a2132 1
ParseFeatures( char * s )
d2184 1
a2184 1
AddWarningsAndFeatures( void )
d2249 1
a2249 1
AddDefines( void )
d2262 2
a2263 1
AddInclude( char * path )
d2321 2
a2322 1
AddSymbol( char * path )
d2380 2
a2381 1
AddLibraryPath( char * path )
d2441 1
a2441 1
AddIncludeOpts( void )
d2483 1
a2483 1
AddSymbolOpts( void )
d2512 1
a2512 1
CountSources( void )
d2581 3
a2583 3
main(
     int		argc,
     char **		argv )
@


1.33
log
@fixed failure to pass on return codes
@
text
@d16 2
a17 2
#define REVISION	50
#define DATE		13/03/91
d118 2
d127 2
d130 2
d134 1
d136 1
d3411 2
a3412 1
  
d3482 1
a3482 1
  
a3485 2


@


1.32
log
@fixed generation of FORTRAN temporary file names
fixed scanning of resident libraries
@
text
@d16 2
a17 2
#define REVISION	49
#define DATE		11/03/91
d115 3
d1206 1
a1206 1
  return 0;
d1270 1
a1270 1
  return 0;
d1534 1
a1534 1
  List *		plist  = (List *)&args;
d1536 1
a1536 1
  char *		extension;	
d1600 1
a1600 1
  List *		plist  = (List *)&args;
d1604 5
a1608 1
  if (strncmp( "lib", fnode->base, 3 ) != 0)
d1610 1
a1610 5
      InitList( plist );
      
      AddNamef( plist, "%s", macro );
      
      if (REDIRECT && !ASSEMBLE)
d1612 1
a1612 4
	  if (ObjName != NULL)
	    {
	      AddNamef( plist, "-o%s", ObjName );
	    }
a1613 18
      else if (!USE_PIPE)
	{
	  AddNamef( plist, "-o%s.s", fnode->root );
	}
	
      AddNamef( plist, "-i%s", macdir );
      
      AddNames( plist, "%s",   &MacroOpts );
      
      AddNamef( plist, "%s%s", macdir, BASIC );
      
      AddNamef( plist, "%s.a", fnode->root );
      
      result = ExecuteList( plist );
      
      NCompiles++;
      
      fnode->ext = DupName( "s" );
d1615 1
a1615 1
  else
d1617 14
a1630 1
      AddLibraryName( "-l%s.%s", fnode->root, fnode->ext );
d1632 1
a1632 1
      /* remove the file from the sources list */
a1633 3
      (void) Remove( (Node *)fnode );
    }
  
d1757 1
d1765 4
a1768 2
	    result = FALSE;
	    
d2417 1
a2417 1
  for ( this = (FileNode *)FirstNode( (List *)&SourceFiles );
a2438 1
	  NAfiles++;
d3377 7
a3383 1
	  AddFile( &SourceFiles, arg );
d3385 16
a3400 1
	  NSources++;
d3457 1
a3457 1
  
d3477 2
@


1.31
log
@fixed bug whereby 'c fred.c jim.o' did not create fred.o
@
text
@d16 2
a17 2
#define REVISION	48
#define DATE		6/03/91
d111 4
d127 1
d130 1
d133 1
d135 1
d540 1
a540 1
  error( "*.f           Fortran source file.");
d550 1
a550 1
  error( "-e[6|7]       Enforce Fortran standard.");
d624 2
a625 2
  error( "F77_PASS1     Pathname of the first  pass of the Fortran compiler." );
  error( "F77_PASS2     Pathname of the second pass of the Fortran compiler." );
d634 2
a635 1
  error( "SYMDIR        Pathname of the standard Modula-2 symbol file directory." );
a833 1
  va_list		args;
d835 1
d1077 1
a1077 6
 got_scanned:
  AddLibraryName( "-l%s", buf );
    
  return TRUE;
    
 got_resident:
d1090 2
a1091 1
  AddLibraryName( "%s", buf );
d1381 1
a1381 1
 * compile the indicated Fortran file 
d1389 3
d1396 1
a1396 1
      /* switch off piping for Fortran compiles */
d1407 13
a1419 2
    
  if (ram_disk_present)
d1421 1
a1421 1
      AddName(  plist, "/ram/tmp"     );
d1425 1
a1425 1
      AddName(  plist, "/helios/tmp"	);
d1427 12
d1440 2
d1452 1
a1452 1
      AddNamef( plist, "%s",      f77_pass2   );
d1454 1
a1454 8
      if (ram_disk_present)
	{
	  AddName(  plist, "/ram/tmp"     );
	}
      else
	{
	  AddName(  plist, "/helios/tmp"  );
	}
d1456 1
a1456 1
      AddNamef( plist, "%s.s",    fnode->root );
d2486 1
d2488 1
@


1.30
log
@fixed spelling mistake
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.29 $
 * RCS date:    $Date: 91/02/25 15:01:32 $
d17 1
a17 1
#define DATE		25/02/91
d230 1
d595 1
a596 1
  error( "-T[4|5|8]     Specify Transputer type.(5 => T425)" );
d1748 1
a1748 1
	  if (USE_PIPE && (NCfiles > 1 || NAfiles > 0))
d1765 1
a1765 1
	  if (USE_PIPE && (NAfiles > 1 || NCfiles > 0))
d2394 1
a2394 1
  NAfiles = NCfiles = NFfiles = NSfiles = NDfiles = NMfiles = NSources = 0;
d2426 8
a2433 3
	   if (strneq( this->root, link_cstart, strlen( link_cstart ) - 2 ))
	     link_cstart = NULL;
	     
@


1.29
log
@oops, fixed a few, minor, non-ANSI isms
@
text
@d11 2
a12 2
 * RCS version: $Revision$
 * RCS date:    $Date$
d548 1
a548 1
  error( "-n            Don't acutally execute commands (implies -v)." );
@


1.28
log
@added -L and -W options, fixed more piping stuff
@
text
@d490 1
a490 1
static int
d1061 1
a1061 1
	  return;
d2460 1
a2460 1
  if ((ProgName = strrchr( argv[ 0 ], '/')))
@


1.27
log
@more fixes to non_standard option, plus tided up help message
@
text
@d16 2
a17 2
#define REVISION	47
#define DATE		22/02/91
d107 4
d212 1
d329 1
a329 1
static char *		ProgName;
d352 31
d404 3
a406 1
    
d411 31
d472 1
a472 1
SafeAlloc( unsigned int size )
d482 1
a482 1
      fail( "malloc failed" );
d557 10
a566 1
  error( "-w[Aacdfpsvz] Suppress warnings (A means suppress all warnings)." );
d572 2
a573 2
  error( "-D<name>      #define <name>" );
  error( "-D<name>=<val> #define <name> to be <val> (default <val> is \"1\")." );
d576 8
a583 8
  error( "                   'f' disables the vector stack," );
  error( "                   'g' removes procedure names from the code," );
  error( "                   'h' warns of discrepencies in function declarations," );
  error( "                   'm' warns of unused macros," );
  error( "                   'n' do not put arrays or structs on vector stack," );	
  error( "                   's' turns off stack checking," );
  error( "                   'v' warns of unused functions and variables," );
  error( "                   'A' turns on -Fs and -Fg." );
d587 1
a587 1
  error( "-L<name>      Same as the -l option (for backwards compatability)." );
d596 1
d598 9
d651 2
d673 2
a674 4
  else
    {
      return plist->Head;
    }
d692 2
a693 4
  else
    {
      return node->Next;
    }
d747 1
a747 2
      error( "%s: warning - blank(s) found in argument '%s'",
	    ProgName, name );
d751 3
a753 1
    
d757 32
d790 26
d833 3
a835 1
    
d859 1
a859 1
  for (pname = (NameNode*)FirstNode( (List *)plibs );
d861 1
a861 1
       pname = (NameNode *)NextNode( (Node *)pname ) )
d873 3
a875 1
    
d921 3
a923 1
    
d945 3
a947 1
    
d969 3
a971 1
    
d974 1
d983 1
a983 1
static void
d1065 1
a1065 2
  error( "%s: could not find library '%s' in directory '%s'",
	ProgName, stem, dir );
a1066 2
  return;
    
d1070 1
a1070 1
  return;	
d1077 2
a1078 3
       * adding in the resident X library
       * make sure that there is sufficient stack
       * for the program
d1087 1
a1087 1
  return;
d1092 26
d1194 1
a1194 2
      error( "%s failed because %s exited with return code of %d",
	    ProgName, argv[ 0 ], result );
d1258 1
a1258 2
      error( "%s failed because %s exited with return code of %d",
	    ProgName, shell, result );
d1287 3
a1289 1
    
d1610 3
a1612 2
      if (!USE_PIPE)
      	(void) Remove( (Node *)fnode );
d1634 3
a1636 3
  AddNamef( plist, "%s",   assembler     );
  AddName(  plist, "-p"                  ); /* only assemble */
  AddNames( plist, "%s",   &AssembleOpts );
d1658 25
d1749 2
a1750 1
	      Assemble( this );
d1766 2
a1767 1
	      Assemble( this );
d1821 1
d1848 3
a1850 3
      AddNamef( plist, "%s",    linker       );
      AddName(  plist, "-p"		     );
      AddNames( plist, "%s",    &LinkOpts    );
d1870 2
a1871 2
      AddNamef( plist, "%s",	  linker    );
      AddNames( plist, "%s", 	  &LinkOpts );
d1882 1
a1882 1
	      AddNamef( plist, "%s%s",  libdir, link_fstart );
d1886 1
a1886 1
	      AddNamef( plist, "%s%s",  libdir, link_m2start );
d1890 8
a1897 2
	      AddNamef( plist, "%s%s",  libdir, link_cstart );
	      AddLibrary( libdir, link_clib );
d1901 1
a1901 1
      if (NSources > 1 || !USE_PIPE)
d1903 1
a1903 1
	  AddFiles( plist, "%s.%s", &SourceFiles );
d1907 1
a1907 1
	  AddName( plist, "-" );
d1914 3
a1916 3
	  AddNamef( plist, "-n%s",  ObjectName );
	  AddNamef( plist, "-s%d",  StackSize  );
	  AddNamef( plist, "-h%d",  HeapSize   );
d1998 1
a1998 2
	  error( "%s: Unknown option -w%c, ignored",
		ProgName, *s );
d2001 2
d2050 1
a2050 2
	  error( "%s: Unknown option -F%c, ignored",
		ProgName, *s );
d2053 2
d2118 2
d2131 3
a2133 1
    
d2189 2
d2247 2
d2254 60
d2349 2
d2354 1
a2354 1

d2378 2
d2443 2
d2459 10
a2468 1
  
d2581 1
d2591 2
a2599 2
  
  ProgName  = argv[ 0 ];
d2675 14
a2689 2
	      AddName( &LinkOpts, &arg[ 2 ] );
	      
d2708 9
d2718 6
a2723 1
	      AddName( &Defines, &arg[ 2 ] );
d2725 3
a2727 2
	      if (streq( &arg[ 2 ], "_BSD" ))
		AddLibrary( libdir, "bsd" );
d2738 9
a2747 2
	      ParseFeatures( &arg[ 2 ] );
	      
d2761 1
a2761 1
		      fail( "No filename following -I" );
d2771 3
a2774 1
	      AddName( &ModulaOpts, &arg[ 2 ] );
d2778 18
d2797 3
a2800 1
	      FortranMapFile = &arg[ 2 ];
d2808 15
a2822 1
	    case 'P': /*pass on option to pre-processor */
a2823 1
	      AddName( &PreProcOpts, &arg[ 2 ] );
a2839 9
		case '9':
		  AddName( &ModulaOpts,  "-t8" );
		  AddName( &CompileOpts, "-t9" );
		  AddName( &Defines,    "T800" );
		  
		  strcat( FortranP2Opts, "+F" );
		  
		  break;
		  
d2862 3
d2866 2
d2869 1
a2869 2
		  error( "%s: Unknown -T option '%c', ignored",
			ProgName, arg[ 2 ] );
d2876 24
d2906 78
a2984 4
	      strcat( FortranP1Opts, "+W" );
	      
	      strcat( FortranP1Opts, &arg[ 2 ] );
	      
d2990 3
a2993 2
	      strcat( FortranP1Opts, &arg[ 2 ] );
	      
d3005 1
a3005 1
		  strcat( FortranP1Opts, &arg[ 2 ] );
d3023 1
a3023 1
		  AddName( &AssembleOpts, &arg[ 2 ] );
d3045 3
a3048 2
	      AddName( &LinkOpts, &arg[ 0 ] );
	      
d3062 5
d3069 2
a3070 2
		  error( "%s: Unknown -e option %c, ignored",
			ProgName, arg[ 2 ] );
d3108 1
a3108 1
		  return -1;
d3112 3
a3114 1
		  fail( "Heap size too small" );
a3126 1
	    case 'L':
d3128 14
a3142 2
	      AddLibrary(libdir, &arg[2] );
	      
d3194 1
a3194 1
		      fail( "No filename following -o" );
d3249 1
a3249 1
		      fail( "no number following -s" );
d3259 3
a3261 1
		  fail( "Stack size too small" );
d3277 1
d3286 3
a3289 2
	      ParseWarnings( &arg[ 2 ] );
	      
a3331 1
	    case 'U': /* unused */
d3340 1
a3340 2
	      error( "%s: Unknown option '%s' passed to linker",
		    ProgName, &arg[ 0 ] );
d3401 4
a3404 1
      AddLibrary( libdir, link_helios );
@


1.26
log
@minor improvements, not worth a new version
@
text
@d16 2
a17 2
#define REVISION	46
#define DATE		7/02/91
d91 1
a91 1
 * 41 - added -y option to pass text on to the macro pre-processor
d460 23
a482 22
  error( "*.c		C source file." );
  error( "*.f		Fortran source file.");
  error( "*.s		Assembler source file." );
  error( "*.a		Macro Assembler source file." );
  error( "*.def		Modula-2 definition source file." );
  error( "*.mod		Modula-2 program source file." );
  error( "*.o		Assembled file - ready for linking." );
  error( "-a<text>	Pass <text> as an option to assembler." );
  error( "-b		Don't link with standard library (helios.lib)." );
  error( "-c		Compile/Assemble only, don't link." );
  error( "-d<name>	Specify output file name for library .def compilations." );
  error( "-e[6|7]		Enforce Fortran standard.");
  error( "-f <name>	Specify file name for the assembler's virtual memory system." );
  error( "-g		Compile for debugging." );
  error( "-h<val> 	Specify heap size of program." );
  error( "-j		Join objects but don't link." );
  error( "-l<name>	Link with standard library <name>" );
  error( "-m		Compile code for libraries." );
  error( "-n		Don't acutally execute commands (implies -v)." );
  error( "-n<string>	Specify object name of program." );
  error( "-o <name>	Specify output name (default *.o or \"a.out\") (\"-\" is stdout)" );
  error( "-p		Compile code for profiling.");
d484 15
a498 15
  error( "-r		Suppress static data structures." );
  error( "-s<val> 	Specify stack size of program." );
  error( "-t		Compile code for tracing.");
  error( "-v		Verify command being executed." );
  error( "-w[Aacdfpsvz]	Suppress warnings (A means suppress all warnings)." );
  error( "-y<text>	Pass <text> as an option to the Macro Pre-Processor." );
  error( "-z<text>	Pass <text> as an option to the C compiler." );
  error( "-A<text>	Pass <text> as an option to the linker." );
  error( "-B		Do not link with any libraries.  Do not perform objed." );
  error( "-C		Perform array bound checking (F77,M2).");
  error( "-D<name>	#define <name>" );
  error( "-D<name>=<val>	#define <name> to be <val> (default <val> is \"1\")." );
  error( "-E		Pre-process only - do not compile" );
  error( "-F[Afghmnsv]	Enable compiler features :-" );
  error( "                   'f' diables the vector stack," );
d506 16
a521 16
  error( "-I<dir> 	Specify a directory to be searched for #include or" );
  error( "                 Modula-2 symbol files." );
  error( "-K<text>	Pass <text> as an option to Modula-2 compiler." );
  error( "-L<name>	Same as the -l option (for backwards compatability)." );
  error( "-M<name>	Produce map file <name> (F77).");
  error( "-O		Optimise code, perform full link." );
  error( "-P<text>	Pass <text> as an option to the pre-processor." );
  error( "-R		Force use of RAM disk for temporary FORTRAN and" );
  error( "                 Modula-2 files, even if RAM disk is not loaded" );
  error( "-S		Produce textual assembler output from *.c in *.s, don't link." );
  error( "-V		Pass on verbose flag to executed commands." );
  error( "-T[4|5|8|9] 	Specify Transputer type.(5 => T425),(9 => T810)" );
  error( "-W<val>		Specify warning level (F77).");
  error( "-X<val>		Specify cross reference width (F77).");
  error( "-Z<text>	Pass <text> as an option to FORTRAN compiler." );
  error( "-help		This message." );
d524 22
a545 22
  error( "SHELL		Pathname of the command line interpreter." );
  error( "C_COMPILER	Pathname of the C compiler." );
  error( "PRE_PROCESSOR	Pathname of the pre-processor." );
  error( "F77_PASS1	Pathname of the first  pass of the Fortran compiler." );
  error( "F77_PASS2	Pathname of the second pass of the Fortran compiler." );
  error( "M2_COMPILER	Pathname of the Modula-2 compiler.");
  error( "ASSEMBLER	Pathname of the assembler." );
  error( "LINKER		Pathname of the linker." );
  error( "REMOVER		Pathname of the file removal program." );
  error( "MACRO		Pathname of the assembler macro pre-processor." );
  error( "MACDIR          Pathname of the standard AMPP macro directory." );
  error( "C_LIBDIR	Pathname of the library directory." );
  error( "C_INCDIR	Pathname of the standard C header directory." );
  error( "SYMDIR		Pathname of the standard Modula-2 symbol file directory." );
  error( "LINK_HELIOS	Name     of the standard Helios link library.");
  error( "LINK_CSTART	Name     of the standard C startup file." );
  error( "LINK_CLIB	Name     of the standard C link library.");
  error( "LINK_FSTART	Name     of the standard FORTRAN startup file." );
  error( "LINK_M2START	Name     of the standard Modula-2 startup file." );
  error( "OBJNAME		Default name of output file." );
  error( "MACHINENAME	Name	 of the destination hardware, passed on by -D." );
  error( "C_NONSTANDARD	Enables non-standard features." );
d1385 1
a1385 1
MacroPreProcess( FileNode * fnode )
d1387 1
a1387 1
 * macro preprocess the indicated file
d1438 1
a1438 1
} /* MacroPreProcess */
d1491 1
a1491 1
  else if (streq( fnode->oext, "c" ) && USE_PIPE)
d1543 1
a1543 1
	  if (USE_PIPE && NCfiles > 1)
d1556 1
a1556 1
	  if (MacroPreProcess( this ) != 0)
d1558 6
d2807 1
a2807 1
	    case 'y': /* pass on option to macro pre-processor */
d2881 1
a2881 1
  else if (NSources == 1)
@


1.25
log
@fixed macro pre-processing not to remove intermeadiate file when using pipes
@
text
@d8 1
a8 1
 * This code is Copyright (c) 1991 Perihelion Software Ltd.
d17 1
a17 1
#define DATE		23/01/91
d337 2
a338 1
#define streq( s1, s2 )	(strcmp( s1, s2 ) == 0)
d497 1
a497 1
  error( "                   'f' removes procedure names from the code," );
d818 4
d823 3
d841 1
a841 1
      /* strem already has an extension - do not try adding one */
d845 1
a845 1
      if (stat( buf, &status ) == 0 && (status.st_mode & S_IFREG) == S_IFREG)
d864 1
a864 1
      if (stat( buf, &status ) == 0 && (status.st_mode & S_IFREG) == S_IFREG)
d869 1
a869 1
      if (stat( buf, &status ) == 0 && (status.st_mode & S_IFREG) == S_IFREG)
d874 1
a874 1
      if (stat( buf, &status ) == 0 && (status.st_mode & S_IFREG) == S_IFREG)
d879 1
a879 1
      if (stat( buf, &status ) == 0 && (status.st_mode & S_IFREG) == S_IFREG)
d884 1
a884 1
      if (stat( buf, &status ) == 0 && (status.st_mode & S_IFREG) == S_IFREG)
d889 1
a889 1
      if (stat( buf, &status ) == 0 && (status.st_mode & S_IFREG) == S_IFREG)
d919 13
d1635 1
a1635 1
      AddName(  plist, "-p"		       );
d1650 1
a1650 1
	  AddName(  plist, "-o" 	       );
d1656 2
a1657 2
      AddNamef( plist, "%s",	  linker       );
      AddNames( plist, "%s", 	  &LinkOpts    );
d1683 1
a1683 1
	  AddFiles( plist, "%s.%s", &SourceFiles 	);
d1694 3
a1696 3
	  AddNamef( plist, "-n%s",  ObjectName 	);
	  AddNamef( plist, "-s%d",  StackSize 	);
	  AddNamef( plist, "-h%d",  HeapSize 	);
d2127 7
@


1.24
log
@replaced calls to access() with calls to stat() to trap the case
where library names match the names of directories
@
text
@d17 1
a17 1
#define DATE		22/01/91
d1410 2
a1411 1
      (void) Remove( (Node *)fnode );
@


1.23
log
@reformatted
@
text
@d16 2
a17 2
#define REVISION	45
#define DATE		10/01/91
d105 2
d126 1
d827 2
a828 1
  static char buf[ 100 ];	/* XXX */
d830 1
a830 1
    
d837 1
a837 1
      if (access( buf, F_OK ) == 0)
d856 1
a856 1
      if (access( buf, F_OK ) == 0)
d861 1
a861 1
      if (access( buf, F_OK ) == 0)
d866 1
a866 1
      if (access( buf, F_OK ) == 0)
d871 1
a871 1
      if (access( buf, F_OK ) == 0)
d876 1
a876 1
      if (access( buf, F_OK ) == 0)
d881 1
a881 1
      if (access( buf, F_OK ) == 0)
@


1.22
log
@fixed bug with pipes casuing C to return wrong error code
@
text
@d125 4
d165 5
a169 1
typedef struct _NameNode
d171 3
a173 2
	Node 		node;
	char *		name;
d176 1
a176 1
typedef List 		NameList;
d178 7
a185 7
typedef struct _FileNode
{
	Node 		node;
	char *		ext;		/* extension */
	char *		oext;		/* original extension */
	char *		root;		/* name of file less extension */
	char *		base;		/* name of file less directory and extension */
d188 5
a193 5
typedef enum _State
{
	normal,
	objed_suppressed,
	objed_enabled
d196 1
a197 1
typedef List 		FileList;
d199 4
d325 3
d348 17
a364 17
	va_list	args;
	

	va_start( args, format );

	fflush(   stderr );
	
	fseek(    stderr, 0L, SEEK_END );
	
	vfprintf( stderr, format, args );
	
	fprintf(  stderr, "\n" );
	
	fflush(   stderr );
	
	va_end( args );
	
d374 21
a394 21
	va_list 	args;


	va_start( args, format );

	fflush(   stderr );

	fseek(    stderr, 0L, SEEK_END );
	
	fprintf(  stderr, "%s:- ", ProgName );

	vfprintf( stderr, format,  args );

	fprintf(  stderr, "\n" );
	
	fflush(   stderr );

	va_end(   args );

	exit( 1 );

d404 10
a413 10
 	char *	ptr = (char *)malloc( size );


	if (ptr == NULL)
	{
		fail( "malloc failed" );
	}

	return ptr;

d423 136
a558 136
	int	err = dup( 2 );
	int	pid;
	int	pfds[ 2 ];
	

	pipe( pfds );

	pid = vfork();

	if (pid == 0)
	{
		dup2( pfds[ 0 ], 0 );
		
		close( pfds[ 0 ] );
		close( pfds[ 1 ] );
		
		execlp( "more", "more", 0 );
		
		pid = -1;
		
		_exit( 0 );
	}
	
	if (pid == -1)
		close( err );
		
	else dup2( pfds[ 1 ], 2 );

	close( pfds[ 0 ] );
	close( pfds[ 1 ] );

	error( "Helios compiler driver, version %d.%d", VERSION, REVISION );
	error( "Usage: %s [options] files", ProgName );
	error( "*.c		C source file." );
	error( "*.f		Fortran source file.");
	error( "*.s		Assembler source file." );
	error( "*.a		Macro Assembler source file." );
	error( "*.def		Modula-2 definition source file." );
	error( "*.mod		Modula-2 program source file." );
	error( "*.o		Assembled file - ready for linking." );
	error( "-a<text>	Pass <text> as an option to assembler." );
	error( "-b		Don't link with standard library (helios.lib)." );
	error( "-c		Compile/Assemble only, don't link." );
	error( "-d<name>	Specify output file name for library .def compilations." );
	error( "-e[6|7]		Enforce Fortran standard.");
	error( "-f <name>	Specify file name for the assembler's virtual memory system." );
	error( "-g		Compile for debugging." );
	error( "-h<val> 	Specify heap size of program." );
	error( "-j		Join objects but don't link." );
	error( "-l<name>	Link with standard library <name>" );
	error( "-m		Compile code for libraries." );
	error( "-n		Don't acutally execute commands (implies -v)." );
	error( "-n<string>	Specify object name of program." );
	error( "-o <name>	Specify output name (default *.o or \"a.out\") (\"-\" is stdout)" );
	error( "-p		Compile code for profiling.");
	error( "-q<abdfghilmopqrstuwxyz>	Enable compiler debugging features." );
	error( "-r		Suppress static data structures." );
	error( "-s<val> 	Specify stack size of program." );
	error( "-t		Compile code for tracing.");
	error( "-v		Verify command being executed." );
	error( "-w[Aacdfpsvz]	Suppress warnings (A means suppress all warnings)." );
	error( "-y<text>	Pass <text> as an option to the Macro Pre-Processor." );
	error( "-z<text>	Pass <text> as an option to the C compiler." );
	error( "-A<text>	Pass <text> as an option to the linker." );
	error( "-B		Do not link with any libraries.  Do not perform objed." );
	error( "-C		Perform array bound checking (F77,M2).");
	error( "-D<name>	#define <name>" );
	error( "-D<name>=<val>	#define <name> to be <val> (default <val> is \"1\")." );
	error( "-E		Pre-process only - do not compile" );
	error( "-F[Afghmnsv]	Enable compiler features :-" );
	error( "                   'f' removes procedure names from the code," );
	error( "                   'g' removes procedure names from the code," );
	error( "                   'h' warns of discrepencies in function declarations," );
	error( "                   'm' warns of unused macros," );
	error( "                   'n' do not put arrays or structs on vector stack," );	
	error( "                   's' turns off stack checking," );
	error( "                   'v' warns of unused functions and variables," );
	error( "                   'A' turns on -Fs and -Fg." );
	error( "-I<dir> 	Specify a directory to be searched for #include or" );
	error( "                 Modula-2 symbol files." );
	error( "-K<text>	Pass <text> as an option to Modula-2 compiler." );
	error( "-L<name>	Same as the -l option (for backwards compatability)." );
	error( "-M<name>	Produce map file <name> (F77).");
	error( "-O		Optimise code, perform full link." );
	error( "-P<text>	Pass <text> as an option to the pre-processor." );
	error( "-R		Force use of RAM disk for temporary FORTRAN and" );
	error( "                 Modula-2 files, even if RAM disk is not loaded" );
	error( "-S		Produce textual assembler output from *.c in *.s, don't link." );
	error( "-V		Pass on verbose flag to executed commands." );
	error( "-T[4|5|8|9] 	Specify Transputer type.(5 => T425),(9 => T810)" );
	error( "-W<val>		Specify warning level (F77).");
	error( "-X<val>		Specify cross reference width (F77).");
	error( "-Z<text>	Pass <text> as an option to FORTRAN compiler." );
	error( "-help		This message." );
	error( "" );
	error( "%s uses the following environment variables if present:-", ProgName );
	error( "SHELL		Pathname of the command line interpreter." );
	error( "C_COMPILER	Pathname of the C compiler." );
	error( "PRE_PROCESSOR	Pathname of the pre-processor." );
	error( "F77_PASS1	Pathname of the first  pass of the Fortran compiler." );
	error( "F77_PASS2	Pathname of the second pass of the Fortran compiler." );
	error( "M2_COMPILER	Pathname of the Modula-2 compiler.");
	error( "ASSEMBLER	Pathname of the assembler." );
	error( "LINKER		Pathname of the linker." );
	error( "REMOVER		Pathname of the file removal program." );
	error( "MACRO		Pathname of the assembler macro pre-processor." );
	error( "MACDIR          Pathname of the standard AMPP macro directory." );
	error( "C_LIBDIR	Pathname of the library directory." );
	error( "C_INCDIR	Pathname of the standard C header directory." );
	error( "SYMDIR		Pathname of the standard Modula-2 symbol file directory." );
	error( "LINK_HELIOS	Name     of the standard Helios link library.");
	error( "LINK_CSTART	Name     of the standard C startup file." );
	error( "LINK_CLIB	Name     of the standard C link library.");
	error( "LINK_FSTART	Name     of the standard FORTRAN startup file." );
	error( "LINK_M2START	Name     of the standard Modula-2 startup file." );
	error( "OBJNAME		Default name of output file." );
	error( "MACHINENAME	Name	 of the destination hardware, passed on by -D." );
	error( "C_NONSTANDARD	Enables non-standard features." );
	error( "                 (uses pipes to connect processes and" );
	error( "                 does not use 'a.out' unless really necessary)" );

	if (pid >= 0) 
	{
		int 	stat;
		int 	p;
		
	
		close( 2 );
		
		p = wait( &stat );
		
		dup2( err, 2 );
		
		close( err );
	}

d572 11
a582 11
	if (plist 		== Null( List ) ||
	    plist->Head 	== Null( Node ) ||
	    plist->Head->Next 	== Null( Node ) )
	{
		return Null( Node );
	}
	else
	{
		return plist->Head;
	}

d593 11
a603 11
	if ( node 		== Null( Node ) ||
	     node->Next 	== Null( Node ) ||
	     node->Next->Next 	== Null( Node ) )
	{
		return Null( Node );
	}
	else
	{
		return node->Next;
	}

d613 9
a621 9
	int	n = 0;
	Node *	pnode;


	for (pnode = FirstNode( plist ); pnode; pnode = NextNode( pnode ))
		n++;

	return n;

d631 7
a637 7
	char *	ptr = SafeAlloc( strlen( name ) + 1 );


	strcpy( ptr, name );

	return ptr;

d649 13
a661 13
	NameNode *	new = NEW( NameNode );


	new->name = DupName( name );

	if (strchr( name, ' ' ))
	{
		error( "%s: warning - blank(s) found in argument '%s'",
			ProgName, name );
	}
	
	AddTail( (List *)plist, (Node *)new );

d667 3
a669 3
	NameList *	plist,
	char *		format,
	... )
d674 10
a683 10
	va_list		args;
	static char	buffer[ ARGBUFSIZE ];


	va_start( args,   format );
	vsprintf( buffer, format, args );
	va_end(   args );

	AddName( plist, buffer );

d693 25
a717 7
	static char	buffer[ ARGBUFSIZE ];
	va_list		args;
	NameList *	plibs = &LibraryNames;
	NameNode *	pname;
		

	/* format the name */
d719 3
a721 21
	va_start( args,   format );
	vsprintf( buffer, format, args );
	va_end(   args );

	/* check to see if this name already exists */
	
	for (pname = (NameNode*)FirstNode( (List *)plibs );
	     pname != NULL;
	     pname = (NameNode *)NextNode( (Node *)pname ) )
	{
		if (streq( pname->name, buffer ))
			break;
	}
	
	if (pname == NULL)
	{
		/* add the name to the end of the list */
	
		AddName( plibs, buffer );
	}

d734 34
a767 34
	FileNode *	new = NEW( FileNode );
	char *		tmp = DupName( file );
	char *		p   = strrchr( tmp, '.' );


	if (p == NULL)
	{
		new->ext = DupName( "" );
	}
	else
	{
		*p++     = '\0';
		new->ext = DupName( p );
	}

	p = strrchr( tmp, '/' );

	if (p == NULL)
	{
		p = tmp;
	}
	else
	{
		p++;
	}

	new->base = DupName( p );
	new->oext = new->ext;
	new->root = DupName( tmp );

	AddTail( (List *)plist, (Node *)new );
	
	free( tmp );

d773 3
a775 3
	NameList *	nlist,
	char *		format,
	NameList *	plist )
d780 10
a789 10
	NameNode *	this;


	for (this = (NameNode *)FirstNode( (List *)plist );
	     this;
	     this = (NameNode *)NextNode( (Node *)this ))
	{
 		AddNamef( nlist, format, this->name );
	}

d795 3
a797 3
	NameList *	nlist,
	char *		format,
	FileList *	plist )
d802 10
a811 10
	FileNode *	this;


	for (this = (FileNode *)FirstNode( (List *)plist );
	     this;
	     this = (FileNode *)NextNode( (Node *)this ))
	{
		AddNamef( nlist, format, this->root, this->ext );
	}

d817 2
a818 2
	char *	dir,
	char *	stem )
d824 10
a833 4
	static char buf[ 100 ];


	if (strchr( stem, '.' ))
d835 11
a845 18
		/* strem already has an extension - do not try adding one */

		sprintf( buf, "%s%s", dir, stem );
	
		if (access( buf, F_OK ) == 0)
		{
			char * ptr = strchr( stem, '.' ) + 1;
			

			if (streq( ptr, "def" ))
			{
				goto got_resident;
			}
			else
			{
				goto got_scanned;
			}
		}
d847 4
a850 3
	else
	{
		sprintf( buf, "%s%slib.def", dir, stem );
d852 2
a853 2
		if (access( buf, F_OK ) == 0)
			goto got_resident;
d855 1
a855 1
		sprintf( buf, "%s%s.def", dir, stem );
d857 2
a858 2
		if (access( buf, F_OK ) == 0)
			goto got_resident;
d860 1
a860 1
		sprintf( buf, "%s%slib", dir, stem );
d862 2
a863 2
		if (access( buf, F_OK ) == 0)
			goto got_scanned;
d865 1
a865 1
		sprintf( buf, "%s%s.lib", dir, stem );
d867 2
a868 2
		if (access( buf, F_OK ) == 0)
			goto got_scanned;
d870 1
a870 1
		sprintf( buf, "%s%s", dir, stem );
d872 2
a873 4
		if (access( buf, F_OK ) == 0)
			goto got_scanned;

		sprintf( buf, "%slib%s.a", dir, stem );
d875 1
a875 2
		if (access( buf, F_OK ) == 0)
			goto got_scanned;
d877 16
a892 14
		if (streq( stem, "m" ))
		{
			/*
			 * UNIX style maths libraries
			 */
		 
			if (!STDLIBS)
			{
				AddLibraryName( "%sfplib.def",  libdir );
				AddLibraryName( "%sfpclib.def", libdir );
			}
			
			return;
		}
d894 17
a910 16

	error( "%s: could not find library '%s' in directory '%s'",
		ProgName, stem, dir );
		
	return;

got_scanned:
	AddLibraryName( "-l%s", buf );

	return;	

got_resident:
	AddLibraryName( "%s", buf );

	return;
	
d923 20
a942 12
	pid_t		pid;
	int		i;
	int		result 	= -1;
	int		argc   	= ListSize( (List *)nlist );
	char **		argv 	= (char **)SafeAlloc( (argc + 1) * sizeof( char * ) );
	NameNode *	pnode;


	if (USE_PIPE && command_line[ 0 ] != '\0')
	{
		strcat( command_line, "| " );
	}
d944 1
a944 5
	i = 0;

	for (pnode = (NameNode *)FirstNode( (List *)nlist );
	     pnode;
	     pnode = (NameNode *)NextNode( (Node *)pnode ) )
d946 4
a949 12
		argv[ i++ ] = pnode->name;

		if (USE_PIPE)
		{
			strcat( command_line, pnode->name );
			strcat( command_line, " " );

			continue;
		}
		
		if (VERIFY)
			printf( "%s ", pnode->name );
a950 7

	argv[ i ] = NULL;

	if (!USE_PIPE && VERIFY)
	{
		printf( "\n" );
	}
d952 22
a973 11
	if (!EXECUTE || USE_PIPE)
	{
		free( argv );

		return 0;
	}

	if ((pid = vfork()) == 0)
	{
		int	result;
		
d975 1
a975 4
		result = execvp( argv[ 0 ], argv );
		
		_exit( result );
	}
d977 19
a995 16
	if (pid == -1)
	{
		fail( "Failed to execute %s", argv[ 0 ] );
	}
	
	while (wait( &result ) == -1 && errno == EINTR)
	  ;

	if (result != 0)
	{
		error( "%s failed because %s exited with return code of %d",
			ProgName, argv[ 0 ], result );
	}
	
	return 0;
	
d1006 25
a1030 8
	pid_t		pid;
	int		result 	= -1;


	if (!USE_PIPE || command_line[ 0 ] == '\0')
	{
		return 0;
	}
a1031 11
	if (VERIFY)
	{
		printf( "%s\n", command_line );
	}

	if (!EXECUTE)
	{
		command_line[ 0 ] = '\0';
		
		return 0;
	}
d1033 1
a1033 1
	if ((pid = vfork()) == 0)
d1035 1
a1035 12
		char *	name;
		int	return_code;
		

		if ((name = strrchr( shell, '/' )) == NULL)
		{
			name = shell;
		}
	  
		return_code = execlp( shell, name, "-c", command_line, NULL );
		
		_exit( return_code );
d1038 1
a1038 6
	command_line[ 0 ] = '\0';

	if (pid == -1)
	{
		fail( "Failed to execute %s", shell );
	}
d1040 21
a1060 11
	while (wait( &result ) == -1 && errno == EINTR)
	  ;

	if (result != 0)
	{
		error( "%s failed because %s exited with return code of %d",
			ProgName, shell, result );
	}
	
	return 0;
	
d1075 11
a1085 11
	NameList	args;
	List *		plist = (List *)&args;


	InitList( plist );

	AddNamef( plist, "%s",    remover );
	AddNamef( plist, "%s.%s", pfile->root, pfile->ext );

	(void) ExecuteList( plist );

d1096 14
a1109 12
	NameList	args;
	List *		plist  = (List *)&args;
	int		result = 0;
	

	InitList( plist );

	AddNamef( plist, "%s",   c_compiler   );
	AddNames( plist, "%s",   &CompileOpts );
	AddNamef( plist, "%s.%s", fnode->root, fnode->oext );

	if (REDIRECT && !ASSEMBLE)
d1111 2
a1112 5
		if (ObjName != NULL)
		{
			AddName(  plist, "-s"    );
			AddName(  plist, ObjName );
		}
d1114 17
a1130 16
	else if (!USE_PIPE)
	{
		AddName(  plist, "-s"                );
		AddNamef( plist, "%s.s", fnode->root );
	}

	result = ExecuteList( plist );

	NCompiles++;

	LastCompile = fnode;

	fnode->ext  = DupName( "s" );

	return result;
	
d1141 24
a1164 24
	NameList	args;
	List *		plist  = (List *)&args;
	int		result = 0;
	

	InitList( plist );

	AddNamef( plist, "%s",    pre_processor );
	AddNames( plist, "%s",    &PreProcOpts  );
	AddNames( plist, "-D%s",  &Defines      );
	AddNames( plist, "-I%s",  &IncludeDirs  );
	AddNamef( plist, "%s.%s", fnode->root, fnode->oext );
	AddNamef( plist, "%s.i",  fnode->root   );

	result = ExecuteList( plist );

	NCompiles++;

	LastCompile = fnode;

	fnode->ext  = DupName( "i" );

	return result;
	
d1175 42
a1216 7
	NameList	args;
	List *		plist    = (List *)&args;
	bool		pipe_off = false;
	int		result   = 0;
	

	if (USE_PIPE)
d1218 1
a1218 5
		/* switch off piping for Fortran compiles */

		pipe_off = true;

		Flags &= ~FLAG_P;
d1220 1
a1220 7
	
	InitList( plist );

	AddNamef( plist, "%s",      f77_pass1   );
	AddNamef( plist, "%s.f",    fnode->root );

	if (ram_disk_present)
d1222 1
a1222 1
		AddName(  plist, "/ram/tmp"     );
d1224 5
a1228 1
	else
d1230 16
a1245 1
		AddName(  plist, "/helios/tmp"	);
d1247 17
a1263 62

	if (FortranP1Opts[ 0 ])
	{
		AddName( plist, ","           );
		AddName( plist, FortranP1Opts );
	}

	if ((result = ExecuteList( plist )) == 0)
	{
		InitList( plist );

		AddNamef( plist, "%s",      f77_pass2   );

		if (ram_disk_present)
		{
			AddName(  plist, "/ram/tmp"     );
		}
		else
		{
			AddName(  plist, "/helios/tmp"  );
		}
		
		AddNamef( plist, "%s.s",    fnode->root );
		
		if (FortranP2Opts[ 0 ] ||
		    FortranMapFile)
		{
			AddName( plist, "," );
			AddName( plist, "," );
			
			if (FortranP2Opts[ 0 ])
			{
				AddName( plist, FortranP2Opts );
			}
			else
			{
				AddName( plist, "," );
			}
			
			if (FortranMapFile)
			{
				AddName( plist, FortranMapFile );
			}
		}
		
		result = ExecuteList( plist );
	}


	NCompiles++;

	LastCompile = fnode;

	fnode->ext  = DupName( "s" );

	if (pipe_off)
	{
		Flags |= FLAG_P;
	}

	return result;
	
d1274 15
a1288 15
	NameList	args;
	List *		plist  = (List *)&args;
	int		result = 0;
	

	InitList( plist );

	AddNamef( plist, "%s",     m2_compiler );
	AddNames( plist, "%s",     &ModulaOpts );
	AddNamef( plist, "%s.def", fnode->root );

	result = ExecuteList( plist );

	return result;
	
d1299 28
a1326 13
	NameList	args;
	List *		plist  = (List *)&args;
	int		result = 0;
	char *		extension;	


	InitList( plist );

	AddNamef( plist, "%s",     m2_compiler );
	AddNames( plist, "%s",     &ModulaOpts );
	AddNamef( plist, "%s.mod", fnode->root );

	if (ram_disk_present)
d1328 3
a1330 2
		AddName(  plist, "-w"		);
		AddName(  plist, "/ram/tmp"     );
d1332 23
a1354 39
	else
	{
		AddName(  plist, "-w"		);
		AddName(  plist, "/helios/tmp"	);
	}

	LastCompile = fnode;

	if (REDIRECT && !ASSEMBLE)
	{
		if (ObjName != NULL)
		{
			AddName(  plist, "-s"    );
			AddName(  plist, ObjName );
			extension = "";
		}
	}
	else if (!ASSEMBLE)
	{
		AddName(  plist, "-s"                );
		AddNamef( plist, "%s.s", fnode->root );
		extension = "s";
	}
	else
	{
		AddName(  plist, "-o"                );
		AddNamef( plist, "%s.o", fnode->root );
		extension = "o";
		LastCompile = NULL;
	}

	result = ExecuteList( plist );

	NCompiles++;

	fnode->ext  = DupName( extension );

	return result;
	
d1365 12
a1376 6
	NameList	args;
	List *		plist  = (List *)&args;
	int		result = 0;
	

	if (strncmp( "lib", fnode->base, 3 ) != 0)
d1378 4
a1381 29
		InitList( plist );

		AddNamef( plist, "%s", macro );

		if (REDIRECT && !ASSEMBLE)
		{
			if (ObjName != NULL)
			{
				AddNamef( plist, "-o%s", ObjName );
			}
		}
		else if (!USE_PIPE)
		{
			AddNamef( plist, "-o%s.s", fnode->root );
		}
		
		AddNamef( plist, "-i%s", macdir );

		AddNames( plist, "%s",   &MacroOpts );

		AddNamef( plist, "%s%s", macdir, BASIC );

		AddNamef( plist, "%s.a", fnode->root );

		result = ExecuteList( plist );

		NCompiles++;

		fnode->ext = DupName( "s" );
d1383 1
a1383 1
	else
d1385 1
a1385 3
		AddLibraryName( "-l%s.%s", fnode->root, fnode->ext );
		
		(void) Remove( (Node *)fnode );
d1388 23
a1410 2
	return result;
	
d1421 24
a1444 12
	NameList	args;
	List *		plist  = (List *)&args;
	int		result = 0;

	
	InitList( plist );

	AddNamef( plist, "%s",   assembler     );
	AddName(  plist, "-p"                  ); /* only assemble */
	AddNames( plist, "%s",   &AssembleOpts );

	if (!USE_PIPE)
d1446 2
a1447 1
		AddNamef( plist, "%s.s", fnode->root );
d1449 28
a1476 41
	
	if (vfile != NULL)
	{
		AddNamef( plist, "-m%s", vfile );
	}
	
	if (REDIRECT && !LINK)
	{
		if (ObjName != NULL)
		{
			AddName( plist, "-o"    );
			AddName( plist, ObjName );
		}
	}
	else
	{
		AddName(  plist, "-o"                );
		AddNamef( plist, "%s.o", fnode->root );
	}

	result = ExecuteList( plist );

	if (streq( fnode->oext, "s" ))
	{
		NCompiles++;

		LastCompile = fnode;
	}
	else if (streq( fnode->oext, "c" ) && USE_PIPE)
	{
		(void) ExecuteCommandLine();
	}
	else
	{
		RemoveFile( fnode );
	}

	fnode->ext = DupName( "o" );

	return result;
	
d1487 14
a1500 8
	FileNode *	this;
	FileNode *	next;
	bool		result = TRUE;
	

	for (this = (FileNode *)FirstNode( (List *)&SourceFiles );
	     (this != NULL) && result;
	     this = next)
d1502 52
a1553 59
		/* initialize next so Remove() works safely */

	  	next = (FileNode *)NextNode( (Node *)this );

		switch (*this->ext)
		{
		case 'c':
			if (PRE_PROC_ONLY)
			{
				if (Pre_Process( this ) != 0)
					result = FALSE;
				break;
			}

			/* drop through */
			
		case 'i':
			if (C_Compile( this ) != 0)
				result = FALSE;

			if (USE_PIPE && NCfiles > 1)
			{
				Assemble( this );
			}
			
			break;

		case 'f':
			if (F77_Compile( this ) != 0)
				result = FALSE;
			break;

		case 'a':
			if (MacroPreProcess( this ) != 0)
				result = FALSE;
			break;

		default:
			/* Modula-2 extensions are three characters wide */

			if (streq( this->ext, "mod" ))
			{
				if (M2_CompileMod( this ) != 0)
					result = FALSE;
			}
			else if (streq( this->ext, "def" ))
			{
				if (M2_CompileDef( this ) != 0)
					result = FALSE;

				/* delete this node from the list of source  */
				/* files as it should not be included in the */
				/* file list passed to the linker.	     */

				Remove( (Node *)this );
			}

			break;
		}
d1555 4
a1558 3

	return result;
	
d1569 9
a1577 7
	FileNode *	this;
	bool		result = TRUE;
	

	for (this = (FileNode *)FirstNode( (List *)&SourceFiles );
	     this;
	     this = (FileNode *)NextNode( (Node *)this ))
d1579 5
a1583 8
		if (streq( this->ext, "s" ))
		{
			if (Assemble( this ) != 0)
			{
				result = FALSE;
				break;
			}
		}
d1585 4
a1588 3

	return result;
	
d1599 12
a1610 3
	NameList	args;
	List *		plist  = (List *)&args;
	int		result = 0;
d1612 1
a1612 4

	InitList( plist );

	if (JOIN)
d1614 1
a1614 19
		AddNamef( plist, "%s",    linker       );
		AddName(  plist, "-p"		       );
		AddNames( plist, "%s",    &LinkOpts    );

		if (!USE_PIPE || NCfiles == 0)
		{
			AddFiles( plist, "%s.%s", &SourceFiles );
		}

		if (vfile != NULL)
		{
			AddNamef( plist, "-m%s", vfile );
		}

		if (ObjName != NULL)
		{
			AddName(  plist, "-o" 	       );
			AddNamef( plist, "%s", ObjName );
		}
d1616 2
a1617 1
	else
d1619 1
a1619 48
		AddNamef( plist, "%s",	  linker       );
		AddNames( plist, "%s", 	  &LinkOpts    );
		
		if (vfile != NULL)
		{
			AddNamef( plist, "-m%s", vfile );
		}

		if (!NOLIBS)
		{
			if (NFfiles > 0)
			{
				AddNamef( plist, "%s%s",  libdir, link_fstart );
			}
			else if (NMfiles > 0)
			{
				AddNamef( plist, "%s%s",  libdir, link_m2start );
			}
			else
			{
				AddNamef( plist, "%s%s",  libdir, link_cstart );
				AddLibrary( libdir, link_clib );
			}
		}

		if (NSources > 1 || !USE_PIPE)
		{
			AddFiles( plist, "%s.%s", &SourceFiles 	);
		}
		else
		{
			AddName( plist, "-" );
		}

		AddNames( plist, "%s", 		  &LibraryNames );
		
		if (state != objed_suppressed)
		{
			AddNamef( plist, "-n%s",  ObjectName 	);
			AddNamef( plist, "-s%d",  StackSize 	);
			AddNamef( plist, "-h%d",  HeapSize 	);
		}

		if (ObjName != NULL)
		{		
			AddName(  plist, "-o" 			);
			AddNamef( plist, "%s",	  ObjName 	);
		}
d1621 2
a1622 11

	result = ExecuteList( plist );

	/*
	 * When one source is compiled and linked, the intermediate file is removed 
	 */

	if (!JOIN              &&
	    !USE_PIPE          &&
	    NCompiles   == 1   &&
	    LastCompile != NULL )
d1624 2
a1625 1
		RemoveFile( LastCompile );
d1627 27
a1653 2

	return (result == 0);
d1655 41
d1710 3
a1712 1
	for (; *s; s++)
d1714 40
a1753 43
		switch (*s)
		{
		case 'A':
			Warns = ~0;
			Errs  = ~0;
			break;
			
		case 'a':
			Warns |= WARN_a;
			break;
			
		case 'd':
			Warns |= WARN_d;
			break;
			
		case 'f':
			Warns |= WARN_f;
			break;
			
		case 's':
			Warns |= WARN_s;
			break;
			
		case 'v':
			Warns |= WARN_v;
			break;

		case 'c':
			Errs  |= ERR_c;
			break;
			
		case 'p':
			Errs  |= ERR_p;
			break;
			
		case 'z':
			Errs  |= ERR_z;
			break;

		default:
			error( "%s: Unknown option -w%c, ignored",
				ProgName, *s );
		}
d1755 2
a1756 1

d1766 3
a1768 1
	for (; *s; s++)
d1770 35
a1804 38
		switch (*s)
		{
		case 'A':
			Feats |= FEAT_s | FEAT_g;
			break;
			
		case 'f':
			Feats |= FEAT_f;
			break;
			
		case 'g':
			Feats |= FEAT_g;
			break;

		case 'h':
			Feats |= FEAT_h;
			break;
			
		case 'm':
			Feats |= FEAT_m;
			break;

		case 'n':
			Feats |= FEAT_n;
			break;
			
		case 's':
			Feats |= FEAT_s;
			break;

		case 'v':
			Feats |= FEAT_v;
			break;

		default:
			error( "%s: Unknown option -F%c, ignored",
				ProgName, *s );
		}
d1806 2
a1807 1

d1818 38
a1855 4
	static char buf[ ARGBUFSIZE ];


	if (Warns != 0)
d1857 4
a1860 12
		strcpy( buf, "-w" );
		
		if ((Warns & WARN_a) != 0) strcat( buf, "a" );
		if ((Warns & WARN_d) != 0) strcat( buf, "d" );
		if ((Warns & WARN_f) != 0) strcat( buf, "f" );
 		if ((Warns & WARN_s) != 0) strcat( buf, "s" );
		if ((Warns & WARN_v) != 0) strcat( buf, "v" );
	
		AddName( &CompileOpts, buf );
	}

	if (Errs != 0)
d1862 4
a1865 9
		strcpy( buf, "-e" );
		if ((Errs & ERR_c) != 0) strcat( buf, "c" );
		if ((Errs & ERR_p) != 0) strcat( buf, "p" );
		if ((Errs & ERR_z) != 0) strcat( buf, "z" );

		AddName( &CompileOpts, buf );
	}

	if (Feats != 0)
d1867 1
a1867 23
		strcpy( buf, "-f" );

		if ((Feats & FEAT_f) != 0) strcat( buf, "f" );
		if ((Feats & FEAT_h) != 0) strcat( buf, "h" );
		if ((Feats & FEAT_m) != 0) strcat( buf, "m" );
		if ((Feats & FEAT_v) != 0) strcat( buf, "v" );

 		AddName( &CompileOpts, buf );
		
		if ((Feats & FEAT_g) != 0)
		{
	 		AddName( &CompileOpts, "-pg0" );
		}	

		if ((Feats & FEAT_n) != 0)
		{
	 		AddName( &CompileOpts, "-pf0" );
		}	

		if ((Feats & FEAT_s) != 0)
		{
	 		AddName( &CompileOpts, "-ps1" );
		}
d1869 2
a1870 1

d1880 2
a1881 2
	AddNames( &CompileOpts, "-d%s", &Defines );

d1891 11
a1901 7
	static char	buffer[ ARGBUFSIZE ];
	NameNode *	this;
	char *		end;
	char *		start = path;
	

	while (path != NULL)
d1903 1
a1903 37
		end = strchr( start, ',' );
		
		if (end != NULL)
		{
			*end = '\0';
		}
		else
		{
			path = NULL;
		}

		strcpy( buffer, start );
			
		start = end + 1;
		
		/*
		 * add trailing / if none present and name is not blank
		 */

		if (buffer[ strlen( buffer ) - 1 ] != '/' && strlen( buffer ) > 0)
		{
			strcat( buffer, "/" );
		}

		/*
		 * check for and ignore duplicates, for faster compilation
		 */

		for ( this = (NameNode *)FirstNode( (List *)&IncludeDirs );
		      this;
		      this = (NameNode *)NextNode( (Node *)this) )
		{
			if (streq( this->name, buffer ))
				return;
		}

		AddName( &IncludeDirs, buffer );
d1905 33
a1937 1

d1947 11
a1957 7
	static char	buffer[ ARGBUFSIZE ];
	NameNode *	this;
	char *		end;
	char *		start = path;
	

	while (path != NULL)
d1959 1
a1959 37
		end = strchr( start, ',' );
		
		if (end != NULL)
		{
			*end = '\0';
		}
		else
		{
			path = NULL;
		}

		strcpy( buffer, start );
			
		start = end + 1;
		
		/*
		 * add trailing / if none present and name is not blank
		 */

		if (buffer[ strlen( buffer ) - 1 ] != '/' && strlen( buffer ) > 0)
		{
			strcat( buffer, "/" );
		}

		/*
		 * check for and ignore duplicates, for faster compilation
		 */

		for ( this = (NameNode *)FirstNode( (List *)&SymbolDirs );
		      this;
		      this = (NameNode *)NextNode( (Node *)this) )
		{
			if (streq( this->name, buffer ))
				return;
		}

		AddName( &SymbolDirs, buffer );
d1961 33
a1993 1

d1999 3
d2003 31
a2033 31
	static char	buffer[ ARGBUFSIZE ];
	NameNode *	this = (NameNode *)FirstNode( (List *)&IncludeDirs );


	if (this == NULL)
		return;
	
	strcpy( buffer, "-i" );

	for ( ;
	      this;
	      this = (NameNode *)NextNode( (Node *)this) )
	{
		strcat( buffer, this->name );
		strcat( buffer, "," );
	}

	buffer[ strlen( buffer ) - 1 ] = '\0'; 		/* remove trailing ',' */

	AddName( &CompileOpts, buffer ); 		/* -i version */

	/*
	 * start -j option 3 places futher on so that we miss the "./,"
	 * at the start of the -i option
	 */
	 
	buffer[ 3 ] = '-';
	buffer[ 4 ] = 'j';

	AddName( &CompileOpts, buffer + 3 ); 		/* -j version */

d2040 21
a2060 21
	static char	buffer[ ARGBUFSIZE ];
	NameNode *	this = (NameNode *)FirstNode( (List *)&SymbolDirs );


	if (this == NULL)
		return;
	
	strcpy( buffer, "-i" );

	for ( ;
	      this;
	      this = (NameNode *)NextNode( (Node *)this) )
	{
		strcat( buffer, this->name );
		strcat( buffer, "," );
	}

	buffer[ strlen( buffer ) - 1 ] = '\0'; 		/* remove trailing ',' */

	AddName( &ModulaOpts, buffer ); 		/* -i version */

d2070 12
a2081 8
	FileNode *	this;


	NAfiles = NCfiles = NFfiles = NSfiles = NDfiles = NMfiles = NSources = 0;

	for ( this = (FileNode *)FirstNode( (List *)&SourceFiles );
	      this;
	      this = (FileNode *)NextNode( (Node *)this ))
d2083 31
a2113 36
		NSources++;

		switch (*this->ext)
		{
		case 'i':		/* pre-processed C source */
		case 'c':
			NCfiles++;
			break;

		case 'f':
			NFfiles++;
			break;

		case 's':
			NSfiles++;
			break;

		case 'a':
			NAfiles++;
			break;

		case 'o':
		case 'p':
			break;

		default:
			if (streq( this->ext, "mod" ))
				NMfiles++;
			else if (streq( this->ext, "def" ))
				NDfiles++;
			else if (streq( this->ext, "lib" ))
				break;
			else
				fail( "unknown type of source file => %s.%s", this->root, this->ext );
			break;
		}
d2115 2
a2116 1

d2122 2
a2123 2
	int		argc,
	char **		argv )
d2125 167
a2291 167
	Object *	o;
	int		i 	 = 0x01020304;
	int		byteswap = *((char *)&i) == '\001';
	bool		succeded = TRUE;
		

	if ((shell = getenv( "SHELL" )) == NULL)
	{
		shell = SHELL;
	}
	
	if ((c_compiler = getenv( "C_COMPILER" )) == NULL)
	{
		c_compiler = C_COMPILER;
	}
	
	if ((pre_processor = getenv( "PRE_PROCESSOR" )) == NULL)
	{
		pre_processor = PRE_PROCESSOR;
	}
	
	if ((f77_pass1 = getenv( "F77_PASS1" )) == NULL)
	{
		f77_pass1 = F77_PASS1;
	}
	
	if ((f77_pass2 = getenv( "F77_PASS2" )) == NULL)
	{
		f77_pass2 = F77_PASS2;
	}
	
	if ((m2_compiler = getenv( "M2_COMPILER" )) == NULL)
	{
		m2_compiler = M2_COMPILER;
	}

	if ((assembler = getenv( "ASSEMBLER" )) == NULL)
	{
		assembler = ASSEMBLER;
	}
	
	if ((linker = getenv( "LINKER" )) == NULL)
	{
		linker = LINKER;
	}
	
	if ((remover = getenv( "REMOVER" )) == NULL)
	{
		remover = REMOVER;
	}
	
	if ((macro = getenv( "MACRO" )) == NULL)
	{
		macro = AMPP;
	}
	
	if ((macdir= getenv( "MACDIR" )) == NULL)
	{
		macdir = MACDIR;
	}

	if ((libdir = getenv( "C_LIBDIR" )) == NULL)
	{
		libdir = C_LIBDIR;
	}
	
	if ((incdir= getenv( "C_INCDIR" )) == NULL)
	{
		incdir = C_INCDIR;
	}

	if ((symdir= getenv( "SYMDIR" )) == NULL)
	{
		symdir = SYMDIR;
	}
	
	if ((link_helios = getenv( "LINK_HELIOS" )) == NULL)
	{
		link_helios= LINK_HELIOS;
	}
	
	if ((link_cstart = getenv( "LINK_CSTART" )) == NULL)
	{
		link_cstart= LINK_CSTART;
	}
	
	if ((link_clib = getenv( "LINK_CLIB" )) == NULL)
	{
		link_clib= LINK_CLIB;
	}
	
	if ((link_fstart = getenv( "LINK_FSTART" )) == NULL)
	{
		link_fstart= LINK_FSTART;
	}
	
	if ((link_m2start = getenv( "LINK_M2START" )) == NULL)
	{
		link_m2start= LINK_M2START;
	}

	if ((ObjectName = getenv( "OBJNAME" )) == NULL)
	{
		ObjectName = OBJNAME;
	}
	
	if ((machinename = getenv( "MACHINENAME" )) == NULL)
	{
		machinename = MACHINENAME;
	}

	if (getenv( "C_NONSTANDARD" ))
	{
		use_non_standard_features = true;
	}
	
	InitList( &IncludeDirs  );
	InitList( &SymbolDirs   );
	InitList( &LibraryNames );
	InitList( &Defines      );
	InitList( &SourceFiles  );
	InitList( &CompileOpts  );
	InitList( &PreProcOpts  );
	InitList( &ModulaOpts   );
	InitList( &AssembleOpts );
	InitList( &MacroOpts    );
	InitList( &LinkOpts     );

	FortranP1Opts[ 0 ] = '\0';
	FortranP2Opts[ 0 ] = '\0';
	FortranMapFile     = NULL;

	NCompiles = 0;
	Flags     = Warns = Errs = 0;

	ProgName  = argv[ 0 ];
	ObjName   = ObjectName;

	HeapSize  = StackSize = 5000;

	if (byteswap)
	{
		AddName( &CompileOpts, "-b" );
	}

	/* There does not seem to be an easy way to define the following */
	/* automatically without introducing some circularity		 */
	
	/* O/S identification */

	AddName( &Defines, "helios" );
	AddName( &Defines, "__HELIOS" );

	/* Processor identification */

	AddName( &Defines, "transputer" );
	AddName( &Defines, "__TRAN" );

	/* shorthand for both */

	AddName( &Defines, "__HELIOSTRAN" );

	AddName( &Defines, machinename );

	AddInclude( "." );
	AddSymbol ( "." );

d2293 1
a2293 1
	ram_disk_present = false;
d2295 13
a2307 13
	if ((o = Locate( NULL, "/loader/ram" )) == NULL)
	  {
	    ram_disk_present = false;
	  }
	else
	  {
	    ram_disk_present = true;
	    
	    Close( o );
	    
	    AddInclude( "/ram/include/" );
	    AddSymbol ( "/ram/symbols/" );
	  }
d2309 6
a2314 6

	if (use_non_standard_features)
	{
		Flags |= FLAG_P;
	}
	
d2316 4
a2319 4
	printf("argv:");
	for (i =1 ; i < argc; i++ )
	  printf(" %s",argv[i]);
	printf("\n");
d2321 5
a2325 1
	for (i = 1; i < argc; i++ )
d2327 53
a2379 3
		char *	arg = argv[ i ];

		if (arg[ 0 ] == '-')
d2381 2
a2382 496
			switch (arg[ 1 ])
			{
			case '\0': /* lone "-" on command line */

				usage();

				break;

			case 'A': /* pass option to linker */

				AddName( &LinkOpts, &arg[ 2 ] );

				break;

			case 'B': /* don't link with any libraries */

				Flags |= FLAG_B;
				
				if (state == normal)
					state = objed_suppressed;
					
				break;

			case 'C': /* perform array bound checking */

				strcat( FortranP2Opts, "+B" );

				break;
				
			case 'D': /* macro definitions */

				AddName( &Defines, &arg[ 2 ] );

				if (streq( &arg[ 2 ], "_BSD" ))
					AddLibrary( libdir, "bsd" );
					
				break;

			case 'E': /* pre-process only */
			
				Flags |= FLAG_p;

				break;

			case 'F': /* compiler features */

				ParseFeatures( &arg[ 2 ] );

				break;

			case 'I': /* include directory */

				if (arg[ 2 ] != '\0')
				{
					AddInclude( &arg[ 2 ] );
					AddSymbol ( &arg[ 2 ] );
				}
				else
				{
					if (++i >= argc)
					{
						fail( "No filename following -I" );
					}

					AddInclude( argv[ i ] );
					AddSymbol ( argv[ i ] );
				}

				break;

			case 'K': /* pass option to Modula-2 compiler */

				AddName( &ModulaOpts, &arg[ 2 ] );
				break;


			case 'M': /* produce map file */

				FortranMapFile = &arg[ 2 ];
				break;

			case 'O': /* Optimise */

				Flags |= FLAG_O;
				break;

			case 'P': /*pass on option to pre-processor */

				AddName( &PreProcOpts, &arg[ 2 ] );
				break;

			case 'R': /* use RAM disk for temporary files even if ram disk is not present */

				ram_disk_present = true;
				break;
				
			case 'S': /* Assemble only */

				Flags |= FLAG_S;
				break;

			case 'T': /* Transputer type */

				switch (arg[ 2 ])
				{
					case '9':
						AddName( &ModulaOpts,  "-t8" );
						AddName( &CompileOpts, "-t9" );
						AddName( &Defines,    "T800" );

						strcat( FortranP2Opts, "+F" );

						break;

					case '8':
						AddName( &ModulaOpts,  "-t8" );
						AddName( &CompileOpts, "-t8" );
						AddName( &Defines,    "T800" );

						strcat( FortranP2Opts, "+F" );

						break;

					case '5':
						AddName( &ModulaOpts,  "-t5" );
						AddName( &CompileOpts, "-t5" );
						AddName( &Defines,    "T400" );

						break;

					case '4':
						AddName( &ModulaOpts,  "-t4" );
						AddName( &CompileOpts, "-t4" );
						AddName( &Defines,    "T400" );

						break;

					default:
						error( "%s: Unknown -T option '%c', ignored",
							ProgName, arg[ 2 ] );

						break;
				}

				break;

			case 'V': /* verbose */

				Flags |= FLAG_V;
				break;

			case 'W': /* warning level */

				strcat( FortranP1Opts, "+W" );

				strcat( FortranP1Opts, &arg[ 2 ] );

				break;

			case 'X': /* Cross reference width */

				strcat( FortranP1Opts, "+X" );

				strcat( FortranP1Opts, &arg[ 2 ] );

				break;

			case 'Z': /* pass on option to FORTRAN compiler */

				if (arg[ 2 ] == '\0')
				{
					if (++i >= argc)
					{
						fail( "No text following -Z option" );
					}

					strcat( FortranP1Opts, &arg[ 2 ] );
				}
				else
				{
					strcat( FortranP1Opts, &arg[ 2 ] );
				}

				break;

			case 'a': /* pass on option to assembler */

				if (arg[ 2 ] == '\0')
				{
					if (++i >= argc)
					{
						fail( "No text following -a option" );
					}

					AddName( &AssembleOpts, &arg[ 2 ] );
				}
				else
				{
					AddName( &AssembleOpts, &arg[ 2 ] );
				}

				break;

			case 'b': /* don't link with standard maths libraries */

				Flags |= FLAG_b;

				break;

			case 'c': /* compile only */

				Flags |= FLAG_c;

				break;

			case 'd': /* .def output file */

				AddName( &LinkOpts, &arg[ 0 ] );

				break;
				
			case 'e': /* enforce standards */

				switch (arg[ 2 ])
				{
					case '6':
						strcat( FortranP1Opts, "+6" );
						break;

					case '7':
						strcat( FortranP1Opts, "+7" );
						break;

					default:
						error( "%s: Unknown -e option %c, ignored",
							ProgName, arg[ 2 ] );
						break;
				}

				break;

			case 'f': /* virtual memory file name */

				if (arg[ 2 ] != '\0')
				{
					vfile = &arg[ 2 ];
				}
				else
				{
					if (++i >= argc)
					{
						fail( "No filename following -f" );
					}

					vfile = argv[ i ];
				}

				break;

			case 'g': /* compile for debugging */

				AddName( &CompileOpts, "-g" );

				AddName( &ModulaOpts,  "-g" );
				
				break;

			case 'h': /* specify heap size */

				if (!strncmp( &arg[ 1 ], "help", 4 ))
				{
					usage();
					
					return -1;
				}
				else if ((HeapSize = atoi( &arg[ 2 ] )) < 200)
				{				
					fail( "Heap size too small" );
				}

				state = objed_enabled;
				
				break;

			case 'j': /* join asm files */

				Flags |= FLAG_j;

				break;

			case 'L':
			case 'l': /* specify library */

				AddLibrary(libdir, &arg[2] );

				break;

			case 'm': /* compile for library */

				AddName( &CompileOpts, "-l" );

				AddName( &ModulaOpts,  "-m" );

				strcat( FortranP2Opts, "+M" );

				break;

			case 'n': /* report commands executed OR specify object name */

				if (arg[ 2 ] != '\0')
				{
					ObjectName = &arg[ 2 ];
				}
				else
				{
					Flags |= FLAG_n;
					Flags |= FLAG_v; 	/* must be verbose too */
				}

				break;

			case 'o': /* output file name */

				Flags |= FLAG_o;
				
				if (arg[ 2 ] != '\0')
				{
					ObjName = &arg[ 2 ];

					if (streq( ObjectName, OBJNAME ))
					{
						ObjectName = ObjName;
					}
					
					if (streq( ObjName, "-" ))
					{
						ObjName    = NULL;
						ObjectName = OBJNAME;
					}
				}
				else
				{
					i++;

					if (i >= argc)
					{
						fail( "No filename following -o" );
					}

					ObjName = argv[ i ];
					
					if (streq( ObjectName, OBJNAME ))
					{
						ObjectName = ObjName;
					}
					
					if (streq( ObjName, "-" ))
					{
						ObjName    = NULL;
						ObjectName = OBJNAME;
					}
				}

				break;

			case 'p': /* compile for profiling */

				AddName( &CompileOpts, "-p" );

				AddName( &ModulaOpts,  "-p" );
				
				strcat( FortranP2Opts, "+P" );

				break;

			case 'q': /* compiler debugging features */

				AddNamef( &CompileOpts, "%s", &arg[ 0 ] );

				break;
				
			case 'r': /* compile for device driver */

				AddName( &CompileOpts, "-r" );

				AddName( &ModulaOpts,  "-r" );

				strcat( FortranP2Opts, "+R" );

				break;

			case 's': /* specify stack size */

				if (arg[ 2 ] != '\0')
				  {
				    StackSize = atoi( &arg[ 2 ] );
				  }
				else
				  {
				    if (++i >= argc)
				      {
					fail( "no number following -s" );
				      }
				    else
				      {
					StackSize = atoi( argv[ i ] );
				      }
				  }

				if (StackSize < 200)
				{
					fail( "Stack size too small" );
				}

				state = objed_enabled;
				
				break;

			case 't': /* compile tracing code */

				AddName( &ModulaOpts, "-t" );
				
				strcat( FortranP1Opts, "+T" );

				break;

			case 'v': /* verify */
				strcat( FortranP1Opts, "+V" );
				strcat( FortranP2Opts, "+V" );

				Flags |= FLAG_v;

				break;

			case 'w': /* warning flags */

				ParseWarnings( &arg[ 2 ] );

				break;

			case 'y': /* pass on option to macro pre-processor */

				if (arg[ 2 ] == '\0')
				{
					if (++i >= argc)
					{
						fail( "No text following -y option" );
					}

					AddName( &MacroOpts, argv[ i ] );
				}
				else
				{
					AddName( &MacroOpts, &arg[ 2 ] );
				}

				break;

			case 'z': /* pass on option to C compiler */

				if (arg[ 2 ] == '\0')
				{
					if (++i >= argc)
					{
						fail( "No text following -z option" );
					}

					AddName( &CompileOpts, &arg[ 2 ] );
				}
				else
				{
					AddName( &CompileOpts, &arg[ 2 ] );
				}

				break;

			case 'G': /* unused */
			case 'H': /* unused */
			case 'J': /* unused */
			case 'N': /* unused */
			case 'U': /* unused */
			case 'Q': /* unused */
			case 'Y': /* unused */
			case 'i': /* unused */
			case 'k': /* unused */
			case 'u': /* unused */
			case 'x': /* unused */
			default:

				error( "%s: Unknown option '%s' passed to linker",
					ProgName, &arg[ 0 ] );

				AddName( &LinkOpts, &arg[ 0 ] );
				
				break;
			}
d2384 1
a2384 1
		else
d2386 7
a2392 3
			AddFile( &SourceFiles, arg );

			NSources++;
d2394 37
a2430 14
	}

	AddInclude( incdir );
	AddSymbol ( symdir );

	CountSources();

	if (NSources == 0)
	{
		fail( "nothing to compile" );
	}
	else if (NSources == 1)
	{
		if (use_non_standard_features && streq( ObjectName, OBJNAME ))
d2432 37
a2468 4
			/* use the source file name as the output name */

			ObjName    = ((FileNode *)FirstNode( &SourceFiles ))->base;
			ObjectName = ObjName;
d2470 353
d2824 1
a2824 1
	else if (NSources > 1 && !LINK && REDIRECT )
d2826 3
a2828 1
		fail( "Invalid -o option: multiple output files" );
d2830 14
a2843 7
	
	AddWarningsAndFeatures();
	AddDefines();
	AddIncludeOpts();
	AddSymbolOpts();

	if (OPTIMISE)
d2845 4
a2848 2
		AddName( &AssembleOpts, "-f" ); /* full link */
		AddName( &LinkOpts,     "-f" );
d2850 51
a2900 35

	if (VERBOSE)
	{
		AddName( &AssembleOpts, "-v" );
		AddName( &ModulaOpts,   "-v" );
		AddName( &LinkOpts,     "-v" );
	}

	if (STDLIBS)
	{
		/* add standard libraries */

	        AddLibrary( libdir, link_helios );
	}

	succeded = DoCompiles();

	if (succeded && ASSEMBLE)
	{
		if (!LINK || NCfiles + NFfiles + NSfiles + NAfiles + NMfiles > 1)
			succeded |= DoAssembles();

		/* attempt to link only if not all Modula-2 .def files given */

		if (NSources != NDfiles && LINK && succeded)
	        	succeded = DoLink();
	}

	if (succeded && USE_PIPE)
	{
		succeded = (ExecuteCommandLine() == 0);
	}
	
	return (succeded ? 0 : -1);
	
@


1.21
log
@added -T9 option and more fixes to pipe handling
@
text
@d16 2
a17 2
#define REVISION	44
#define DATE		09/01/91
d103 2
d131 3
d135 1
d141 3
d145 1
d640 2
a641 1
		error( "warning - blank(s) found in argument '%s'", name );
d974 2
a975 1
		error( "%s failed because %s exited with return code of %d", ProgName, argv[ 0 ], result );
d978 1
a978 1
	return result;
d1039 2
a1040 1
		error( "%s failed because %s exited with return code of %d", ProgName, shell, result );
d1043 1
a1043 1
	return result;
d1451 1
a1451 1
		ExecuteCommandLine();
d1737 2
a1738 1
			error( "Unknown option -w%c, ignored", *s );
d1788 2
a1789 1
			error( "Unknown option -F%c, ignored", *s );
d2447 2
a2448 1
						error( "Unknown -T option '%c', ignored", arg[ 2 ] );
d2543 2
a2544 1
						error( "Unknown -e option %c, ignored\n", arg[ 2 ] );
d2798 2
a2799 1
				error( "Unknown option '%s' passed to linker", &arg[ 0 ] );
d2873 1
a2873 1
	        	DoLink();
d2878 1
a2878 1
		succeded = ExecuteCommandLine();
@


1.20
log
@removed dash from line 1633 (oops)
@
text
@d11 2
a12 2
 * RCS version: $Revision: 1.19 $
 * RCS date:    $Date: 91/01/08 15:40:56 $
d16 2
a17 2
#define REVISION	43
#define DATE		08/01/91
d101 2
d486 1
a486 1
	error( "-T[4|5|8] 	Specify Transputer type.(5 => T425)" );
d1584 1
a1584 1
		if (USE_PIPE && NCfiles == 0)
d2399 9
d2411 1
a2411 1
						AddName( &Defines, "T800" );
d2420 1
a2420 1
						AddName( &Defines, "T400" );
d2427 1
a2427 1
						AddName( &Defines, "T400" );
@


1.19
log
@fixed pipes for single file compilation, but requires new version of asm (RCS version 1.6 or later)
@
text
@d11 2
a12 2
 * RCS version: $Revision$
 * RCS date:    $Date$
d1633 1
a1633 1
-
@


1.18
log
@oops, fixed typo of execvp for execlp
@
text
@d11 2
d988 1
d990 2
d1629 5
a1633 1
		
@


1.17
log
@now at version 43
added command line optin -T5 (for the T425)
added enironment variable C_NONSTANDARD which enables :-
  a.out not used as output name when only 1 file is being compiled
  pipes are used to connect compilation processes
@
text
@d1003 1
a1003 1
		return_code = execvp( shell, name, "-c", command_line, NULL );
@


1.16
log
@merged martyns changes back
@
text
@d8 3
d14 2
a15 2
#define REVISION	41
#define DATE		09/10/90
d91 4
a94 1
 * 42 - no longer passes signals on to child, posix does this automatically
d96 3
d101 4
d112 2
a113 1
#include <errno.h>
d117 1
d119 5
a210 2
static int		Flags;

d217 1
a235 1
static char *		objname;
d238 2
d242 10
a251 9
#define FLAG_S		(1 << 2)
#define FLAG_V		(1 << 3)
#define FLAG_b  	(1 << 4)
#define FLAG_c		(1 << 5)
#define FLAG_j		(1 << 6)
#define FLAG_n		(1 << 7)
#define FLAG_o		(1 << 8)
#define FLAG_p		(1 << 9)
#define FLAG_v		(1 << 10)
d264 1
d296 1
a296 1
#define NEW(_type)	(_type *)SafeAlloc( sizeof(_type) )
d299 3
d304 1
a304 1
#define streq( s1, s2 )		(strcmp( s1, s2 ) == 0)
d322 2
d325 2
d349 4
d377 1
a377 1
	if ( ptr == NULL )
a392 1
#if 1
d423 1
a423 1
#endif
d434 1
a434 1
	error( "-b		Don't link with standard libraries (fplib and fpclib)." );
d467 1
a467 1
	error( "                   'n' do not put arrays or structs on vector stack" );
d471 2
a472 2
	error( "-I<dir> 	Specify a directory to be searched for #include or");
	error( "		Modula-2 symbol files." );
d478 2
a479 2
	error( "-R		Force use of RAM disk for temporary FORTRAN and");
	error( "		Modula-2 files, even if RAM disk is not loaded" );
d482 1
a482 1
	error( "-T[4|8] 	Specify Transputer type." );
d489 1
d510 3
a513 1
#if 1
d528 1
a528 1
#endif
d567 1
a567 1
		return Null(Node);
d714 1
a714 1
		*p++ = '\0';
d752 3
a754 3
	for ( this = (NameNode *)FirstNode( (List *)plist );
	      this;
	      this = (NameNode *)NextNode( (Node *)this ))
d774 3
a776 3
	for ( this = (FileNode *)FirstNode( (List *)plist );
	      this;
	      this = (FileNode *)NextNode( (Node *)this ))
d883 2
d892 1
a897 1
	pid_t		pid;
d899 6
d907 3
a909 3
	for ( pnode = (NameNode *)FirstNode( (List *)nlist );
	      pnode;
	      pnode = (NameNode *)NextNode( (Node *)pnode ) )
d913 8
d927 1
a927 1
	if (VERIFY)
d932 1
a932 1
	if (!EXECUTE)
d938 1
a938 1
	
d942 2
a943 1

d954 2
a955 1
	while( wait( &result ) == -1 && errno == EINTR );
d967 2
d970 59
d1045 1
a1045 1
	AddNamef( plist, "%s", remover );
d1079 1
a1079 1
	else
d1112 4
a1115 4
	AddNamef( plist, "%s", pre_processor );
	AddNames( plist, "%s", &PreProcOpts );
	AddNames( plist, "-D%s", &Defines );
	AddNames( plist, "-I%s", &IncludeDirs );
d1117 1
a1117 1
	AddNamef( plist, "%s.i", fnode->root );
d1140 3
a1142 2
	List *		plist  = (List *)&args;
	int		result = 0;
d1145 9
d1222 5
d1348 1
a1348 1
		else
d1396 5
a1400 1
	AddNamef( plist, "%s.s", fnode->root   );
d1411 1
a1411 1
			AddName(  plist, "-o"   );
d1429 4
a1461 1
		next = (FileNode *)NextNode( (Node *)this );
d1463 2
d1474 1
d1480 6
d1500 1
d1514 1
a1575 1
		AddFiles( plist, "%s.%s", &SourceFiles );
d1577 5
d1619 5
a1624 1
		AddFiles( plist, "%s.%s", 	  &SourceFiles 	);
d1647 4
a1650 3
	if (!JOIN &&
	    NCompiles == 1 &&
	    LastCompile != NULL)
d2039 1
a2039 1
		case 'i':
d2085 6
d2182 1
a2182 1
	if ((objname = getenv( "OBJNAME" )) == NULL)
d2184 1
a2184 1
		objname = OBJNAME;
d2191 5
d2217 1
a2217 1
	ObjName   = ObjectName = objname;
d2230 1
d2235 1
d2240 1
d2248 3
d2264 7
a2270 1
	  
d2273 2
a2274 1
	for (i =1 ; i < argc; i++ ) printf(" %s",argv[i]);
d2277 1
a2277 1
	for (i =1 ; i < argc; i++ )
d2281 1
a2281 1
		if (arg[0] == '-')
d2316 1
a2316 1
				if( streq( &arg[2], "_BSD" ) )
a2355 1

a2361 1

a2371 1

d2375 2
a2376 4
				{
					ram_disk_present = true;
				}
				
d2389 1
a2392 2
						AddName( &ModulaOpts, "-t8" );

d2397 7
d2405 1
a2408 2
						AddName( &CompileOpts, "-t4" );

d2412 1
a2412 1
						error( "Unknown -T option %c, ignored", arg[ 2 ] );
a2421 1

a2701 5
/* MJT 23/10/90 Don't pass this option on - cc doesn't know what to do with it

				AddName( &CompileOpts, "-v" );
*/
				
d2761 1
a2761 1
				error( "Unknown option %s passed to linker", &arg[ 0 ] );
d2785 5
d2791 5
a2795 1
	if (NSources > 1 && !LINK && REDIRECT )
d2799 1
a2799 1
		
d2821 2
a2822 7
#if 0
		AddLibraryName( "%sfplib.def",  libdir );
		AddLibraryName( "%sfpclib.def", libdir );
		AddLibraryName( "%sservlib.def", libdir );
#else
		AddLibrary( libdir, link_helios );
#endif
d2833 1
d2838 5
@


1.15
log
@signal handling fixed, some tidies to help text
@
text
@d431 1
a431 1
	error( "                   'f' " );
d435 1
d437 1
a437 1
	error( "                   'v' warns of unused functions and varaibles," );
@


1.14
log
@fixed help spelling mistakes, etc.
@
text
@d88 2
d99 1
a99 2
#include <posix.h>
#include <signal.h>
d429 1
a429 1
	error( "-E		pre-process only - do not compile" );
d431 1
a431 1
	error( "                   'f' removes procedure names from the code," );
a434 1
	error( "                   'n' don't put vecs/structs on vector stack," );
d436 1
a436 1
	error( "                   'v' warns of unused functions and variables," );
d438 2
a439 1
	error( "-I<dir> 	Specify a directory to be searched for #include or M2 symbol files." );
d445 2
a446 1
	error( "-R		force use of RAM disk for temporary FORTRAN and Modula-2 files, even if RAM disk is not loaded" );
a846 11
static int 	pid;	/* globals so that CatchSignal() can pass on signals to the correct process */


static void
CatchSignal( int signal )
{
	kill( pid, signal );
	
} /* CatchSignal */


a853 1
	VoidFnPtr	old_handler;
d859 1
a859 1

a885 2

	old_handler = signal( SIGINT, CatchSignal );
d890 1
a890 2
		
	
d901 1
a901 1
	wait( &result );
a907 2
	signal( SIGINT, old_handler );
	
d1928 1
a1928 2
		

@


1.13
log
@*** empty log message ***
@
text
@d430 1
a430 1
	error( "                   'f' " );
d434 1
d436 1
a436 1
	error( "                   'v' warns of unused functions and varaibles," );
@


1.12
log
@stopped -v option being passed to cc
@
text
@@


1.11
log
@fixed scanned library poarsing
@
text
@d2537 2
d2540 1
@


1.10
log
@added -y option
@
text
@d1251 6
@


1.9
log
@fixed compile for library option for the C compiler
@
text
@d11 2
a12 2
#define REVISION	40
#define DATE		20/08/90
d86 2
d163 1
d421 3
a423 2
	error( "-z<text>	Pass <text> as an option to C compiler." );
	error( "-A<text>	Pass <text> as an option to linker." );
d584 5
d917 1
a917 1
		error( "%s failed because %s returned with return code of %d", ProgName, argv[ 0 ], result );
d1238 3
d1242 1
d1908 1
d2047 1
d2271 13
a2283 1
				strcat( FortranP1Opts, &arg[ 2 ] );
d2287 8
a2294 1
			case 'a': /*pass on option to assembler */
d2296 6
a2301 1
				AddName( &AssembleOpts, &arg[ 2 ] );
d2543 18
d2563 13
a2575 1
				AddName( &CompileOpts, &arg[ 2 ] );
a2589 1
			case 'y': /* unused */
@


1.8
log
@added missing return statement in AddLibrary()
@
text
@d2361 1
a2361 1
				AddName( &CompileOpts, "-m" );
@


1.7
log
@fixed bug with -j option having / in it's path
@
text
@d812 2
@


1.6
log
@fixed addition of multiple extensions to libary names
@
text
@d1816 7
a1822 2
	buffer[ 1 ] = '-';
	buffer[ 2 ] = 'j';
d1824 1
a1824 1
	AddName( &CompileOpts, buffer+1 ); 		/* -j version */
@


1.5
log
@MACDIR environment variable added for ampp *.m files
@
text
@d11 1
a11 1
#define REVISION	39
d81 1
a81 1
 * 39 - added function AddLibraryName() to add names to the library list. but
a97 1

d99 1
d357 6
a362 4
	int err = dup(2);
	int pid;
	int pfds[2];
	pipe(pfds);
d366 1
a366 1
	if( pid == 0 )
d368 7
a374 3
		dup2(pfds[0],0);
		close(pfds[0]);close(pfds[1]);
		execlp("more","more", 0);
d376 2
a377 1
		_exit(0);
d380 4
a383 2
	if( pid == -1 ) close(err);
	else dup2(pfds[1],2);
d385 2
a386 2
	close(pfds[0]);close(pfds[1]);
	
d471 1
a471 1
	if( pid >= 0 ) 
d473 11
a483 6
		int stat;
		int p;
		close(2);
		p = wait(&stat);
		dup2(err,2);
		close(err);
d748 24
a771 1
	sprintf( buf, "%s%slib.def", dir, stem );
d773 2
a774 2
	if (access( buf, F_OK ) == 0)
		goto got_resident;
d776 4
a779 1
	sprintf( buf, "%s%s.def", dir, stem );
d781 16
a796 2
	if (access( buf, F_OK ) == 0)
		goto got_resident;
d798 8
a805 25
	sprintf( buf, "%s%slib", dir, stem );
	
	if (access( buf, F_OK ) == 0)
		goto got_scanned;
	
	sprintf( buf, "%s%s.lib", dir, stem );
	
	if (access( buf, F_OK ) == 0)
		goto got_scanned;
	
	sprintf( buf, "%s%s", dir, stem );
	
	if (access( buf, F_OK ) == 0)
		goto got_scanned;

	sprintf( buf, "%slib%s.a", dir, stem );
	
	if (access( buf, F_OK ) == 0)
		goto got_scanned;
	
	if (streq( stem, "m" ))
	{
		/*
		 * UNIX style maths libraries
		 */
d807 5
a811 4
		if (!STDLIBS)
		{
			AddLibraryName( "%sfplib.def",  libdir );
			AddLibraryName( "%sfpclib.def", libdir );
d814 3
a816 5
	else
	{
		error( "%s: could not find library %s in directory %s",
			ProgName, stem, dir );
	}
@


1.4
log
@if -D_BSD is seen, adds -lbsd automatically
@
text
@d117 1
d208 1
d449 1
d451 1
a451 1
	error( "C_INCDIR	Pathname of the standard header directory." );
d1190 2
a1191 2
		AddNamef( plist, "-i%s", incdir );
		AddNamef( plist, "%s%s", incdir, BASIC );
d1926 5
@


1.3
log
@new version uploaded, uses c0.o, c.lib and helios.lib for linking.
@
text
@a85 1
 * $Log$
a87 2
static char *rcsid = "$Header: /usr/perihelion/Helios/cmds/com/RCS/c.c,v 1.2 90/08/23 09:50:36 nick Exp Locker: nick $";

d1418 1
a1863 2
	if( NCfiles ) AddLibrary( libdir, link_clib );

d2078 3
@


1.2
log
@*** empty log message ***
@
text
@d11 2
a12 2
#define REVISION	38
#define DATE		09/08/90
d81 6
d89 1
a89 1
static char *rcsid = "$Header: /usr/perihelion/Helios/cmds/com/RCS/c.c,v 1.1 90/08/22 16:00:32 james Exp Locker: james $";
d102 2
d114 3
a116 1
#define LINK_CSTART	"cstart.o"
d123 1
a123 1
#define MACHINENAME	"B008"
d206 1
d208 1
d357 23
d453 1
d455 1
d461 11
d595 38
d772 2
a773 2
			AddNamef( &LibraryNames, "%sfplib.def",   libdir );
			AddNamef( &LibraryNames, "%sfpclib.def",  libdir );
d785 1
a785 1
	AddNamef( &LibraryNames, "-l%s", buf );
d790 1
a790 1
	AddNamef( &LibraryNames, "%s", buf );
d1866 2
d1942 5
d1952 5
d2005 4
a2008 1
	AddName( &Defines, machinename );
d2010 3
d2014 6
a2305 1
				/*AddNamef( &LibraryNames, "%s%slib.def", libdir, &arg[ 2 ] );*/
d2525 7
a2531 4

		AddNamef( &LibraryNames, "%sfplib.def",  libdir );
		AddNamef( &LibraryNames, "%sfpclib.def", libdir );
		AddNamef( &LibraryNames, "%sservlib.def", libdir );
@


1.1
log
@Initial revision
@
text
@d83 1
a83 1
static char rcsid[] = "$Header$";
@
